- en: Chapter 5. Creating Your Own Module
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章 创建自己的模块
- en: Nginx allows you to extend functionality by writing new modules in plain C.
    This chapter gives a brief introduction to creating your own modules. It is a
    quick reference to the module system in Nginx, and the internal architecture of
    Nginx, which makes extension possible. It introduces different categories of modules
    and add-ons you can create at a high level. This chapter will also contain a quick
    introduction of NDK, a special module in Nginx used as a basis of other modules.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Nginx 允许通过用纯 C 语言编写新的模块来扩展功能。本章简要介绍了如何创建自己的模块。它是 Nginx 模块系统的快速参考，并介绍了使扩展成为可能的
    Nginx 内部架构。它以高层次的方式介绍了可以创建的不同类别的模块和插件。本章还将简要介绍 NDK，这是 Nginx 中作为其他模块基础的特殊模块。
- en: 'The topics covered are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题如下：
- en: Concept of module chaining and delegation in Nginx
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nginx 中模块链式调用和委托的概念
- en: Handler modules
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理器模块
- en: Filter modules
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤器模块
- en: Load balancer modules
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负载均衡器模块
- en: '**Nginx Development Toolkit** (**NDK**): The NDK is an Nginx module that is
    designed to extend the core functionality of the excellent Nginx web server, in
    a way that can be used as a basis of other Nginx modules'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Nginx 开发工具包** (**NDK**)：NDK 是一个 Nginx 模块，旨在以一种可以作为其他 Nginx 模块基础的方式扩展优秀的 Nginx
    Web 服务器的核心功能。'
- en: Sample source code of a custom Nginx module
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义 Nginx 模块的示例源代码
- en: At the end of this chapter, the advanced users will have an idea about internal
    Nginx architecture, and what is the basis of creating your own third-party module.
    Readers should be able to know how to use NDK; the source code will help them
    see a very simple self-written module in action.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结束时，进阶用户将了解 Nginx 内部架构，并了解创建自己第三方模块的基础。读者应能学会如何使用 NDK；源代码将帮助他们看到一个非常简单的自编写模块如何运行。
- en: Nginx module delegation
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Nginx 模块委托
- en: Nginx has a very modular architecture. All major operations that Nginx performs
    are carried out by modules. All Nginx modules are built in at compile time and
    are not loaded dynamically.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Nginx 拥有非常模块化的架构。Nginx 执行的所有主要操作都是通过模块完成的。所有 Nginx 模块在编译时构建，并且不会动态加载。
- en: Module delegation can also be called **module chaining**. The core pretty much
    does the basic stuff related to setting up the connection and taking care of things
    related to the protocol. It then sets up a chain of modules to execute, each taking
    care of a certain phase or stage of request processing.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 模块委托也可以称为 **模块链式调用**。核心基本上完成与设置连接和处理协议相关的基础工作。然后它设置一个模块链来执行，每个模块处理请求处理的某个阶段或步骤。
- en: The module-based noncentralized architecture makes it possible for advanced
    users to develop a module that does something they want.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 基于模块的非集中化架构使得高级用户能够开发出符合其需求的模块。
- en: The following are the different types of Nginx modules.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是不同类型的 Nginx 模块。
- en: Handlers
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理器
- en: 'There is a handler for each defined location in the configuration file. When
    the server starts up, handlers are attached or bound to a location. Ideally there
    should only be one handler to a location; if there are more than one defined in
    the configuration file, only one of them will be valid (typically the last one).
    Handlers end in the following three ways: successfully when all is good, fail
    when there is an error, or they will not process the request and will let the
    default handler process it.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件中为每个定义的位置都有一个处理器。当服务器启动时，处理器会附加或绑定到某个位置。理想情况下，每个位置应该只有一个处理器；如果在配置文件中定义了多个，只有一个会有效（通常是最后一个）。处理器会通过以下三种方式结束：成功（当一切正常时）、失败（当出现错误时），或者它们不会处理请求，而是让默认处理器处理请求。
- en: Load balancers
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 负载均衡器
- en: 'The load balancer or upstream module forwards your requests to one of the many
    configured backends or upstreams. Nginx, by default, has two load-balancing modules
    built in: **Round Robin** and the **IP Hash** method (look at `ngx_http_upstream_module`).
    There are other third-party modules available that allow you to do load balancing
    based on various hashing mechanisms, for example, Consistent Hashing.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 负载均衡器或上游模块将你的请求转发到配置的多个后端或上游中的一个。默认情况下，Nginx 内置了两个负载均衡模块：**轮询法**和 **IP 哈希**
    方法（查看 `ngx_http_upstream_module`）。还有其他第三方模块可以让你基于各种哈希机制进行负载均衡，例如一致性哈希。
- en: Filters
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤器
- en: After a handler produces a response, the filters are executed. Filters do the
    postprocessing on the handler's response. One example can be that you need to
    compress the response, or add certain headers to it. Multiple filters can associate
    with each location.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理程序生成响应后，过滤器会被执行。过滤器对处理程序的响应进行后处理。举个例子，你可能需要压缩响应，或者添加某些头部信息。多个过滤器可以与每个位置相关联。
- en: Order of execution
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行顺序
- en: The order of execution of Nginx filters is determined when they are compiled.
    You can see the order of the execution after compiling the code in `ngx_modules.c`.
    This file is generated on the fly by the `modules` script, which is found at `nginx/auto/`.
    This script makes sure that it maintains the correct order of the module and filter
    execution.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Nginx 过滤器的执行顺序在编译时确定。你可以在编译代码后查看 `ngx_modules.c` 中的执行顺序。这个文件是通过 `modules` 脚本即时生成的，该脚本位于
    `nginx/auto/`。这个脚本确保了模块和过滤器执行顺序的正确性。
- en: The built-in modules do need a specific order, for example, a gzip filter should
    run after the header and body filters have been executed. The new custom modules
    are generally executed in the end.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 内建模块确实需要特定的顺序，例如，gzip 过滤器应该在头部和主体过滤器执行后运行。新的自定义模块通常会在最后执行。
- en: Filters do not execute in a fully blocked manner, rather the output of the filters
    is streamed through the chain of filters. By default, one filter processes some
    data and passes it on to the next module and so on. The amount of data processed
    at a time is usually a multiple of the page size. Different modules, for example,
    gzip, allow you to adjust this value.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器并不是以完全阻塞的方式执行，而是过滤器的输出通过过滤器链进行流转。默认情况下，一个过滤器处理某些数据并将其传递给下一个模块，依此类推。每次处理的数据量通常是页面大小的倍数。不同的模块，比如
    gzip，允许你调整这个值。
- en: The extended "Hello world" module
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展版 "Hello world" 模块
- en: Now we will proceed towards creating a simple Nginx module. This module will
    print a configurable text in your browser whenever you enter a specific location.
    This is a very simple module and the idea is to just introduce the core concepts
    of how to create an Nginx module. This is based on and is an enhanced version
    of the simple Hello world module found at [http://blog.zhuzhaoyuan.com/2009/08/creating-a-hello-world-nginx-module/](http://blog.zhuzhaoyuan.com/2009/08/creating-a-hello-world-nginx-module/).
    This module is an example of a handler module.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将开始创建一个简单的 Nginx 模块。这个模块将在你输入特定位置时，在浏览器中显示一个可配置的文本。这是一个非常简单的模块，目的是介绍如何创建
    Nginx 模块的核心概念。这个模块是基于并扩展了简单的 Hello world 模块，原文可以在 [http://blog.zhuzhaoyuan.com/2009/08/creating-a-hello-world-nginx-module/](http://blog.zhuzhaoyuan.com/2009/08/creating-a-hello-world-nginx-module/)
    找到。这个模块是一个处理程序模块的示例。
- en: Writing and compiling a module
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写和编译模块
- en: 'The first thing you have to do is to obviously create a folder for your new
    module. Create it anywhere other than the Nginx source tree. You should create
    the following two files to start with:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先要做的显然是为你的新模块创建一个文件夹。将其创建在 Nginx 源代码树以外的地方。你应首先创建以下两个文件：
- en: '`config`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config`'
- en: '`ngx_http_hello_module.c`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngx_http_hello_module.c`'
- en: The contents of the `config` file will depend on what kind of module you are
    writing.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`config` 文件的内容将取决于你编写的模块类型。'
- en: 'For this simple module, it will look like the following code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个简单的模块，它的代码大致如下：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The file is quite self-explanatory. In the second line we are adding the module
    to a list of HTTP modules. Depending on which module type you are writing, you
    will need to add it to a different list. You can see the full list in the `modules`
    script found at `nginx/auto/`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件非常直观易懂。在第二行中，我们将模块添加到 HTTP 模块的列表中。根据你编写的模块类型，你需要将其添加到不同的列表中。你可以在 `nginx/auto/`
    中找到的 `modules` 脚本中查看完整列表。
- en: Before compiling, the module needs to be explicitly specified using the `configure`
    script as in the following code. The `add-module` list should contain a list of
    all third-party modules you want to include in the compilation.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译之前，需要使用 `configure` 脚本显式指定模块，像以下代码所示。`add-module` 列表应该包含你希望在编译中包含的所有第三方模块。
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This has to be followed by `make` and `make install` as usual.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这之后需要像往常一样执行 `make` 和 `make install`。
- en: The "Hello world" source code
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '"Hello world" 源代码'
- en: The following code is from `ngx_http_hello_module.c:`
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码来自 `ngx_http_hello_module.c`：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'A sample configuration for this extended `hello world` module could look as
    follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这个扩展版 `hello world` 模块的示例配置可能如下所示：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Components of the Nginx module
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Nginx 模块的组件
- en: There are many components on an Nginx module depending on the type of the module.
    We will now discuss those parts that are common to almost all the modules. The
    intention is to present to you a reference in an easy to understand way so that
    you can be ready to write your own module.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 根据模块类型的不同，Nginx 模块有许多组件。我们现在将讨论那些几乎所有模块都通用的部分。目的是以一种易于理解的方式为您提供参考，使您能够准备好编写自己的模块。
- en: Module configuration structures
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块配置结构
- en: 'Modules can define one configuration for each of the configuration file''s
    configuration contexts—there is an individual structure for the main, server,
    and location contexts. It is OK for most modules to simply have a location structure.
    These structures should be named as `convention ngx_http_<module name>_(main|srv|loc)_conf_t`.
    The following is the code snippet from the sample module:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 模块可以为每个配置文件的配置上下文定义一个配置——主上下文、服务器上下文和位置上下文都有各自的独立结构。大多数模块只需要一个位置结构是可以的。这些结构应该命名为`convention
    ngx_http_<module name>_(main|srv|loc)_conf_t`。以下是来自示例模块的代码片段：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The members of this structure should use Nginx's special data types (`ngx_uint_t`,
    `ngx_flag_t`, and `ngx_str_t`), which are simply aliases for basic/primitive types.
    You can look into `core/nginx_config.h` in the source tree for the data type definitions.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构的成员应该使用 Nginx 特有的数据类型（`ngx_uint_t`，`ngx_flag_t`，和 `ngx_str_t`），这些数据类型只是基本类型的别名。您可以在源代码树中的`core/nginx_config.h`文件里查看这些数据类型的定义。
- en: There should be as many members of this structure as the module directives.
    In the preceding example our module only has one directive, so we can already
    tell that this module will support a single directive/option at the location level,
    which will populate the member `name` of this structure.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构的成员应该与模块指令的数量相匹配。在前面的示例中，我们的模块只有一个指令，所以我们可以预见该模块将在位置级别支持一个指令/选项，并将填充该结构的`name`成员。
- en: As it must be obvious by now, that the elements in the configuration structure
    are filled by module directives defined in the configuration file.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如今这已经显而易见，配置结构中的元素是由配置文件中定义的模块指令填充的。
- en: Module directives
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块指令
- en: 'After you have defined the place where the value of the module directives will
    be stored, it is time to define the name of the module directives and what kind
    and type of arguments they will accept. A module''s directives are defined in
    a static array of the `ngx_command_t type` structure. Looking at the example code
    we previously wrote, the following is what the directives structure looks like:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了模块指令值存储位置之后，就可以定义模块指令的名称及其接受的参数类型。模块的指令是通过`ngx_command_t type`结构的静态数组来定义的。回顾我们之前写的示例代码，以下是指令结构的样子：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding structure may look a little bit complicated. However, we will
    now look at each one of those to understand them a little better.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的结构可能看起来有些复杂。不过，我们现在将逐一查看这些元素，以便更好地理解它们。
- en: The first argument defines the name of the directive. This is of type `ngx_str`
    and is instantiated with the directive name, for example, `ngx_str("hello")`.
    An `ngx_str_t` data type is a struct type with data and length elements. Nginx
    uses this data structure for all the strings.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数定义了指令的名称。这个参数是`ngx_str`类型，并且实例化为指令名称，例如`ngx_str("hello")`。`ngx_str_t`数据类型是一个结构体类型，包含数据和长度元素。Nginx
    使用这个数据结构来处理所有字符串。
- en: 'The second argument defines the type of the directive, and what kind of arguments
    it accepts. The acceptable values for these parameters should be bitwise ordered
    with each other. The possibilities are as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数定义了指令的类型以及它接受什么样的参数。这些参数的接受值应按位排列。可能的值如下：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Please see the full details in `ngx_conf_file.h` found in the `core` folder.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看`core`文件夹中的`ngx_conf_file.h`，了解更多细节。
- en: 'The maximum number of arguments that a directive can take is eight (0-7) as
    defined in `core/ngx_conf_file.h`, as shown in the following code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 指令可以接受的最大参数数为八个（0-7），如`core/ngx_conf_file.h`中所定义，代码如下所示：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding example, we only use a single element in the array, as we are
    providing values for a single `ngx_command_t` structure.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们只使用了数组中的一个元素，因为我们为单个`ngx_command_t`结构提供了值。
- en: 'The third argument is a function pointer. This is a setup function that takes
    the value provided for the directive in the configuration file and stores it in
    the appropriate element of the structure. This function can take the following
    three arguments:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个参数是一个函数指针。这是一个设置函数，它获取配置文件中提供的指令值，并将其存储在结构的相应元素中。这个函数可以接受以下三个参数：
- en: Pointer to `ngx_conf_t` (`main`, `srv`, or `loc`) structure, which contains
    the values of the directive in the configuration file
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指向 `ngx_conf_t`（`main`、`srv` 或 `loc`）结构的指针，其中包含配置文件中的指令值
- en: Pointer to the target `ngx_command_t` structure where the value will be stored
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指向目标 `ngx_command_t` 结构的指针，值将被存储在此处
- en: Pointer to the module's custom configuration structure (can be `NULL`)
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指向模块自定义配置结构的指针（可以是 `NULL`）
- en: 'Nginx provides a number of functions that can be used to set the values for
    the built-in data types. These functions include:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Nginx 提供了许多函数，可以用来设置内置数据类型的值。这些函数包括：
- en: '`ngx_conf_set_flag_slot`'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngx_conf_set_flag_slot`'
- en: '`ngx_conf_set_str_slot`'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngx_conf_set_str_slot`'
- en: '`ngx_conf_set_str_array_slot`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngx_conf_set_str_array_slot`'
- en: '`ngx_conf_set_keyval_slot`'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngx_conf_set_keyval_slot`'
- en: '`ngx_conf_set_num_slot`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngx_conf_set_num_slot`'
- en: '`ngx_conf_set_size_slot`'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngx_conf_set_size_slot`'
- en: '`ngx_conf_set_off_slot`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngx_conf_set_off_slot`'
- en: '`ngx_conf_set_msec_slot`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngx_conf_set_msec_slot`'
- en: '`ngx_conf_set_sec_slot`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngx_conf_set_sec_slot`'
- en: '`ngx_conf_set_bufs_slot`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngx_conf_set_bufs_slot`'
- en: '`ngx_conf_set_enum_slot`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngx_conf_set_enum_slot`'
- en: '`ngx_conf_set_bitmask_slot`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngx_conf_set_bitmask_slot`'
- en: 'Some of these are described as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些如下所述：
- en: '`ngx_conf_set_flag_slot`: This translates on or off to 1 or 0'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngx_conf_set_flag_slot`：此函数将 on 或 off 转换为 1 或 0'
- en: '`ngx_conf_set_str_slot`: This saves a string as `ngx_str_t`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngx_conf_set_str_slot`：将一个字符串保存为 `ngx_str_t`'
- en: '`ngx_conf_set_num_slot`: This parses a number and saves it to an integer'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngx_conf_set_num_slot`：此函数解析一个数字并将其保存到整数中'
- en: '`ngx_conf_set_size_slot`: This parses a data size (5k, 2m, and so on) and saves
    it to `size_t`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngx_conf_set_size_slot`：此函数解析数据大小（5k、2m 等）并将其保存到 `size_t`'
- en: Module authors can also pass the pointer to their own function here, if the
    built-in functions are not sufficient for their purpose, for example, if the string
    needs to be interpreted in a certain way instead of just being stored as it is.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果内置函数无法满足模块作者的需求，例如，如果字符串需要以某种特定方式解释，而不仅仅是按原样存储，模块作者也可以在此传递指向自定义函数的指针。
- en: In order to specify where these built-in (or custom) functions will store the
    directive values, you have to specify `conf` and `offset` as the next two arguments.
    `conf` specifies the type of the structure where the value will be stored (`main`,
    `srv`, `loc`) and `offset` specifies which part of this configuration structure
    to store it in. The following is the `offset` of the element in the structure,
    that is, `offsetof(ngx_http_hello_loc_conf_t, name)`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了指定这些内置（或自定义）函数将在哪里存储指令值，你必须将 `conf` 和 `offset` 作为下两个参数进行指定。`conf` 指定存储值的结构类型（`main`、`srv`、`loc`），而
    `offset` 指定存储在此配置结构的哪一部分。以下是该元素在结构中的 `offset`，即 `offsetof(ngx_http_hello_loc_conf_t,
    name)`。
- en: The last element is often `NULL`, and at the moment we can choose to ignore
    it.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个元素通常是 `NULL`，目前我们可以选择忽略它。
- en: The last element of the command array is `ngx_null_command`, which indicates
    the termination.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 命令数组的最后一个元素是 `ngx_null_command`，它表示终止。
- en: The module context
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块上下文
- en: 'The third structure in an Nginx module that needs to be defined is a static
    `ngx_http_module_t` structure, which just has the function pointers for creating
    the `main`, `srv`, and `loc` configurations, and merging them together. Its name
    is `ngx_http_<module name>_module_ctx`. The function references that you can provide
    are as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Nginx 模块中需要定义的第三个结构是一个静态的 `ngx_http_module_t` 结构，它包含用于创建 `main`、`srv` 和 `loc`
    配置的函数指针，并将它们合并在一起。它的名字是 `ngx_http_<module name>_module_ctx`。你可以提供的函数引用如下：
- en: Pre configuration
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置前
- en: Post configuration
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置后
- en: Creating the main `conf`
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建主 `conf`
- en: Initializing the main `conf`
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化主 `conf`
- en: Creating the server `conf`
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建服务器 `conf`
- en: Merging it with the main `conf`
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与主 `conf` 合并
- en: Creating the location `conf`
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建位置 `conf`
- en: Merging it with the server `conf`
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与服务器 `conf` 合并
- en: 'These take different arguments depending on what they''re doing. The following
    is the structure definition, taken from `http/ngx_http_config.h`, so you can see
    the different function signatures of the callbacks:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数根据其功能接受不同的参数。以下是结构定义，摘自 `http/ngx_http_config.h`，你可以看到回调函数的不同签名：
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can set functions you don't need to `NULL`, and Nginx will accept it, and
    do the right thing.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将不需要的函数设置为`NULL`，Nginx会接受它并做出正确的处理。
- en: The create functions such as create main `conf`, create server `conf`, and create
    location `conf` normally just allocate memory for the structures (such as `malloc()`)
    and initialize the elements as default values. The functions such as initialize
    main `conf`, and merge with main `conf` provide the opportunity to override the
    default values.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 创建函数，如创建主`conf`、创建服务器`conf`和创建位置`conf`，通常只是为结构体分配内存（例如`malloc()`）并将元素初始化为默认值。像初始化主`conf`、与主`conf`合并等函数则提供了覆盖默认值的机会。
- en: During merging, the module authors can look for duplicate definitions of elements
    and throw errors if there is a problem with directives provided by configuration
    authors in the configuration file.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在合并过程中，模块作者可以查找元素的重复定义，如果配置文件中配置作者提供的指令有问题，则抛出错误。
- en: 'Most module authors just use the last two elements as such: a function to allocate
    memory for `ngx_loc_conf` (`main` , `srv`, or `loc`) configuration, and a function
    to set defaults and merge this configuration into a merged location configuration
    (called `ngx_http_<module name >_merge_loc_conf`).'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数模块作者只是使用最后两个元素：一个函数用于为`ngx_loc_conf`（`main`、`srv`或`loc`）配置分配内存，另一个函数用于设置默认值并将此配置合并到合并后的位置配置中（称为`ngx_http_<module
    name >_merge_loc_conf`）。
- en: 'The following is an example module context structure:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例模块上下文结构：
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We can have a closer look now at these functions, which set up the location
    based on configuration.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以更仔细地看这些函数，它们根据配置设置位置。
- en: create_loc_conf
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: create_loc_conf
- en: The following is what a basic `create_loc_conf` function looks like. It takes
    a directive structure (`ngx_conf_t`) and returns a module configuration structure
    that is newly allocated.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个基本的`create_loc_conf`函数的样子。它接受一个指令结构体（`ngx_conf_t`）并返回一个新分配的模块配置结构体。
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The Nginx memory allocation takes care of freeing the memory if you use the
    built-ins `ngx_palloc` (a malloc wrapper) or `ngx_pcalloc` (a calloc wrapper).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用内置的`ngx_palloc`（一个malloc包装器）或`ngx_pcalloc`（一个calloc包装器），Nginx内存分配会负责释放内存。
- en: merge_loc_conf
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: merge_loc_conf
- en: The sample module we created does not contain a merge location `conf` function.
    However, we can look at the following sample code just to explain some basic concepts.
    You generally need a merge function if a directive can be defined multiple times.
    It is your job to define a merge function that can set the appropriate value in
    case it is defined multiple times or in multiple locations.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的示例模块不包含合并位置`conf`函数。然而，我们可以看看以下示例代码，只是为了说明一些基本概念。如果一个指令可以多次定义，你通常需要一个合并函数。你的任务是定义一个合并函数，能够在该指令多次定义或在多个位置定义的情况下设置适当的值。
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Nginx provides very useful merging built-in functions for various data types
    (`ngx_conf_merge_<data type>_value`). These functions take the arguments as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Nginx为各种数据类型提供了非常有用的合并内置函数（`ngx_conf_merge_<data type>_value`）。这些函数接受以下参数：
- en: The location's value (can refer to an element in a structure)
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置的值（可以引用结构体中的元素）
- en: The value to use if the first value is not set
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果未设置第一个值，则使用此值
- en: The default value if both first and second values are not set
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果未设置第一个和第二个值，则使用默认值
- en: 'The first argument stores the result. See `core/ngx_conf_file.h` for a full
    list of available merge functions. The following is an extract from the file:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数存储结果。有关可用的合并函数的完整列表，请参阅`core/ngx_conf_file.h`。以下是文件中的摘录：
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see these functions are defined as macros, and they are expanded
    and placed inline in the code during compilation.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这些函数被定义为宏，并且在编译时展开并内联到代码中。
- en: Another thing to learn is how to log errors. The function outputs to the log
    file using the `ngx_conf_log_error` function—where you specify a log level—and
    returns `NGX_CONF_ERROR`, which stops server startup.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个要学习的内容是如何记录错误。该函数使用`ngx_conf_log_error`函数将信息输出到日志文件——你可以指定日志级别——并返回`NGX_CONF_ERROR`，这将停止服务器启动。
- en: 'There are several log levels defined in Nginx. These are defined in `ngx_log.h`.
    The following is an extract from the code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在Nginx中定义了几个日志级别，这些级别在`ngx_log.h`中定义。以下是代码中的摘录：
- en: '[PRE13]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The module definition
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块定义
- en: 'The next structure a new module should define is the module definition structure
    or the `ngx_module_t` structure. The variable is called `ngx_http_<module name>_module`.
    This structure binds together the structures we have been defining until now.
    You have to provide the pointers to the context and directives structures, as
    well as the remaining callbacks (exit thread, exit process, and so on). The module
    definition can act like a key to look up data associated with a particular module.
    The module definition of our custom module looks as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个结构是新模块应该定义的模块定义结构或`ngx_module_t`结构。变量称为`ngx_http_<module name>_module`。这个结构将前面定义的上下文和指令结构以及剩余的回调（退出线程、退出进程等）绑定在一起。模块定义可以像一个键一样查找与特定模块关联的数据。我们自定义模块的模块定义如下：
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can see that the macros `NGX_MODULE_V1` and `NGX_MODULE_V1_PADDING` provide
    the values for the structure elements before and after the highlighted section
    in the preceding code. This is a detail we don''t need to get into at the moment.
    For now, look at the following example on how to use them:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到宏`NGX_MODULE_V1`和`NGX_MODULE_V1_PADDING`在上述代码突出显示的部分之前和之后为结构元素提供了值。这是一个我们目前不需要深入了解的细节。现在，看看以下示例如何使用它们：
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can see from the comments in the preceding code what each argument means.
    The first and last elements are the masks that hide the additional structure elements
    mainly because we don't need them, and they are place holders for the future.
    We also provide a module type, which in this case is HTTP. Most of the user-defined
    custom modules will be of this type. You can define other types such as CORE,
    MAIL, EVENT and so on; however, they are mostly not used as add-on module types.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从前面代码的注释中看到每个参数的含义。第一个和最后一个元素是隐藏额外结构元素的掩码，主要是因为我们不需要它们，并且它们是未来的占位符。我们还提供了一个模块类型，本例中是HTTP。大多数用户定义的自定义模块将属于这种类型。你可以定义其他类型，如CORE、MAIL、EVENT等；然而，它们大多数不用作附加模块类型。
- en: The handler function
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理函数
- en: 'The final piece of the puzzle after all the preparation work and configuration
    structures is the actual handler function which does all the work. The handler
    function for our sample module is as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有的准备工作和配置结构之后，最后一块拼图是实际的处理函数，它完成所有的工作。我们示例模块的处理函数如下：
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'There are a few things to learn in the code. As explained earlier, this module
    basically prints whatever you had provided in the configuration. For example,
    according to the following configuration, this module will make sure that it prints
    **Hello World** whenever you open `http://localhost:8080`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中有几件事情要学习。正如前面解释的那样，这个模块基本上会打印出你在配置中提供的任何内容。例如，根据以下配置，当你打开`http://localhost:8080`时，这个模块将确保打印**Hello
    World**：
- en: '[PRE17]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This method receives the HTTP request as an argument. If your module only responds
    to a certain type of HTTP requests, you can check by looking at the HTTP request
    structure. For example, our module only responds to HTTP `GET` and `HEAD` requests
    as checked by this chunk of code; otherwise it returns "error code 405 (not allowed)".
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法接收HTTP请求作为参数。如果你的模块只响应特定类型的HTTP请求，你可以通过查看HTTP请求结构来检查。例如，我们的模块只响应HTTP `GET`
    和 `HEAD` 请求，如这段代码所检查的；否则返回"错误代码405（不允许）"。
- en: 'All the HTTP error codes are defined in `ngx_http_request.h` as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的HTTP错误代码都在`ngx_http_request.h`中定义如下：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Next, we discard the request body as in this module we don't need it. In several
    modules, one will write a body that will be important, however, right now we don't
    care about it. By discarding the request body, Nginx will not read the request
    body fully for processing and will not allocate memory for it internally.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们丢弃请求体，因为在这个模块中我们不需要它。在一些模块中，将写一个对请求体很重要的正文；然而，现在我们不关心它。通过丢弃请求体，Nginx将不会完全读取请求体以进行处理，并且不会在内部为其分配内存。
- en: 'Next we set some HTTP headers in our response. All headers you can set in the
    response can be accessed through the `headers_out` member of the HTTP request
    structure. The `headers_out` structure allows you to set a number of outgoing
    headers. The extract from `ngx_http_request.h` is as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在响应中设置一些HTTP头部。你可以通过HTTP请求结构的`headers_out`成员访问所有可以设置在响应中的头部。`headers_out`结构允许你设置多个输出头部。从`ngx_http_request.h`中提取的部分如下：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The next important step in our module is allocating memory for the response
    buffer. This memory should be allocated using Nginx's own APIs as mentioned in
    earlier chapters (since it also automatically takes care of freeing it). This
    can be done because the memory is allocated from a local memory pool, so that
    all memory allocations are tracked.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们模块中的下一个重要步骤是为响应缓冲区分配内存。应该使用Nginx自有的API分配这块内存，如前面章节所述（因为它也会自动处理释放内存）。之所以可以这样做，是因为内存是从本地内存池中分配的，所以所有内存分配都受到追踪。
- en: The response is created in a linked list or *chain* of buffers, each of which
    is of the size of `ngx_buf_s`. This allows Nginx to process the response in a
    parallel way. If there are other handlers or filters that need to postprocess
    the response, they can start their work as soon as the first buffer in the chain
    is ready, while you are filling up the second buffer. This allows Nginx to keep
    operating in a parallel fashion without waiting for any module to completely finish
    processing first.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 响应是在一个链接列表或*链*的缓冲区中创建的，每个缓冲区的大小为`ngx_buf_s`。这使得Nginx可以并行处理响应。如果有其他处理程序或过滤器需要对响应进行后处理，它们可以在链中的第一个缓冲区准备好时开始工作，而你则在填充第二个缓冲区。这使得Nginx可以继续并行操作，而无需等待任何模块完全处理完毕。
- en: When you are finished with creating the response in the last buffer, you should
    set `b->last_buf = 1`. This, as it is obvious from the name, will tell Nginx that
    this is the last response buffer from your module.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在最后一个缓冲区中创建完响应后，应设置`b->last_buf = 1`。正如其名称所示，这将告诉Nginx，这是来自你的模块的最后一个响应缓冲区。
- en: If the response processing was successful, you would want to set the status
    of the response header to `HTTP_OK`. This is done by `r->headers_out.status =
    NGX_HTTP_OK`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果响应处理成功，你会希望将响应头的状态设置为`HTTP_OK`。可以通过`r->headers_out.status = NGX_HTTP_OK`来完成。
- en: You will then need to initiate the chain of header filters by calling `ngx_http_send_header`.
    This will indicate to Nginx that processing of the output headers has finished,
    and now Nginx can pass them to a chain of filters, which might want to do further
    postprocessing to the headers.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你需要通过调用`ngx_http_send_header`来初始化头部过滤器链。这将告诉Nginx，输出头部的处理已完成，现在Nginx可以将它们传递给一个过滤器链，这些过滤器可能希望对头部进行进一步的后处理。
- en: The final step is returning from the function by calling `ngx_http_output_filter`.
    This will initiate the process of the HTTP body filter chain. That is, Nginx or
    custom filter modules that might have been installed to do postprocessing on the
    HTTP response body you have just created in the buffer.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是通过调用`ngx_http_output_filter`从函数中返回。这将启动HTTP主体过滤链的处理过程。也就是说，Nginx或可能已经安装的自定义过滤模块将对你刚刚在缓冲区中创建的HTTP响应主体进行后处理。
- en: 'The summary of creating the Nginx custom module can be as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 创建Nginx自定义模块的总结如下：
- en: Create a module configuration that is structured either for location , main,
    or server; each with a specific naming convention (see `ngx_http_hello_loc_conf_t`).
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个模块配置，它可以根据位置、主配置或服务器结构化；每种结构都有特定的命名约定（见`ngx_http_hello_loc_conf_t`）。
- en: The allowed directives of the module are in a static array of `typengx_command_t`
    (see `ngx_http_hello_commands`). This will also have the function's pointers that
    will have the code to validate the value of each directive as well as initialize
    the handler.
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 模块的允许指令在`typengx_command_t`的静态数组中（见`ngx_http_hello_commands`）。这将包含指向函数的指针，函数中包含了验证每个指令值以及初始化处理程序的代码。
- en: Create a module context struct such as `ngx_http_<module name>_module_ctx` of
    type `ngx_http_module_t` which has a bunch of hooks for setting up configuration.
    Here you can have the post configuration hook, for example, to set up the main
    handler of your module (see `ngx_http_hello_module_ctx`).
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个模块上下文结构体，如`ngx_http_<module name>_module_ctx`，它是`ngx_http_module_t`类型，包含许多用于设置配置的钩子。你可以在这里设置后配置钩子，例如，设置模块的主处理程序（见`ngx_http_hello_module_ctx`）。
- en: Then we do the module definition, which is also a struct of type `ngx_module_t`
    and contains references to the module context and module commands that you created
    in the previous steps (see `ngx_http_hello_module`).
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义模块，它也是一个`ngx_module_t`类型的结构体，包含对你在前面步骤中创建的模块上下文和模块命令的引用（见`ngx_http_hello_module`）。
- en: Create the main module handler function that processes the HTTP request. This
    function also outputs the response headers and body in a series of fixed size
    buffers.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建处理HTTP请求的主模块处理函数。该函数还会以一系列固定大小的缓冲区输出响应头和主体。
- en: Nginx Development Toolkit (NDK)
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Nginx 开发工具包 (NDK)
- en: NDK is an Nginx module that makes it easier for the module developers to develop
    Nginx modules. As you have seen in this chapter so far, there are certain generic
    tasks that are repetitive as you are developing modules. NDK provides you with
    some built-in macros and functions that will reduce the amount of code you will
    have to write to develop a module.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: NDK 是一个 Nginx 模块，它使得模块开发者更容易开发 Nginx 模块。正如你在本章中所看到的，开发模块时会有一些重复的通用任务。NDK 提供了一些内置的宏和函数，可以减少你在开发模块时需要编写的代码量。
- en: In order to use NDK, you will have to add it as a module just like any other
    module. If you wish to use the macros and functions provided by this module, you
    will have to include the `ndk.h` file in your module source as well.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 NDK，你需要像其他模块一样将其作为一个模块进行添加。如果你希望使用该模块提供的宏和函数，你还需要在你的模块源代码中包含 `ndk.h` 文件。
- en: NDK provides useful utilities such as `conf` set functions for complex types
    such as paths and regular expressions, utility methods for NULL checking, returning
    values, and setting data to zero.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: NDK 提供了一些有用的工具，如用于处理路径和正则表达式等复杂类型的 `conf` 设置函数，NULL 检查、返回值处理以及将数据设置为零的工具方法。
- en: NDK also includes an **Auto Lib Core** that allows the developers and users
    to include external libraries in Nginx in a consistent, cross-platform manner.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: NDK 还包含了一个 **Auto Lib Core**，它允许开发者和用户以一致的、跨平台的方式将外部库包含到 Nginx 中。
- en: You can see more details and documentation at [https://github.com/simpl/ngx_devel_kit](https://github.com/simpl/ngx_devel_kit).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://github.com/simpl/ngx_devel_kit](https://github.com/simpl/ngx_devel_kit)
    上查看更多详细信息和文档。
- en: Summary
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter we have learned the process of creating a simple Nginx handler
    module. We also looked at which basic structures a new module should define, and
    how to link them to each other. Finally, we looked at a small handler function
    that does a basic task, but provides you the basis of writing a much more complicated
    module.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了创建一个简单的 Nginx 处理器模块的过程。我们还了解了一个新模块应该定义的基本结构，以及如何将它们相互关联。最后，我们看了一个执行基本任务的小型处理器函数，它为你编写更复杂的模块提供了基础。
- en: If you are an Nginx module developer, you must extensively browse other modules
    and Nginx source code, which will help you learn how to do different things within
    your code and which API to use in general.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一个 Nginx 模块开发者，你必须广泛浏览其他模块和 Nginx 源代码，这将帮助你学习如何在代码中完成不同的任务以及通常使用哪个 API。
- en: You will also find Nginx Development Kit at [https://github.com/simpl/ngx_devel_kit](https://github.com/simpl/ngx_devel_kit).
    This will provide you additional `conf_set` functions for regexes, complex/script
    values, paths, and macros to simplify tasks such as checking for NULL values when
    doing `ngx_array_push` and much more, which will simplify your life while writing
    custom Nginx modules.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在 [https://github.com/simpl/ngx_devel_kit](https://github.com/simpl/ngx_devel_kit)
    上找到 Nginx 开发工具包。这将为你提供额外的 `conf_set` 函数，用于处理正则表达式、复杂/脚本值、路径和宏，从而简化任务，比如在进行 `ngx_array_push`
    时检查 NULL 值等等，这将使你在编写自定义 Nginx 模块时更加轻松。
