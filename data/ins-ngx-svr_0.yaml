- en: Chapter 1. Instant Nginx Starter
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. 即刻使用 Nginx
- en: Welcome to *Instant Nginx Starter*. With this book I aim to give you a solid
    start to your nginx adventure. You will learn the basic features of nginx and
    be guided through your first virtual host to a point where you will know how to
    build on top of the basics to get to advanced features.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到 *即刻使用 Nginx*。本书旨在为你提供 nginx 探险的坚实起点。你将学习 nginx 的基本功能，并在构建第一个虚拟主机的过程中，掌握如何在基础上进一步构建，逐步实现高级功能。
- en: 'This book contains the following sections:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本书包含以下章节：
- en: '*So, what is nginx?* teaches you what nginx actually is, how it can be used,
    and how it fares against similar technologies.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*那么，什么是 nginx？* 教你 nginx 实际上是什么，它如何使用，以及它与类似技术相比的表现。'
- en: '*Installation* helps us learn the procedure to download and install nginx with
    different methods, and the cons and pros of each.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*安装* 帮助我们了解如何通过不同的方式下载并安装 nginx，以及每种方法的优缺点。'
- en: '*Quick start* covers nginx configuration syntax while creating our first virtual
    host through some simple steps. After this section you will be comfortable with
    the working of an nginx configuration.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*快速入门* 介绍了 nginx 配置语法，同时通过一些简单的步骤创建第一个虚拟主机。完成这一部分后，你将能熟练掌握 nginx 配置的工作原理。'
- en: '*Top 9 features you need to know about* helps you learn to perform nine useful
    tasks that the nginx modules offer. By the end of this section, you will be able
    to:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*你需要知道的 9 大功能* 帮助你学习如何执行 nginx 模块提供的九项有用任务。完成这一部分后，你将能够：'
- en: G-zip assets for optimal page load time
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 G-zip 压缩资源以优化页面加载时间
- en: Pre-zip assets for optimal page load time
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预压缩资源以优化页面加载时间
- en: Use nginx as a micro cache
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 nginx 作为微缓存
- en: How to use WebSockets with nginx
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 nginx 中使用 WebSockets
- en: Use nginx with other software
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 nginx 与其他软件一起使用
- en: Set up backend authentication for nginx downloads
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 nginx 下载设置后台认证
- en: Do GeoIP lookups in nginx
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 nginx 中进行 GeoIP 查找
- en: Limiting user requests to prevent abuse
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制用户请求以防止滥用
- en: Create seekable video streaming with nginx
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建可搜索的视频流媒体与 nginx
- en: '*People and places you should get to know* provides you with many useful links
    to resources about nginx, while keeping in mind that the community is important
    to nginx and it''s where most support happens and where a lot of module development
    takes place.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*你应该了解的人和地方* 提供了许多有用的 nginx 资源链接，同时强调社区对 nginx 的重要性，社区是大多数支持发生的地方，也是许多模块开发的场所。'
- en: So, what is nginx?
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 那么，什么是 nginx？
- en: The best way to describe nginx (pronounced engine-x) is as an event-based multi-protocol
    reverse proxy. This sounds fancy, but it's not just buzz words and actually affects
    how we approach configuring nginx. It also highlights some of the flexibility
    that nginx offers. While it is often used as a web server and an HTTP reverse
    proxy, it can also be used as an IMAP reverse proxy or even a raw TCP reverse
    proxy. Thanks to the plug-in ready code structure, we can utilize a large number
    of first and third party modules to implement a diverse amount of features to
    make nginx an ideal fit for many typical use cases.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 描述 nginx（发音为 engine-x）最好的方式是将其看作一个基于事件的多协议反向代理。这听起来很高大上，但这并非只是流行的术语，实际上它影响了我们配置
    nginx 的方式，也突显了 nginx 的一些灵活性。虽然 nginx 通常作为 Web 服务器和 HTTP 反向代理使用，但它也可以作为 IMAP 反向代理或甚至作为原始
    TCP 反向代理。得益于插件化的代码结构，我们可以利用大量的第一方和第三方模块，实施多种功能，使 nginx 适用于许多典型的使用场景。
- en: '![So, what is nginx?](img/5125OS_01_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![那么，什么是 nginx？](img/5125OS_01_01.jpg)'
- en: A more accurate description would be to say that nginx is a reverse proxy first,
    and a web server second. I say this because it can help us visualize the request
    flow through the configuration file and rationalize how to achieve the desired
    configuration of nginx. The core difference this creates is that nginx works with
    URIs instead of files and directories, and based on that determines how to process
    the request. This means that when we configure nginx, we tell it what should happen
    for a certain URI rather than what should happen for a certain file on the disk.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 更准确的描述是，nginx 应该首先被看作一个反向代理，其次是一个 Web 服务器。我之所以这样说，是因为它有助于我们通过配置文件来可视化请求流，并理清如何实现所需的
    nginx 配置。这种核心差异在于 nginx 是通过 URI 来工作，而不是文件和目录，并根据此来决定如何处理请求。这意味着，在配置 nginx 时，我们告诉它对于某个
    URI 应该发生什么，而不是告诉它某个磁盘上的文件应该发生什么。
- en: A beneficial part of nginx being a reverse proxy is that it fits into a large
    number of server setups, and can handle many things that other web servers simply
    aren't designed for. A popular question is "Why even bother with nginx when Apache
    httpd is available?"
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: nginx作为反向代理的一个有益之处在于，它适用于多种服务器配置，并且能够处理许多其他网页服务器根本不擅长的任务。一个常见的问题是：“既然已经有Apache
    httpd，为什么还要使用nginx？”
- en: The answer lies in the way the two programs are designed. The majority of Apache
    setups are done using prefork mode, where we spawn a certain amount of processes
    and then embed our dynamic language in each process. This setup is synchronous,
    meaning that each process can handle one request at a time, whether that connection
    is for a PHP script or an image file.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 答案在于这两个程序的设计方式。大多数Apache配置使用预先启动模式（prefork mode），在这种模式下，我们会启动一定数量的进程，然后在每个进程中嵌入我们的动态语言。该配置是同步的，这意味着每个进程一次只能处理一个请求，无论这个连接是用于PHP脚本还是图像文件。
- en: In contrast, nginx uses an asynchronous event-based design where each spawned
    process can handle thousands of concurrent connections. The downside here is that
    nginx will, for security and technical reasons, not embed programming languages
    into its own process - this means that to handle those we will need to reverse
    proxy to a backend, such as Apache, PHP-FPM, and so on. Thankfully, as nginx is
    a reverse proxy first and foremost, this is extremely easy to do and still allows
    us major benefits, even when keeping Apache in use.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，nginx采用的是基于事件的异步设计，每个启动的进程可以处理成千上万的并发连接。这里的缺点是，nginx出于安全和技术原因，不会将编程语言嵌入到其自身进程中——这意味着为了处理这些请求，我们需要将其反向代理到后端，比如Apache、PHP-FPM等。幸运的是，作为一个以反向代理为主的服务器，nginx非常容易做到这一点，并且即使在继续使用Apache时，依然能够带来显著的好处。
- en: Let's take a look at a use case where Apache is used as an application server
    described earlier rather than just a web server. We have embedded PHP, Perl, or
    Python into Apache, which has the primary disadvantage of each request becoming
    costly. This is because the Apache process is kept busy until the request has
    been fully served, even if it's a request for a static file. Our online service
    has gotten popular and we now find that our server cannot keep up with the increased
    demand. In this scenario introducing nginx as a spoon-feeding layer would be ideal.
    When an nginx server with a spoon-feeding layer will sit between our end user
    and Apache and a request comes in, nginx will reverse proxy it to Apache if it
    is for a dynamic file, while it will handle any static file requests itself. This
    means that we offload a lot of the request handling from the expensive Apache
    processes to the more lightweight nginx processes, and increase the number of
    end users we can serve before having to spend money on more powerful hardware.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个使用Apache作为应用服务器的案例，而不仅仅是作为网页服务器。我们已经将PHP、Perl或Python嵌入到Apache中，这种配置的主要缺点是每个请求变得非常耗费资源。因为Apache进程会一直忙碌，直到请求完全处理完毕，即使它是一个静态文件的请求。我们的在线服务变得越来越受欢迎，现在我们发现服务器无法跟上增加的需求。在这种情况下，引入nginx作为一个中介层将是理想的选择。当一个带有中介层的nginx服务器位于终端用户和Apache之间时，如果请求是针对动态文件，nginx会将其反向代理到Apache，而它自己会处理所有静态文件请求。这意味着我们将大量的请求处理从昂贵的Apache进程卸载到更轻量级的nginx进程，从而在不增加更多硬件的情况下提高了能服务的终端用户数量。
- en: Another example scenario is where we have an application being used from all
    over the world. We don't have any static files so we can't easily offload a number
    of requests from Apache. In this use case, our PHP process is busy from the time
    the request comes in until the user has finished downloading the response. Sadly,
    not everyone in the world has fast internet and, as a result, the sending process
    could be busy for a relatively significant period of time. Let's assume our visitor
    is on an old 56k modem and has a maximum download speed of 5 KB per second, it
    will take them five seconds to download a 25 KB gzipped HTML file generated by
    PHP. That's five seconds where our process cannot handle any other request. When
    we introduce nginx into this setup, we have PHP spending only microseconds generating
    the response but have nginx spend five seconds transferring it to the end user.
    Because nginx is asynchronous it will happily handle other connections in the
    meantime, and thus, we significantly increase the number of concurrent requests
    we can handle.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个典型的场景是我们有一个全球使用的应用程序。我们没有任何静态文件，因此不能轻松地从Apache卸载大量请求。在这种用例中，我们的PHP进程会从请求到用户下载完响应为止都很忙。遗憾的是，世界上并不是每个人都有快速的互联网连接，因此，发送过程可能会在相对较长的时间内处于忙碌状态。假设我们的访客使用的是旧款56k调制解调器，最大下载速度为每秒5
    KB，那么下载一个由PHP生成的25 KB压缩HTML文件将需要五秒钟。在这五秒钟里，我们的进程无法处理任何其他请求。当我们在这个设置中引入nginx时，PHP仅需几微秒生成响应，而nginx将花费五秒钟将其传输到最终用户。由于nginx是异步的，它会愉快地在此期间处理其他连接，因此我们显著提高了可以处理的并发请求数量。
- en: In the previous two examples I used scenarios where nginx was used in front
    of Apache, but naturally this is not a requirement. nginx is capable of reverse
    proxying via, for instance, FastCGI, UWSGI, SCGI, HTTP, or even TCP (through a
    plugin) enabling backends, such as PHP-FPM, Gunicorn, Thin, and Passenger.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面两个例子中，我使用了nginx在Apache前面工作的场景，但这自然不是必须的。nginx能够通过例如FastCGI、UWSGI、SCGI、HTTP，甚至TCP（通过插件）进行反向代理，从而启用后端服务，如PHP-FPM、Gunicorn、Thin和Passenger。
- en: Installation
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装
- en: There are two ways to install nginx, either by building it from source, or by
    installing a binary package via a package manager, such as yum or apt. Each method
    has its own pros and cons, and which method we choose depends on what we need
    nginx to do and which OS we're using.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 安装nginx有两种方法，分别是从源代码构建或通过包管理器（如yum或apt）安装二进制包。每种方法都有其优缺点，选择哪种方法取决于我们需要nginx完成的任务以及使用的操作系统。
- en: Historically nginx, Inc has only provided the source files for nginx so that
    we could compile the software ourselves, and only recently have they begun distributing
    binary packages for the various Linux distributions. Additionally, nginx requires
    that third party modules are compiled statically instead of being loaded at runtime.
    The end result of this is that the nginx ecosystem ends up with a number of native
    binary packages and custom binary packages built by different people to include
    different modules.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，nginx公司仅提供nginx的源代码文件，以便我们自己编译软件，直到最近，他们才开始为各种Linux发行版分发二进制包。此外，nginx要求第三方模块必须静态编译，而不是在运行时加载。最终结果是，nginx生态系统中会出现许多本地二进制包和由不同人构建的自定义二进制包，包含不同的模块。
- en: Even today many of the Linux distributions ship very old versions of nginx,
    which means we'll have to be careful when we install nginx to make sure we get
    the version we need. If we need any third party modules enabled, we are almost
    guaranteed to have to build from source. Thankfully, nginx is easy to install
    from source and this book details how to do it without suffering a nervous breakdown.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 即使今天，许多Linux发行版仍然发布非常旧版本的nginx，这意味着我们在安装nginx时必须小心，以确保安装到我们需要的版本。如果我们需要启用任何第三方模块，几乎可以确定我们必须从源代码编译。幸运的是，从源代码安装nginx是比较简单的，本书详细介绍了如何在不崩溃的情况下进行安装。
- en: 'A last note before we continue to the installation process. nginx has three
    versions available: development, stable, and legacy. Development here refers to
    the program API stability, not runtime stability. This means that the development
    version is usually just as stable, or even more stable than the stable branch.
    This is because bug fixes are added to the development branch before the stable
    branch. In general, if I personally want features in a new development version,
    I will give it a week or two to be tested by the community and then feel safe
    upgrading to it. Legacy versions should be avoided, as they are not supported
    by either nginx, Inc or the community, and usually bugs are fixed by simply updating
    to the stable or development version.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续安装过程之前，最后一个注意事项。nginx 有三个版本可供选择：开发版、稳定版和遗留版。开发版指的是程序 API 的稳定性，而不是运行时稳定性。这意味着开发版通常与稳定版一样稳定，甚至可能更稳定，因为错误修复首先会添加到开发分支，然后才会添加到稳定分支。通常，如果我个人需要新开发版中的功能，我会等一到两周，让社区进行测试，然后才会安全地升级到该版本。遗留版本应该避免使用，因为它们不再得到
    nginx、Inc 或社区的支持，通常通过更新到稳定版或开发版来修复错误。
- en: Step 1 – Different operating systems
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一步 – 不同操作系统
- en: Now, we will have a look at installing nginx on different operating systems.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看看如何在不同操作系统上安装 nginx。
- en: Windows
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Windows
- en: Installing on Windows is the easiest of them all, as it's really only available
    as a binary file unless we want to start compiling through Cygwin, for most people
    this is overkill. Instead, just head to the nginx download page and get one of
    the Windows releases as signified by **nginx/Windows-1.X.XX**. Extract that anywhere
    and we're ready to go!
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上安装是最简单的，因为它实际上只提供二进制文件，除非我们想通过 Cygwin 开始编译，但对大多数人来说这是多余的。相反，只需前往
    nginx 下载页面并获取标示为 **nginx/Windows-1.X.XX** 的 Windows 版本。将其解压到任意位置，我们就可以开始使用了！
- en: 'A word of warning about nginx on Windows though. Windows has a unique version
    of event polling called IOCP and nginx does not currently support this. This means
    that nginx falls back to a slower variant, which means that nginx on Windows is
    not at the same performance standard as nginx on Linux. Additionally, there are
    a number of limitations that we should be aware of. At the time of writing the
    following are the known limitations:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 但需要警告一下 Windows 上的 nginx。Windows 有一种独特的事件轮询版本，叫做 IOCP，而 nginx 当前不支持此功能。这意味着
    nginx 会退回到一个较慢的变种，因此 Windows 上的 nginx 在性能上无法与 Linux 上的 nginx 相比。除此之外，还有一些我们需要了解的限制。在撰写本文时，以下是已知的限制：
- en: Only one worker will be used
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只会使用一个工作进程
- en: A worker can handle no more than 1,024 concurrent connections
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个工作进程最多只能处理 1,024 个并发连接
- en: Cache modules do not work on Windows Vista or later
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存模块在 Windows Vista 或更高版本上无法工作
- en: 'nginx, Inc maintains an updated list of known limitations at the following
    URL:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: nginx, Inc 在以下网址维护已知限制的更新列表：
- en: '[http://www.nginx.org/en/docs/windows.html](http://www.nginx.org/en/docs/windows.html)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.nginx.org/en/docs/windows.html](http://www.nginx.org/en/docs/windows.html)'
- en: Linux
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Linux
- en: 'To install on Linux we first need to decide whether we''ll compile from source
    or install via a binary package. To help decide, here''s a brief overview of the
    pros and cons:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上安装之前，我们首先需要决定是从源代码编译安装还是通过二进制包安装。为了帮助做出决定，下面是一些优缺点的简要概述：
- en: Installation via source
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通过源代码安装
- en: 'The pros of installing nginx on Linux via source are as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通过源代码在 Linux 上安装 nginx 的优点如下：
- en: It can easily use third party modules
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以轻松使用第三方模块
- en: It can use the latest version immediately
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以立即使用最新版本
- en: 'The cons of installing nginx on Linux via source are as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通过源代码在 Linux 上安装 nginx 的缺点如下：
- en: It is more difficult than installing a binary package
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装起来比二进制包更复杂
- en: You have to keep on top of updates yourself
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须自己跟踪更新
- en: Installation via binary package
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通过二进制包安装
- en: 'The pros of installing nginx on Linux via binary package are as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通过二进制包在 Linux 上安装 nginx 的优点如下：
- en: It is very easy to install
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装非常简单
- en: You don't have to keep track of updates yourself
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不需要自己跟踪更新
- en: 'The cons of installing nginx on Linux via binary package are as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通过二进制包在 Linux 上安装 nginx 的缺点如下：
- en: It is difficult to find a binary package with third party modules
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 很难找到包含第三方模块的二进制包
- en: It is potentially lagging behind on versions
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能会滞后于版本
- en: It has many different versions, need to research them
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有许多不同的版本，需要进行研究
- en: Ultimately I personally think it comes down to whether or not you need third
    party modules. Finding binary packages that contain the modules you need is often
    difficult and you rely on external people to keep their binary package updated.
    Compiling from source if you need third party modules also means that we can restrict
    binary packages to the official nginx provided repositories. This makes it far
    easier and reduces the research required into the various custom repositories
    and **Ubuntu Personal Package Archives** (**PPAs**).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我个人认为关键在于你是否需要第三方模块。找到包含所需模块的二进制包通常很困难，而且你需要依赖外部人员来保持他们的二进制包更新。如果你需要第三方模块，编译源代码还意味着我们可以将二进制包限制在官方nginx提供的仓库中。这使得安装过程更加简单，并减少了对各种自定义仓库和**Ubuntu个人软件包归档**（**PPAs**）的研究需求。
- en: Installing from source
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从源代码安装
- en: Installing nginx from source is not as daunting as it might sound, as nginx
    is a fairly simple piece of software and we can still utilize yum and apt-get
    to simplify the installation of the dependencies.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 从源代码安装nginx并不像听起来那么令人畏惧，因为nginx是一个相对简单的软件，我们仍然可以使用yum和apt-get来简化依赖项的安装。
- en: 'If using apt, simply run the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用apt，只需运行以下命令：
- en: '[PRE0]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To automatically install the dependencies for their nginx package, usually these
    are the same as for what we will install.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要自动安装nginx包的依赖项，通常这些依赖项与我们将要安装的依赖项相同。
- en: 'If using yum, run the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用yum，请运行以下命令：
- en: '[PRE1]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'At this point we have the dependencies and are ready to compile nginx. Make
    sure we''re in the directory we want to download the source code into and then
    run the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们已经获得了依赖项，并准备好编译nginx。确保我们在要下载源代码的目录中，然后运行以下命令：
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: After running the last command we should get a large amount of text on the screen.
    If you're not used to compiling from source, this would probably be pretty daunting
    at first, but let's read through the important points.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 运行最后一个命令后，我们应该在屏幕上看到大量文本。如果你不习惯从源代码编译，刚开始可能会觉得相当令人畏惧，但我们可以一起阅读一些重要的要点。
- en: '|'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '| This sets the base path where nginx is installed. If not defined, this will
    default to `/usr/local/nginx`. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 这设置了nginx安装的基本路径。如果未定义，则默认路径为`/usr/local/nginx`。 |'
- en: '|'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '| This sets the path where the binary file is installed. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 这设置了二进制文件安装的路径。 |'
- en: '|'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '| This sets the path of the configuration file. |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 这设置了配置文件的路径。 |'
- en: 'Any of the other install specific switches can be configured in the configuration
    file, so those really aren''t important to set yet. Further down we start seeing
    switches named as `—with-*` and `—without-*`. Each of these allow us to define
    which standard modules go into our compiled binary package, and the switches we
    use depend on which features we want. Each module we include increases the size
    of the binary package, which increases memory usage. Although, even if we include
    all the modules, the memory size won''t be more than a few megabytes. Do note
    that some modules might have other dependencies, for instance the GeoIP module
    relies on external GeoIP software which will have to be installed through your
    package manager. To read about what each module does, please refer to the official
    documentation at: [http://www.nginx.org/en/docs/](http://www.nginx.org/en/docs/).'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 任何其他与安装相关的开关都可以在配置文件中进行配置，因此这些实际上现在还不重要。往下看，我们开始看到名为`—with-*`和`—without-*`的开关。每个开关都允许我们定义哪些标准模块将包含在我们的编译二进制包中，使用哪些开关取决于我们想要的功能。我们包含的每个模块都会增加二进制包的大小，从而增加内存使用。尽管如此，即使我们包含所有模块，内存大小也不会超过几兆字节。请注意，有些模块可能有其他依赖项，例如GeoIP模块依赖于外部的GeoIP软件，必须通过包管理器进行安装。要了解每个模块的功能，请参阅官方文档：[http://www.nginx.org/en/docs/](http://www.nginx.org/en/docs/)。
- en: 'Once we have decided the modules we want to be included, simply run the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们决定了要包含的模块，只需运行以下命令：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If all the dependencies are correct, a summary screen should be presented as
    follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有依赖项正确，应显示以下摘要界面：
- en: '![Installing from source](img/5125OS_02_01.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![从源代码安装](img/5125OS_02_01.jpg)'
- en: 'If the information there is as expected, complete the compile by running the
    follow commands:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果信息符合预期，请通过运行以下命令完成编译：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If we already have nginx installed, we can have the make script automatically
    and seamlessly rotate the running binary package by using the following command:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们已经安装了nginx，我们可以使用以下命令让make脚本自动、无缝地切换正在运行的二进制包：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If we did everything right, we should get the following message after running
    `make install`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们做对了所有的步骤，运行`make install`后应该会看到以下信息：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The quickest way to install from a binary package is to simply use the native
    packages and run either of the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 从二进制包安装的最快方法是直接使用本地包并运行以下任意一个：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: or
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If the version installed is fairly recent, we might want to do just that for
    convenience, if it's old then move on and use the nginx provided binary packages.
    To use these first install the repository like so.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果安装的版本比较新，我们可能为了方便想要这样做，如果是旧版本，则可以继续使用 nginx 提供的二进制包。要使用这些包，首先按照下面的方式安装仓库。
- en: 'For yum:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 yum：
- en: 'Create the file `/etc/yum.repos.d/nginx.repo` and add the following to it:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 创建文件`/etc/yum.repos.d/nginx.repo`，并将以下内容添加到其中：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Where `OS` is *centos* if CentOS is used and *rhel* if RHEL, or another RHEL-based
    distribution is used. `OSRELEASE` is the OS version number, being either *5* or
    *6*. If unsure check `uname -a` for a clue, or use the tried and tested method
    of trial and error.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，`OS`是*centos*（如果使用 CentOS）或者*rhel*（如果使用 RHEL 或其他基于 RHEL 的发行版）。`OSRELEASE`是操作系统版本号，可以是*5*或*6*。如果不确定，可以通过运行`uname
    -a`查看线索，或者使用反复试错法。
- en: 'For apt:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 apt：
- en: 'Add the following to `/etc/apt/sources.list` for Debian:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Debian，添加以下内容到`/etc/apt/sources.list`：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'For Ubuntu, add the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Ubuntu，添加以下内容：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Where codename is one of lucid, oneiric, precise, or quantal, depending on
    which version is used and then run:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，`codename`是`lucid`、`oneiric`、`precise`或`quantal`中的一个，取决于使用的是哪个版本，然后运行：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Step 2- Starting nginx
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第2步 - 启动 nginx
- en: 'Regardless of how nginx was installed, we will most likely want to start it
    by using a script. Our options are the classic `init.d` script or an `upstart/systemd`
    script depending on our platform. If nginx was installed via a binary package,
    one such script should already have been provided for us and can be used by running:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 无论 nginx 是如何安装的，我们大多数情况下都希望通过脚本启动它。我们的选择是经典的`init.d`脚本，或者根据平台选择`upstart/systemd`脚本。如果
    nginx 是通过二进制包安装的，那么一个这样的脚本应该已经由我们提供并可以使用，运行以下命令：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If nginx was installed via source, we''ll need to install the init script ourselves.
    An nginx community effort to gather `.init` scripts can be found at: [http://wiki.nginx.org/InitScripts](http://wiki.nginx.org/InitScripts),
    which will help us get set up quickly.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 nginx 是通过源代码安装的，我们需要自己安装 init 脚本。nginx 社区为我们收集了`.init`脚本，具体可以访问：[http://wiki.nginx.org/InitScripts](http://wiki.nginx.org/InitScripts)，它将帮助我们快速设置。
- en: 'Download the `init` script for the relevant platform and save it to `/etc/rc.d/init.d/nginx`,
    check the paths in the `.init` file to make sure they fit the install configurations
    we set with the `./configure arguments` (or the defaults!), and then run the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 下载与平台相关的`init`脚本并将其保存到`/etc/rc.d/init.d/nginx`，检查`.init`文件中的路径，确保它们与我们使用`./configure
    arguments`（或默认设置）时配置的安装路径一致，然后运行以下命令：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now run the preceding command up above to see the options available.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行上面提到的命令，查看可用选项。
- en: And that's it
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 就这样
- en: At this point nginx should be installed and ready to be configured. It's time
    to experiment a bit and learn the good stuff!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，nginx 应该已经安装完毕并准备好进行配置。是时候做一些实验并学习一些有用的东西了！
- en: Quick start – Creating your first virtual host
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速开始 – 创建第一个虚拟主机
- en: It's finally time to get nginx up and running. To start out, let's quickly review
    the configuration file. If you installed via a system package, the default configuration
    file location is most likely `/etc/nginx/nginx.conf`. If you installed via source
    and didn't change the path prefix, nginx installs itself into `/usr/local/nginx`
    and places `nginx.conf` in a `/conf` subdirectory. Keep this file open as a reference
    to help visualize many of the things described in this chapter.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 终于可以让 nginx 启动了。首先，让我们快速回顾一下配置文件。如果通过系统包安装，默认的配置文件位置很可能是`/etc/nginx/nginx.conf`。如果通过源代码安装且没有更改路径前缀，nginx
    会安装到`/usr/local/nginx`，并将`nginx.conf`放置在`/conf`子目录中。保持此文件打开，以便在本章中参考，帮助理解描述的许多内容。
- en: Step 1 – Directives and contexts
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第1步 – 指令和上下文
- en: To understand what we'll be covering in this section, let me first introduce
    a bit of terminology that the nginx community at large uses. Two central concepts
    to the nginx configuration file are those of **directives** and **contexts**.
    A directive is basically just an identifier for the various configuration options.
    Contexts refer to the different sections of the nginx configuration file. This
    term is important because the documentation often states which context a directive
    is allowed to have within.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解我们将在本节中讨论的内容，让我首先介绍一些 nginx 社区常用的术语。nginx 配置文件的两个核心概念是 **指令** 和 **上下文**。指令基本上只是各种配置选项的标识符。上下文是指
    nginx 配置文件的不同部分。这个术语很重要，因为文档中通常会说明某个指令在哪些上下文中可以使用。
- en: A glance at the standard configuration file should reveal that nginx uses a
    layered configuration format where blocks are denoted by curly brackets `{}`.
    These blocks are what are referred to as contexts.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 从标准配置文件来看，nginx 使用一种分层的配置格式，其中块通过大括号 `{}` 表示。这些块就是我们所说的上下文。
- en: The topmost context is called main, and is not denoted as a block but is rather
    the configuration file itself. The main context has only a few directives we're
    really interested in, the two major ones being `worker_processes` and user. These
    directives handle how many worker processes nginx should run and which user/group
    nginx should run these under.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最上层的上下文叫做 main，并不是通过一个块表示的，而是整个配置文件本身。main 上下文只有几个我们真正感兴趣的指令，其中两个主要的指令是 `worker_processes`
    和 user。这些指令处理 nginx 应该运行多少个工作进程，以及 nginx 应该以哪个用户/组身份运行这些进程。
- en: Within the main context there are two possible subcontexts, the first one being
    called **events**. This block handles directives that deal with the event-polling
    nature of nginx. Mostly we can ignore every directive in here, as nginx can automatically
    configure this to be the most optimal; however, there's one directive which is
    interesting, namely `worker_connections`. This directive controls the number of
    connections each worker can handle. It's important to note here that nginx is
    a terminating proxy, so if you HTTP proxy to a backend, such as Apache httpd,
    that will use up two connections.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在主上下文中，有两个可能的子上下文，第一个叫做 **events**。这个块处理与 nginx 事件轮询相关的指令。大多数情况下我们可以忽略这里的指令，因为
    nginx 可以自动配置为最优状态；然而，有一个指令很有意思，即 `worker_connections`。这个指令控制每个工作进程可以处理的连接数。值得注意的是，nginx
    是一个终止代理，因此如果你将 HTTP 请求代理到后端，比如 Apache httpd，那么就会消耗两个连接。
- en: The second subcontext is the interesting one called `http`. This context deals
    with everything related to HTTP, and this is what we will be working with almost
    all of the time. While there are directives that are configured in the `http`
    context, for now we'll focus on a subcontext within `http` called `server`. The
    `server` context is the nginx equivalent of a virtual host. This context is used
    to handle configuration directives based on the host name your sites are under.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个子上下文是非常有趣的一个，叫做 `http`。这个上下文处理与 HTTP 相关的所有内容，几乎我们所有的工作都会集中在这里。虽然在 `http`
    上下文中有一些指令需要配置，但目前我们会专注于 `http` 中的一个子上下文，叫做 `server`。`server` 上下文是 nginx 的虚拟主机等效物。这个上下文用于根据你的站点所在的主机名处理配置指令。
- en: Within the `server` context, we have another subcontext called `location`. The
    `location` context is what we use to match the URI. Basically, a request to nginx
    will flow through each of our contexts, matching first the server block with the
    hostname provided by the client, and secondly the location context with the URI
    provided by the client.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `server` 上下文中，我们有一个叫做 `location` 的子上下文。`location` 上下文是我们用来匹配 URI 的地方。基本上，一个请求会依次经过每个上下文，首先是与客户端提供的主机名匹配的
    server 块，其次是与客户端提供的 URI 匹配的 location 上下文。
- en: Depending on the installation method, there might not be any server blocks in
    the `nginx.conf` file. Typically, system package managers take advantage of the
    include directive that allows us to do an in-place inclusion into our configuration
    file. This allows us to separate out each virtual host and keep our configuration
    file more organized. If there aren't any server blocks, check the bottom of the
    file for an `include` directive and check the directory from which it includes,
    it should have a file which contains a server block.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 根据安装方式，`nginx.conf` 文件中可能没有任何服务器块。通常，系统包管理器会利用 `include` 指令，使我们能够将配置文件进行内联包含。这样我们可以将每个虚拟主机分开管理，从而保持配置文件的有序。如果没有服务器块，可以检查文件底部是否有
    `include` 指令，并检查它所包含的目录，应该会有一个包含服务器块的文件。
- en: Step 2 – Define your first virtual hosts
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 步骤 2 – 定义你的第一个虚拟主机
- en: Finally, let us define our first server block!
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们定义我们的第一个服务器块！
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Tip
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从你在 [http://www.packtpub.com](http://www.packtpub.com) 账户中下载所有已购买 Packt 书籍的示例代码文件。如果你是在其他地方购买的这本书，可以访问
    [http://www.packtpub.com/support](http://www.packtpub.com/support)，并注册以便直接通过电子邮件获取文件。
- en: That is basically all we need, and strictly speaking, we don't even need to
    define which port to listen on as port 80 is default. However, it's generally
    a good practice to keep it in there should we want to search for all virtual hosts
    on port 80 later on.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上就是我们所需的，严格来说，我们甚至不需要定义监听的端口，因为端口 80 是默认的。然而，通常来说，保持这个配置是个好习惯，以便以后我们想要查找所有监听在
    80 端口上的虚拟主机时使用。
- en: Quick start – Interacting with backends
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速入门 – 与后端交互
- en: Obviously, this virtual host is quite boring, all it does is serve a static
    file, and while that is certainly useful, it's practically never all we want to
    do. Something more interesting would be to serve PHP requests, perhaps even for
    a framework with a front controller pattern and search engine friendly URLs.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这个虚拟主机非常简单，它做的只是提供一个静态文件，虽然这确实很有用，但它几乎从来不是我们想要做的全部内容。更有趣的做法可能是处理 PHP 请求，甚至是为一个具有前端控制器模式并且搜索引擎友好的
    URL 的框架提供服务。
- en: Step 1 – A quick backend communication example
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 步骤 1 – 快速后端通信示例
- en: 'Communicating with a backend is done by passing the request to the backend
    if certain conditions are met. For example, in the following server block:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 与后端的通信是通过在满足特定条件时将请求传递给后端完成的。例如，在以下的服务器块中：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here we are using a regular expression location block to define what should
    happen when a request with a URI ending in `.php` comes in. If the URI does not
    end in `.php` but, for instance, `/contact-us/`, `location /` is used instead
    that tries to find a file on the disk using our root directive and the URI. If
    that's not found, it tries to search for a directory instead and uses our index
    directive to find an index file. If that is not found either, then it finally
    rewrites internally to `/index.php` and restarts location evaluation with the
    URI now ending in `.php` and as such the PHP location will be used and send the
    request to PHP.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用正则表达式位置块来定义当请求的 URI 以 `.php` 结尾时应该发生的事情。如果 URI 不是以 `.php` 结尾，而是例如 `/contact-us/`，则会使用
    `location /`，该指令尝试使用我们的根目录指令和 URI 来查找磁盘上的文件。如果未找到，它会尝试查找目录，并使用我们的索引指令来查找索引文件。如果仍然找不到，它最终会内部重写为
    `/index.php`，并重新开始位置评估，此时 URI 以 `.php` 结尾，因此 PHP 位置将被使用，并将请求发送到 PHP。
- en: Step 2 – Location blocks
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 步骤 2 – 位置块
- en: 'As we''ll pass requests to a backend by using location blocks, it''ll be useful
    to understand the different types of location blocks available. Did you notice
    in the preceding section how the location blocks use different modifiers before
    the URI? In the first location there is no modifier, and in the second `a ~` is
    used. This modifier changes how nginx matches the location to the URI sent by
    the end user. The modifiers and rules are as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将通过使用位置块将请求传递给后端，因此了解可用的不同类型的位置块将非常有用。你注意到在前一节中，位置块在 URI 之前使用了不同的修饰符吗？在第一个位置中没有修饰符，而在第二个位置中使用了
    `a ~`。这个修饰符改变了 nginx 匹配位置和用户发送的 URI 的方式。修饰符和规则如下：
- en: '| Modifier | Result |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 修饰符 | 结果 |'
- en: '| --- | --- |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| No modifier | This will match as a prefix value. `location /` will match
    any URI beginning with `/`, while `location /foo` will match any URI beginning
    with `/foo`. |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 无修饰符 | 将作为前缀值进行匹配。`location /` 将匹配以 `/` 开头的任何 URI，而 `location /foo` 将匹配以
    `/foo` 开头的任何 URI。 |'
- en: '| `=` | This will match as an exact value. `location = /foo` will only match
    the exact `URI /foo` not the `URI /foobar` or even `/foo/`. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `=` | 将作为精确值匹配。`location = /foo` 只会匹配精确的 `URI /foo`，而不会匹配 `URI /foobar` 或
    `/foo/`。 |'
- en: '| `~` | This will match as a case sensitive regular expression using the PCRE
    library. |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `~` | 将使用 PCRE 库进行区分大小写的正则表达式匹配。 |'
- en: '| `~*` | This will match as a case insensitive regular expression using the
    PCRE library. |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `~*` | 将使用 PCRE 库进行不区分大小写的正则表达式匹配。 |'
- en: '| `^~` | Will match as a prefix value, which is more important than a regular
    expression. |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `^~` | 将作为前缀值进行匹配，比正则表达式更优先。 |'
- en: With all of these different location modifiers, nginx needs a way to know which
    one to use if multiple matches occur. To do this nginx assigns each type of modifier
    a certain specificity, which helps to determine how important a location is.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些不同的路径修饰符时，nginx 需要一种方法来确定在多个匹配时应该使用哪一个。为此，nginx 为每种修饰符分配一个特定的优先级，这有助于确定路径的优先级。
- en: '| Modifier | Specificity |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 修饰符 | 优先级 |'
- en: '| --- | --- |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `=` | This is the most specific modifier possible, as it matches only the
    exact string. If this location matches, it will be chosen first. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `=` | 这是最具体的修饰符，只匹配精确的字符串。如果该路径匹配，将会首先被选中。 |'
- en: '| `^~` | This modifier is used specifically when you want a prefix match to
    be more important than a regular expression location. If you have multiple matching
    locations of this type, the longest match will be used. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `^~` | 当你希望前缀匹配比正则表达式路径更优先时，使用此修饰符。如果有多个此类型的匹配路径，将使用最长的匹配。 |'
- en: '| `~` and `~*` | nginx has no way to decide how specific a regular expression
    is, so these are matched in the order they are defined. This means that if multiple
    regular expression locations match, the first one defined will be used. |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `~` 和 `~*` | nginx 无法决定正则表达式的具体性，因此这些会按定义的顺序匹配。这意味着如果多个正则表达式路径匹配，将使用第一个定义的路径。
    |'
- en: '| No modifier | Finally if nothing else matches, a standard prefix match is
    used. If multiple prefix locations match, the longest match will be used. |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 无修饰符 | 最终如果没有其他匹配项，将使用标准的前缀匹配。如果多个前缀路径匹配，将使用最长的匹配。 |'
- en: Knowing how nginx chooses a location is quite essential because of how nginx
    inheritance works. The common thing with every directive is that it will only
    ever inherit downwards, never up and never across contexts. In effect this means
    that we cannot have nginx apply two locations at the same time. As soon as we
    internally rewrite a request and locations are re-evaluated, nginx will forget
    about the directives in the old location and only care about the ones in the new
    location.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 了解 nginx 如何选择路径是非常重要的，因为 nginx 的继承机制如此工作。每个指令的共同点是，它只会向下继承，从不会向上或横向继承。实际上，这意味着我们不能让
    nginx 同时应用两个路径。一旦我们在内部重写了请求并重新评估路径，nginx 将忘记旧路径中的指令，只会关注新路径中的指令。
- en: 'For an illustration of this behavior, see this following server block:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这种行为，请参见以下服务器块：
- en: '[PRE20]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: When a request comes in for `/phpmyadmin/image/foo.jpg`, the `/phpmyadmin` location
    will be considered most specific and `try_files` will find the image. In contrast,
    if a request comes in for `/phpmyadmin`, it will first use the `/phpmyadmin` location
    and then `try_files` will rewrite the request into the PHP location. When this
    happens everything from the previous location is discarded and now the root is
    inherited from the server context making the `root /home/bill/www` instead, and
    the request results in a 404 error.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求 `/phpmyadmin/image/foo.jpg` 时，`/phpmyadmin` 路径将被认为是最具体的，`try_files` 将找到该图像。相比之下，当请求
    `/phpmyadmin` 时，它将首先使用 `/phpmyadmin` 路径，然后 `try_files` 会将请求重写为 PHP 路径。发生这种情况时，之前路径中的所有内容都会被丢弃，现在根路径会继承自服务器上下文，使得
    `root /home/bill/www` 成为新路径，最终请求会导致 404 错误。
- en: Instead, what we need to do here is use a sublocation so that nginx does not
    have to inherit across.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们在这里需要做的是使用子路径，这样 nginx 就不需要进行跨路径继承了。
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this example we don't need `try_files`, as we have no need to rewrite the
    request. If the URI matches `/phpmyadmin/`, it will be chosen before the PHP location
    at the bottom, and if it then also matches the PHP sublocation, it will flow into
    that one, maintaining the root directive from the parent location.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们不需要`try_files`，因为我们不需要重写请求。如果URI匹配`/phpmyadmin/`，它将在底部的PHP位置之前被选择，如果它还匹配PHP子位置，它将进入该位置，并保持父位置的根指令。
- en: The positive aspect of the preceding scenario is that it will always be simple
    to tell which directives will apply to any given request, by just following the
    rewrites to the final location and checking directives in the parent contexts.
    There are no complicated inheritance paths across contexts with some values being
    overridden by new directives, while others persist.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 前述场景的积极方面是，通过简单地跟随重写到最终位置并检查父上下文中的指令，始终可以轻松判断哪些指令会应用于特定请求。上下文之间没有复杂的继承路径，也没有某些值被新指令覆盖，而其他值保持不变。
- en: Related to location blocks is something called a **named location**. A named
    location is essentially a location that isn't reached via the URI, but rather
    by internal references. A named location is denoted by a `@`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 与位置块相关的是一种叫做**命名位置**的东西。命名位置本质上是一个无法通过URI访问的位置，而是通过内部引用访问。命名位置由`@`表示。
- en: '[PRE22]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This location is useful when you want to logically separate out some directives,
    but don't want that part of the config accessible through the URI. The previously
    named location might be used for an error page, for example, where it would only
    be called when a request would result in a 404 error.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 此位置在您希望逻辑上分离一些指令，但又不希望该配置部分通过URI访问时很有用。之前命名的位置可以用于错误页面，例如，只有当请求导致404错误时，才会调用该位置。
- en: '[PRE23]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Step 3 – Directive types
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 步骤3 – 指令类型
- en: 'In nginx, a directive will usually inherit based on a simple `http`-`server`-`location`
    flow. Mostly, anyway. nginx has different types of directives and each type inherits
    a bit differently. How a directive inherits depends on its type. In nginx, there
    are three types of directives and `try_files`. The three types are as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在nginx中，指令通常会基于简单的`http`-`server`-`location`流继承。大多数情况下，确实如此。nginx有不同类型的指令，每种类型的继承方式略有不同。指令如何继承取决于其类型。在nginx中，有三种类型的指令以及`try_files`。这三种类型如下：
- en: The standard directive
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准指令
- en: The array directive
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组指令
- en: The action directive
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动作指令
- en: The vast majority of directives are **standard directives**. These are passive
    configuration directives that do nothing but configure some aspect of nginx. They
    follow the standard inheritance of nginx and inherit downwards unless the lower
    context specifies the same directive.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 绝大多数指令都是**标准指令**。这些是被动配置指令，仅配置nginx的某些方面，不执行其他操作。它们遵循nginx的标准继承规则，并且会向下继承，除非下级上下文指定相同的指令。
- en: '**Array directives** differ a bit, as multiple directives can be specified
    in the same context. An example of an array directive would be the `access_log`
    directive. If we use the array directive three times in the same location block,
    nginx will create all three access logs.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**数组指令**略有不同，因为可以在同一上下文中指定多个指令。一个数组指令的例子是`access_log`指令。如果我们在同一位置块中使用三次数组指令，nginx将创建所有三个访问日志。'
- en: 'The possible confusion with array directives comes from the fact that while
    we can use the directive multiple times in the same context, when we try to use
    it multiple times in two different contexts, the lower context will replace the
    higher one, not add to it. Consider the following example:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 数组指令的混淆之处在于，虽然我们可以在同一上下文中多次使用该指令，但当我们尝试在两个不同的上下文中多次使用它时，下级上下文会替换上级上下文，而不是添加到上级上下文中。考虑以下示例：
- en: '[PRE24]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding example, there are two access logs defined but only one of
    them will ever be written to, depending upon whether the PHP location matches
    or not. If the goal is to log to both the server context access log and the PHP
    specific one, we need to define the server context access log twice.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，定义了两个访问日志，但只有一个会被写入，取决于PHP位置是否匹配。如果目标是同时记录到服务器上下文的访问日志和PHP特定的访问日志，我们需要在服务器上下文中定义两次访问日志。
- en: '[PRE25]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The final type of directive is the action directive. These are directives that
    cause an immediate action, and as such do not inherit but rather execute immediately
    if the relevant context becomes active. Take, for example, the `rewrite` directive
    in the following example:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一类指令是动作指令。这些指令会立即执行，因此不会继承，而是当相关上下文变为活动状态时立即执行。例如，以下示例中的`rewrite`指令：
- en: '[PRE26]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here the `rewrite` directive in the `server` context will always execute, thus
    the regex parser will always start and see if the pattern `^/booking(.*)` matches
    the current URI; the request will then flow into the `/calendar` location and
    the next rewrite will trigger.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在`server`上下文中的`rewrite`指令将始终执行，因此正则表达式解析器将始终启动并检查模式`^/booking(.*)`是否与当前URI匹配；请求将流入`/calendar`位置，并且下一个重写将被触发。
- en: Finally, there's `try_files`, which is a bit of an outlier. This is because
    `try_files` does not fit any of the other directive types. It is perhaps closest
    to an action directive in the sense that it will not inherit, the difference is
    that when placed in the `server` context nginx actually creates a special pseudo-location
    that is the least specific location possible. This essentially means that `try_files`
    in the `server` context will only ever execute if no location matches the request.
    This if of course a possible scenario, however, if `location /` is used, this
    location will always match and thus `try_files` is never used. It's highly recommended
    that `try_files` is never placed outside a location, so as to avoid confusion
    if suddenly `try_files` no longer executes when the configuration is changed.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 最后是`try_files`，它有点像例外。因为`try_files`不适用于其他任何指令类型。它可能最接近动作指令，因为它不会继承，区别在于，当它放置在`server`上下文中时，nginx实际上会创建一个特殊的伪位置，这是最不具体的可能位置。这基本上意味着，`try_files`在`server`上下文中只会在没有任何位置匹配请求时执行。当然，这是一种可能的情况，但如果使用`location
    /`，此位置将始终匹配，因此`try_files`永远不会被使用。强烈建议`try_files`永远不要放在位置外部，以避免在配置更改时突然发现`try_files`不再执行的情况。
- en: 'Unfortunately, this behavior only holds true when we consider the contexts
    `http`-`server`-`location`. Locations can have three different subcontexts of
    nested location, if-in-location and `limit_except`. The bad news here is that
    how directive inheritance works for these contexts is entirely up to the module
    that defines the directive. The good news is that the modules included with nginx
    have a standardized behavior and that standard and array directives function much
    like they normally do. The only real difference is with action directives which
    not only won''t inherit, but also won''t execute if a nested location matches.
    The following example illustrates this scenario:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这种行为只有在考虑`http`-`server`-`location`这些上下文时才成立。位置可以有三个不同的子上下文：嵌套位置、if-in-location和`limit_except`。这里的坏消息是，这些上下文中的指令继承是完全由定义该指令的模块决定的。好消息是，nginx附带的模块有标准化的行为，这些标准和数组指令的功能与正常情况下基本相同。唯一的真正区别在于动作指令，它们不仅不会继承，而且如果匹配嵌套位置，也不会执行。以下示例说明了这一场景：
- en: '[PRE27]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `rewrite` directive in the outer location will execute only if the inner
    location does not match.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 外部位置中的`rewrite`指令仅在内部位置不匹配时才会执行。
- en: Step 4 – Location reevaluation
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 步骤4 – 位置重新评估
- en: A useful thing to talk about when following action directives is the effect
    these directives have when executed, as they cause an internal rewrite. With every
    internal rewrite nginx will reevaluate the locations and possibly select a new
    one. Keeping internal redirects simple and few in number can often result in less
    debugging when problems arise.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行动作指令时，谈论这些指令的效果是很有用的，因为它们会导致内部重写。每次内部重写时，nginx都会重新评估位置，并可能选择一个新的位置。保持内部重定向简单且数量较少，通常可以在出现问题时减少调试工作。
- en: 'It''s useful to know that while `try_files` was listed as similar to action
    directives, only the final argument to `try_files` will actually cause a location
    reevaluation. This can cause issues with `try_files` like this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这一点很有用：虽然`try_files`被列为与动作指令类似，但只有`try_files`的最终参数才会导致位置重新评估。这可能会导致像这样的`try_files`问题：
- en: '[PRE28]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: While initially this may seem to enable pretty URLs, it will actually cause
    nginx to potentially output the source code of PHP files to the user, as `$uri.php`
    is not the last argument to `try_files`, and will therefore only set the internal
    `$uri` pointer and not reevaluate locations.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然最初这可能看起来可以启用漂亮的 URL，但实际上它可能导致 nginx 向用户输出 PHP 文件的源代码，因为 `$uri.php` 不是 `try_files`
    的最后一个参数，因此只会设置内部的 `$uri` 指针，而不会重新评估位置。
- en: Another useful thing to know is that rewrites can be made to not trigger location
    reevaluation by using the `break` flag at the end, for example, if you wish to
    rewrite from an old PHP script to a new one, you can avoid nginx going through
    the entire location evaluation process again.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的知识是，通过在末尾使用 `break` 标志，重写操作可以避免触发位置重新评估。例如，如果你希望将旧的 PHP 脚本重写到新的脚本上，你可以避免
    nginx 再次进行整个位置评估过程。
- en: '[PRE29]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Step 5 – Dealing with backends
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 5 步 - 处理后端
- en: Backends come into play once we need to use nginx for something more than just
    static file serving. nginx is designed to not embed anything within itself, but
    rather use transport protocols to talk to backends. There are multiple protocols
    available, such as HTTP, FastCGI, uWSGI, SCGI, and Memcached. Third party plugins
    may add even more possible protocols, allowing nginx to talk to more different
    backends.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 后端在我们需要将 nginx 用于不仅仅是静态文件服务时开始发挥作用。nginx 的设计目标是不要在其内部嵌入任何东西，而是使用传输协议与后端进行通信。有多种协议可供选择，如
    HTTP、FastCGI、uWSGI、SCGI 和 Memcached。第三方插件可能会增加更多可用的协议，使 nginx 能够与更多不同的后端进行通信。
- en: As nginx separates itself from backends using transport protocols, the management
    of these backends becomes a separate issue as well.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 nginx 通过传输协议与后端进行分离，管理这些后端也成为一个独立的问题。
- en: In order to have nginx talk to a backend, we'll have to tell the backend which
    file to execute as well as provide it some other information. Thankfully, nginx
    provides configuration for this with its default install. Check for files `fastcgi.conf`,
    `uwsgi_params`, and `scgi_params`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 nginx 与后端通信，我们需要告诉后端要执行哪个文件，并提供一些其他信息。幸运的是，nginx 在其默认安装中为此提供了配置。检查 `fastcgi.conf`、`uwsgi_params`
    和 `scgi_params` 文件。
- en: 'For HTTP proxying we usually need to provide the backend with some information
    through HTTP headers. Most backends will expect the `HOST` header to be set as
    well as the end user IP. Typically, a configuration for proxying would look like
    the following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 HTTP 代理，我们通常需要通过 HTTP 头部向后端提供一些信息。大多数后端会期望 `HOST` 头部被设置，并且还需要设置最终用户的 IP 地址。典型的代理配置如下所示：
- en: '[PRE30]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Step 6 – What can you do if you get stuck?
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 6 步 - 如果卡住了你能做什么？
- en: Getting stuck is an inevitable part of dealing with servers. The information
    from the *Step 5 – Dealing with backends* section will help us understand the
    flow of a request, and thus allow us to know which directives apply to the request.
    Sometimes, though, it's nice with a bit more information to help us debug a problem
    faster. For this nginx provides the error log. Most errors go in the error log,
    even if its a 404 error, or the backend reporting an error. Therefore, it's critical
    to have an error log defined with a proper log level.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 被卡住是处理服务器时不可避免的一部分。*第 5 步 - 处理后端* 部分的信息将帮助我们理解请求的流程，从而让我们知道哪些指令适用于该请求。然而，有时稍微多一点的信息可以帮助我们更快地调试问题。因此，nginx
    提供了错误日志。大多数错误都会记录在错误日志中，即使是 404 错误或后端报告的错误也是如此。因此，定义一个具有适当日志级别的错误日志是至关重要的。
- en: 'The error log directive in nginx is defined as:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: nginx 中的错误日志指令定义如下：
- en: '[PRE31]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: When faced with a problem, the first thing to do is set the log level to info
    and check for any entry in the error log. Usually, there will be something to
    give a clue, for instance if a 404 error occurs where it shouldn't, the nginx
    error log will explain where it's trying to find the file and that can help us
    visualize where in our configuration we've gone wrong.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 遇到问题时，首先要做的是将日志级别设置为 info 并检查错误日志中是否有任何条目。通常会有一些线索，例如，如果出现了本不应该出现的 404 错误，nginx
    错误日志会解释它试图查找文件的位置，这有助于我们可视化配置中的错误所在。
- en: 'If things still aren''t making sense at this point, nginx offers one more easy
    way to look at a request. The return directive allows us to return a status code
    and a string. For instance, we use the following:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果到目前为止仍然没有理解，nginx 提供了另一种简单的方法来查看请求。`return` 指令允许我们返回一个状态码和一个字符串。例如，我们使用以下内容：
- en: '[PRE32]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We can get the content of that variable output. This can function as a poor
    man's debugger.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以获取该变量输出的内容。这可以作为一种简易的调试工具。
- en: Top 9 features you need to know about
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你需要了解的 9 个重要特性
- en: While nginx at the core is designed to be a standard reverse proxy and HTTP
    web server, we can take it much further and use nginx as a central part in our
    toolchain, if we look into some of the more esoteric modules as well as the ones
    not included in the default compile. Thankfully, these modules are very often
    included in the binary packages provided by repositories, so regardless of which
    method was used to install nginx, they should be available for us to play with.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 nginx 核心设计是作为标准的反向代理和 HTTP 网络服务器，但我们可以进一步扩展，使用 nginx 作为我们工具链中的核心部分，前提是我们研究一些更为深奥的模块以及那些未包含在默认编译中的模块。幸运的是，这些模块通常会包含在由软件包管理库提供的二进制包中，因此无论使用何种方法安装
    nginx，它们都应当可以使用。
- en: Compressing site assets is one of the most important methods to optimize the
    perceived load time of a first time visitor, and even for subsequent page loads
    when compressing the HTML backend response.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩站点资源是优化首次访问者感知加载时间的最重要方法之一，甚至对于后续页面加载，当压缩 HTML 后端响应时同样有效。
- en: Gzipping
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 压缩
- en: Gzipping the JavaScript, CSS, and HTML responses is of utmost importance if
    load time is considered important, which naturally means that nginx offers this
    as a core feature. If we include the optional gzip static module, we can optimize
    this process even further by compressing the assets ahead of time, so that nginx
    can merely serve the static gzip file instead of having to compress it on-the-fly.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果加载时间很重要，那么对 JavaScript、CSS 和 HTML 响应进行压缩至关重要，这也意味着 nginx 将其作为核心功能提供。如果我们包含可选的
    gzip 静态模块，我们可以通过提前压缩资源进一步优化这个过程，这样 nginx 就可以直接提供静态的 gzip 文件，而无需实时压缩。
- en: To start off with, let's look at how to enable normal on-the-fly gzip compression.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们来看看如何启用正常的即时 gzip 压缩。
- en: '[PRE33]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: These directives are valid in an `http` context, which means that if we specify
    them in the `http` block they will apply to every `server` block, thus enabling
    us to specify compression only once. Using our knowledge of **nginx inheritance**
    from the *Quick Start* section we can still override this on a server or location
    basis if required by simply setting the `gzip` directive to `off`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令在 `http` 上下文中有效，这意味着如果我们在 `http` 块中指定它们，它们将适用于每个 `server` 块，从而使我们只需设置一次压缩。通过我们在
    *快速入门* 部分获得的 **nginx 继承** 知识，我们仍然可以在需要时通过将 `gzip` 指令设置为 `off`，在某个服务器或位置块上覆盖这些设置。
- en: 'The different directives are as always explained in detail in the documentation;
    however, here''s a brief overview of what each does:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的指令总是会在文档中详细说明；然而，这里是每个指令的简要概述：
- en: '| Directive | Description |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | 描述 |'
- en: '| --- | --- |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `gzip` | On or off, that is enables or disables gzipping. |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| `gzip` | 开启或关闭，表示启用或禁用 gzip 压缩。 |'
- en: '| `gzip_min_length` | This is the minimum response size in bytes before nginx
    will compress the response. It Defaults to 20 bytes. |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| `gzip_min_length` | 这是在 nginx 压缩响应之前，响应的最小字节数。默认为 20 字节。 |'
- en: '| `gzip_proxied` | This defines if nginx should compress the response when
    nginx is behind other proxy software, such as Varnish or HAProxy. It defaults
    to off. |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| `gzip_proxied` | 定义当 nginx 位于其他代理软件（如 Varnish 或 HAProxy）后面时，是否应压缩响应。默认为关闭。
    |'
- en: '| `gzip_comp_level` | This defines the gzip compression level, default being
    `1`. It gives diminishing returns past level `4`, and past level `5` there''s
    rarely any difference at all. Higher levels use more CPU resources. |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| `gzip_comp_level` | 这定义了 gzip 压缩级别，默认值为 `1`。超过级别 `4` 后，压缩效果递减，超过级别 `5` 后几乎没有区别。更高的级别会消耗更多的
    CPU 资源。 |'
- en: '| `gzip_types` | The mime types to compress. Text/html is always compressed
    if gzipping is enabled. To compress everything use `*`, though, this also compresses
    resources which are already compressed, thus wasting server resources. |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| `gzip_types` | 需要压缩的 MIME 类型。如果启用了 gzip，text/html 总是会被压缩。要压缩所有内容，可以使用 `*`，不过这样会压缩已经被压缩的资源，从而浪费服务器资源。
    |'
- en: '| `gzip_disable` | Regex matched against the user agent to determine when to
    not compress in case the user agent is buggy. `msie6` is a special value for Internet
    Explorer 4 to 6, which were buggy. |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| `gzip_disable` | 正则表达式匹配用户代理，以确定在用户代理存在 bug 的情况下何时不进行压缩。`msie6` 是针对 Internet
    Explorer 4 到 6 的特殊值，因为它们存在 bug。 |'
- en: Pre-gzipping
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预压缩
- en: 'Using the pre-gzipping module has the advantage of saving CPU resources, as
    the site assets will already be stored in a compressed format instead of having
    to be compressed on each request. Making use of the pre-gzipping module is both
    simpler and more complicated at the same time. More complicated as we have to
    gzip the files ourselves, but simpler as there are far less configuration directives.
    To enable the precompressed gzip module we simply use the following configuration:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 使用预先压缩的 gzip 模块有节省 CPU 资源的优势，因为网站资源已经以压缩格式存储，而不必在每次请求时都进行压缩。使用预压缩的 gzip 模块既更简单也更复杂。更复杂的是我们必须自己压缩文件，但更简单的是配置指令要少得多。要启用预压缩的
    gzip 模块，我们只需使用以下配置：
- en: '[PRE34]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Immediately, we'll see that the only new directive is really `gzip_static` which,
    like the `gzip` directive, takes an `on` or `off` value to enable or disable it.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们立刻看到，唯一新增的指令实际上是 `gzip_static`，它与 `gzip` 指令一样，取值为 `on` 或 `off` 来启用或禁用它。
- en: Gzipping files is a bit outside the scope of this book. It can either be done
    by hand using the command line gzip application, or automated as part of a build
    process, but it has to be done outside of nginx.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Gzipping 文件超出了本书的范围。它可以通过命令行 gzip 应用手动完成，也可以作为构建过程的一部分自动化处理，但必须在 nginx 之外完成。
- en: Using nginx as a full-page micro cache
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 nginx 作为全页微缓存
- en: It's noon and you've just sat down for lunch when your monitoring service sends
    you a text message saying your start-up's newly launched web service is down.
    Seconds later your cofounder texts you in a panic that the website is down, and
    just as his submissions to HackerNews and Reddit got on the front page too. Ars
    Technica and The Next Web are currently writing articles covering your start-up
    and the world is literally about to go under if you don't get the website online
    immediately.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是中午，你刚坐下准备吃午餐，这时你的监控服务发来一条短信，告诉你初创公司新推出的网页服务宕机了。几秒钟后，你的联合创始人慌张地发来短信，说网站崩溃了，而且恰好他提交到
    HackerNews 和 Reddit 的帖子刚刚上了首页。Ars Technica 和 The Next Web 正在撰写关于你们初创公司的文章，如果你不马上让网站恢复在线，整个世界简直要崩溃了。
- en: Enter the micro cache. The concept is that any page which doesn't contain user
    specific information should be cached in nginx, so that the backend application
    isn't even touched. This relieves load on the backend and allows most applications
    to handle far more traffic. Normally, an application will have to be written with
    caching in mind to handle invalidation of cached pages whenever content updates.
    The micro cache concept handles this by only caching things for a short period
    of time. If traffic spikes to 20 requests per second, and the micro cache is set
    to expire after 10 seconds, that's 200 requests the backend application did not
    have to handle, which makes micro caching a good tool to use when in a pinch.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 进入微缓存。其概念是，任何不包含用户特定信息的页面都应该在 nginx 中缓存，这样后端应用程序就不会被访问到。这减轻了后端的负担，使大多数应用程序能够处理更多的流量。通常，应用程序必须考虑缓存，才能在内容更新时处理缓存页面的失效。微缓存的概念通过仅缓存短时间内的内容来处理这个问题。如果流量激增到每秒
    20 个请求，而微缓存设置为 10 秒后过期，那么后端应用程序就不必处理 200 个请求，这使得微缓存成为在紧急情况下非常有用的工具。
- en: While the concept of micro cache is simple, the execution can be a bit more
    complicated depending on the application. The key aspect is to only cache pages
    that contain no user specific information. If no such thing exists, it's very
    simple, otherwise we'll need to control when to cache and when not to cache.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然微缓存的概念很简单，但根据应用程序的不同，执行起来可能会更复杂。关键点是只缓存不包含用户特定信息的页面。如果没有这样的页面，事情会非常简单；否则，我们就需要控制何时缓存，何时不缓存。
- en: There are two approaches to do this. The first is to use the built-in FastCGI
    cache or the equivalent for the other modules, such as proxy, uWSGI, SCGI, and
    so on. The second is to use Memcached as a cache, which is agnostic to the proxy
    method.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以实现这一点。第一种是使用内置的 FastCGI 缓存，或者其他模块的等效方法，如 proxy、uWSGI、SCGI 等。第二种是使用 Memcached
    作为缓存，这与代理方法无关。
- en: The difference between the two methods is that the built-in FastCGI cache is
    read and write, while Memcached cache is read-only. Essentially, it becomes a
    question of where the responsibility for writing to the cache lies. With the built-in
    FastCGI cache the logic is placed in the nginx config, while with Memcached the
    logic is placed in the application, as it will need to write to the cache itself.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法的区别在于，内置的 FastCGI 缓存是读写的，而 Memcached 缓存是只读的。从本质上讲，这是一个关于谁负责写入缓存的问题。对于内置的
    FastCGI 缓存，逻辑放在 nginx 配置中，而对于 Memcached，逻辑放在应用程序中，因为它需要自己写入缓存。
- en: Memcached micro cache
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Memcached 微型缓存
- en: 'Lets start with the Memcached scenario, as that''s simpler from an nginx point
    of view and largely similar in construct for us to build on later. A basic Memcached
    micro cache would look like the following in the nginx configuration:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 Memcached 场景开始，因为从 nginx 的角度来看，这是更简单的，而且对于我们后续的构建相似。一个基本的 Memcached 微型缓存在
    nginx 配置中会如下所示：
- en: '[PRE35]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the preceding configuration, the important aspects take place inside the
    location to handle PHP requests. Specifically, the variable `$memcached_key` is
    the most important, as this defines the key to request from Memcached.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的配置中，重要的部分发生在处理 PHP 请求的 location 内。具体来说，变量 `$memcached_key` 是最关键的，因为它定义了从
    Memcached 请求的键。
- en: A potential complication here is if pages with user data and without user data
    share the same request URI. In this case, extra configuration is needed to check
    if a page contains user data. This is always application specific, but common
    methods are checking for cookies via `$http_cookie` or checking the URL arguments
    through `$args`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 一个潜在的复杂问题是，如果带有用户数据的页面和不带用户数据的页面共享相同的请求 URI。在这种情况下，需要额外的配置来检查页面是否包含用户数据。这通常是应用程序特定的，但常见的方法是通过
    `$http_cookie` 检查 cookie，或通过 `$args` 检查 URL 参数。
- en: Another thing to notice is that only `GET` requests use the cache, anything
    not a `GET` request will instead `fastcgi_pass` to our backend, thus bypassing
    the cache.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的事项是，只有 `GET` 请求会使用缓存，任何不是 `GET` 请求的请求会转发到我们的后端，进而绕过缓存。
- en: If a request passes all the validation and is sent to Memcached and Memcached
    returns a 404 not found status, `error_page` will send the request to the `@nocache`
    named location, which will `fastcgi_pass` to our backend. The backend is then
    responsible for populating the proper key in Memcached for the next request to
    use.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求通过所有验证并被发送到 Memcached，且 Memcached 返回 404 未找到状态，`error_page` 会将请求发送到 `@nocache`
    命名位置，那里会 `fastcgi_pass` 到我们的后端。然后，后端负责为下一个请求在 Memcached 中填充正确的键。
- en: As the application is writing to the cache here, remember to set the cache expire
    time to something low enough that we won't have stale cache entries for long when
    the application date updates.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 由于应用程序正在向缓存写入数据，记得将缓存过期时间设置得足够短，以便在应用程序数据更新时不会有过期的缓存条目。
- en: Built-in FastCGI cache
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内置 FastCGI 缓存
- en: 'Using the built-in caches is very similar in construct to the previous config
    example. The main difference is that not only do we have to define when to read
    from the cache, but also when to write to it. A typical configuration would look
    like the following:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内置缓存的构建方式与之前的配置示例非常相似。主要区别在于，我们不仅需要定义何时从缓存读取，还需要定义何时写入缓存。一个典型的配置如下所示：
- en: '[PRE36]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As can be seen, the concept is largely the same. Set up the cache `keys_zone`,
    figure out whether to cache or not and finally set the cache key. To fully explain
    what's going on, let's have a look at what the different directives actually do.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，概念大体相同。设置缓存 `keys_zone`，确定是否缓存，最后设置缓存键。为了完整解释发生了什么，我们来看一下不同指令的实际作用。
- en: '| Directive | Description |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | 描述 |'
- en: '| --- | --- |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `fastcgi_cache_path` | Sets the path to store cached responses under. Also
    names the key zone associated with this cache path and specifies how much metadata
    and data can be stored there. In this example, `keys_zone` is called micro cache.
    |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| `fastcgi_cache_path` | 设置存储缓存响应的路径。还命名了与此缓存路径相关联的键区，并指定可以在该路径下存储多少元数据和数据。在此示例中，`keys_zone`
    被称为微型缓存。 |'
- en: '| `fastcgi_no_cache` | Specifies whether to write to the cache or not. Anything
    other than an empty string or the value numeric `0` will cause it to not write
    to the cache. |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| `fastcgi_no_cache` | 指定是否写入缓存。任何非空字符串或数值 `0` 以外的值都会导致不写入缓存。 |'
- en: '| `fastcgi_bypass_cache` | Specifies whether to read from the cache or not.
    Anything other than an empty string or the numeric value `0` will cause it to
    not read from the cache. |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| `fastcgi_bypass_cache` | 指定是否从缓存读取数据。任何非空字符串或数值`0`都将导致不从缓存读取。 |'
- en: '| `fastcgi_cache` | Specifies `keys_zone` to use. In this example, the `keys_zone`
    used is micro cache. |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| `fastcgi_cache` | 指定要使用的`keys_zone`。在此例中，使用的`keys_zone`是micro cache。 |'
- en: '| `fastcgi_cache_key` | The key used to identify data in the cache. |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| `fastcgi_cache_key` | 用于标识缓存中数据的键。 |'
- en: '| `fastcgi_cache_valid` | Sets the caching time for a given response code.
    In this example, we want to cache only 200 responses and we will cache them for
    5 seconds. Our application can override this directive using the `X-Accel-Expires`
    header from the X-Accel module or by using standard caching headers `Expires`
    and `Cache-Control`. |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| `fastcgi_cache_valid` | 设置给定响应码的缓存时间。在这个例子中，我们只缓存200响应，并将其缓存5秒钟。我们的应用程序可以通过X-Accel模块的`X-Accel-Expires`头部或使用标准缓存头`Expires`和`Cache-Control`来覆盖此指令。
    |'
- en: '| `fastcgi_cache_use_stale` | Specifies when the cache will use a cache entry
    after it''s expired. In this example, we use `updating` to allow us to use the
    cache while it''s being updated, thus preventing a sudden flood of connections
    when a key expires. |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| `fastcgi_cache_use_stale` | 指定缓存过期后，何时使用缓存条目。在此例中，我们使用`updating`，允许在缓存更新时使用缓存，从而防止在密钥过期时连接突然增加。
    |'
- en: Using nginx behind other proxies
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用nginx作为其他代理后的反向代理
- en: While nginx can certainly be used as the only reverse proxy in our stack, there
    are scenarios where we might want to use alternative software in front of nginx
    because we have in-house expertise or are already using them. Popular choices
    here are Varnish and HAProxy.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然nginx肯定可以作为我们栈中的唯一反向代理，但在某些情况下，我们可能希望在nginx前使用其他软件，因为我们拥有内部专长或已经在使用它们。这里的流行选择包括Varnish和HAProxy。
- en: In this case we can have nginx handle such a scenario transparently using the
    optional module Real IP. With this we can have nginx transparently replace the
    variables referencing an IP with the IP of the proxy, thus keeping logs and the
    configuration of the same while giving us the ability to turn frontends on and
    off.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以使用可选模块Real IP，让nginx透明地处理这种场景。这样，nginx可以透明地替换引用IP的变量为代理的IP，从而保持日志和配置一致，同时允许我们开启和关闭前端。
- en: There are only three directives associated with the real IP module, thus making
    it fairly simple to implement and understand.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 只有三个与真实IP模块相关的指令，因此它相对简单实现和理解。
- en: '[PRE37]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '| Directive | Description |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | 描述 |'
- en: '| --- | --- |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `set_real_ip_from` | This specifies an IP to enable the real IP module from.
    Preventing random people from pretending to be a frontend to nginx. This can be
    specified multiple times. |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| `set_real_ip_from` | 该指令指定启用真实IP模块的IP。防止随机人员伪装成nginx前端。可以多次指定此项。 |'
- en: '| `real_ip_header` | This specifies the header to get the real IP from. X-Forwarded-For
    and X-Real-IP are the most commonly used. This defaults to X-Real-IP. |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| `real_ip_header` | 该指令指定从哪个头部获取真实IP。X-Forwarded-For和X-Real-IP是最常用的。默认值为X-Real-IP。
    |'
- en: '| `real_ip_recursive` | This specifies the IP to use. If off, this will use
    the last address in header defined by `real_ip_header`. If on, this will search
    the IP list until it finds one not in the trusted IP list. This is useful when
    a request has been forwarded multiple times. This defaults to off. |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| `real_ip_recursive` | 该指令指定使用哪个IP。如果关闭，则使用`real_ip_header`中定义的最后一个地址。如果开启，则会遍历IP列表，直到找到一个不在受信IP列表中的IP。这在请求被转发多次时非常有用。默认值为关闭。
    |'
- en: Setting up secure downloads
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置安全下载
- en: nginx has a feature called X-Accel which is meant as a replacement for the `mod_sendfile`
    functionality found in Apache httpd and lighttpd. The concept is mostly the same.
    A request is sent to a backend application, which can then do whatever it needs
    to do, for instance it might log a download or validate user credentials. Once
    the backend application is done doing its work it issues a non-standard HTTP header
    `X-Accel-Redirect` with a path to the file relative to the document root. nginx
    will detect this header and look for a matching location based on the path sent.
    An example of this would be a PHP backend application issuing a header X-Accel-Redirect,
    that is, `/video/birthday/dad.mp4`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: nginx 有一个名为 X-Accel 的功能，旨在替代 Apache httpd 和 lighttpd 中的 `mod_sendfile` 功能。其概念基本相同。请求发送到后端应用程序，后者可以执行其需要的任何操作，例如记录下载或验证用户凭据。一旦后端应用程序完成其工作，它将发出一个非标准的
    HTTP 头 `X-Accel-Redirect`，其中包含相对于文档根目录的文件路径。nginx 将检测此头并根据发送的路径查找匹配的位置。例如，PHP
    后端应用程序发出头部 X-Accel-Redirect，即 `/video/birthday/dad.mp4`。
- en: 'In nginx, we would then have the following configuration:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在 nginx 中，我们会有以下配置：
- en: '[PRE38]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In this scenario, nginx would then look for the file at the path `/mnt/data/video/birthday/dad.mp4`.
    If the file is not found it will send a 404 status error; if the file is found
    it will start sending the file to the end user, thus relieving the backend application
    of this.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，nginx 将查找路径 `/mnt/data/video/birthday/dad.mp4` 的文件。如果未找到文件，将发送 404 状态错误；如果找到文件，将开始向最终用户发送文件，从而减轻后端应用程序的负担。
- en: nginx has a number of X-Accel headers available.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: nginx 有许多可用的 X-Accel 头信息。
- en: '| Header | Description |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| 头信息 | 描述 |'
- en: '| --- | --- |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| X-Accel-Redirect | Specifies a URI relative to the root directive in nginx
    configuration to the file to send to the user. |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| X-Accel-Redirect | 指定一个 URI，相对于 nginx 配置中的根指令，指定要发送给用户的文件。 |'
- en: '| X-Accel-Buffering | Specifies whether to allow nginx to buffer the connection
    or not. Turn off if doing Comet style application. Defaults to yes. |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| X-Accel-Buffering | 指定是否允许 nginx 缓冲连接。如果进行 Comet 样式的应用程序，请关闭。默认为是。 |'
- en: '| X-Accel-Charset | Specifies the character set of the connection. Defaults
    to utf-8. |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| X-Accel-Charset | 指定连接的字符集。默认为 utf-8。 |'
- en: '| X-Accel-Expires | Used to control whether nginx will cache the application
    response or not. Defaults to off. |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| X-Accel-Expires | 用于控制 nginx 是否缓存应用响应。默认为关闭。 |'
- en: '| X-Accel-Limit-Rate | Specifies a rate limit for the connection. |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| X-Accel-Limit-Rate | 指定连接的速率限制。 |'
- en: Doing GeoIP lookups
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进行 GeoIP 查找
- en: 'To do a GeoIP lookup, nginx will need the MaxMind GeoIP database. Both the
    paid and free versions are compatible with this module. The free version can be
    downloaded from:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行 GeoIP 查找，nginx 将需要 MaxMind GeoIP 数据库。付费版和免费版均兼容此模块。可以从以下位置下载免费版本：
- en: '[http://dev.maxmind.com/geoip/geolite](http://dev.maxmind.com/geoip/geolite)'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://dev.maxmind.com/geoip/geolite](http://dev.maxmind.com/geoip/geolite)'
- en: 'Every directive in this module has to be defined in the `http` section and
    looks like the following:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块中的每个指令都必须在 `http` 部分中定义，并且看起来如下所示：
- en: '[PRE39]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '| Directive | Description |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | 描述 |'
- en: '| --- | --- |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE40]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '| Specifies the path to the country level GeoIP database. |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| 指定国家级别 GeoIP 数据库的路径。 |'
- en: '|'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE41]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '| Specifies the path to the city level GeoIP database. This database also contains
    the data from the country database. |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| 指定城市级别 GeoIP 数据库的路径。该数据库还包含国家数据库的数据。 |'
- en: '|'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE42]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '| Specifies the path to the organization level GeoIP database. The GeoIP organization
    database is a paid-only database that nginx also supports. |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| 指定组织级别 GeoIP 数据库的路径。GeoIP 组织数据库是一个仅限付费的数据库，nginx 也支持它。 |'
- en: '|'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE43]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '| When nginx is used behind other proxy software, this can be used to specify
    the IP of that proxy and have nginx do a lookup on the IP in X-Forwarded-For instead.
    |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| 当 nginx 用于其他代理软件后面时，可以使用此选项指定该代理的 IP，并让 nginx 在 X-Forwarded-For 中进行 IP 查找。
    |'
- en: '|'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE44]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '| Functionally similar to `real_ip_recursive` from the using nginx behind other
    proxies example. |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| 与在使用 nginx 后面的其他代理示例中的 `real_ip_recursive` 功能上相似。 |'
- en: When the proper database is loaded into nginx, the following variables will
    become available to be used through the config, for instance in the access log
    or to be passed on to a backend.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 加载正确的数据库到 nginx 后，以下变量将可通过配置使用，例如在访问日志中或传递给后端使用。
- en: '| Variable | Description |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| 变量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE45]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '| Variable name depends on the database specified. Contains the two letter
    country code. |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| 变量名取决于指定的数据库。包含两位字母的国家代码。 |'
- en: '|'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE46]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '| Variable name depends on the database specified. Contains the three letter
    country code. |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| 变量名取决于指定的数据库。包含三位字母的国家代码。 |'
- en: '|'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE47]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '| Variable name depends on the database specified. Contains the full country
    name. |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| 变量名取决于指定的数据库。包含完整的国家名称。 |'
- en: '|'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE48]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '| Contains the two letter code for the continent. Only available in city database.
    |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| 包含该大洲的两位字母代码。仅在城市数据库中可用。 |'
- en: '|'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE49]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '| Contains US region DMA code. Only available in city database. |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| 包含美国地区 DMA 代码。仅在城市数据库中可用。 |'
- en: '|'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE50]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '| Contains the latitude of the users location. Only available in city database.
    |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| 包含用户位置的纬度。仅在城市数据库中可用。 |'
- en: '|'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE51]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '| Contains the longitude of the users location. Only available in city database.
    |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| 包含用户位置的经度。仅在城市数据库中可用。 |'
- en: '|'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE52]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '| Contains the two symbol country region code. Only available in city database.
    |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| 包含两位符号的国家地区代码。仅在城市数据库中可用。 |'
- en: '|'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE53]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '| Contains the full country region name. Only available in city database. |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| 包含完整的国家地区名称。仅在城市数据库中可用。 |'
- en: '|'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE54]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '| Contains the full city name. Only available in city database. |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| 包含完整城市名称。仅在城市数据库中可用。 |'
- en: '|'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE55]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '| Contains the postal code of the city. Only available in city database. |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| 包含城市的邮政编码。仅在城市数据库中可用。 |'
- en: '|'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE56]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '| Contains the organization name. Could for instance be a university. Only
    available in organization database. |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| 包含组织名称。例如，可以是大学。仅在组织数据库中可用。 |'
- en: Limiting user requests
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 限制用户请求
- en: There are two ways to limit requests in nginx, concurrent requests and frequency
    of requests. Both can be used simultaneously and multiple times on different factors.
    For instance, we can limit concurrent requests per IP while we limit concurrent
    requests per server block.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 限制 nginx 请求的方式有两种，分别是并发请求和请求频率。两者可以同时使用，并且可以在不同的因素上多次应用。例如，我们可以限制每个 IP 的并发请求，同时限制每个服务器块的并发请求。
- en: To achieve this, nginx has two modules; one which limits concurrency and the
    other which limits frequency.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，nginx 提供了两个模块：一个限制并发，另一个限制频率。
- en: Limiting concurrent connections
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 限制并发连接
- en: To limit concurrent requests, we use the **limit conn** module. The concept
    is fairly simple, we create a memory zone based on a variable and nginx will then
    track concurrent requests grouped by this variable. We could, for instance, use
    the `$server_name` variable to limit concurrent requests per vhost, or we could
    use `$binary_remote_addr` to limit on a users IP.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 为了限制并发请求，我们使用 **limit conn** 模块。其概念相当简单，我们基于一个变量创建一个内存区域，然后 nginx 会根据这个变量追踪并发请求。例如，我们可以使用
    `$server_name` 变量来限制每个虚拟主机的并发请求，或者使用 `$binary_remote_addr` 来限制用户的 IP。
- en: '[PRE57]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '| Directive | Description |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | 描述 |'
- en: '| --- | --- |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `limit_conn_zone` | This creates the memory zone. This also specifies the
    variable to limit based on as well as the maximum size of the memory zone. |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| `limit_conn_zone` | 这创建了内存区域，并指定了用于限制的变量以及内存区域的最大大小。 |'
- en: '| `limit_conn` | This specifies which zone to limit by and how many concurrent
    connections to allow. |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| `limit_conn` | 这指定了要限制的区域以及允许的并发连接数。 |'
- en: '| `limit_conn_log_level` | This specifies the log level required before the
    module will log that the concurrent connection limit was exceeded. This defaults
    to error. Generally, it is not advised to set it lower unless needed, as it can
    quickly flood the error log and hide more useful data. |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| `limit_conn_log_level` | 这指定了在模块记录并发连接限制被超出之前所需的日志级别。默认值为 error。通常不建议将其设置为较低级别，除非必要，因为这样会迅速填满错误日志并隐藏更有用的数据。
    |'
- en: Limit frequency of connections
  id: totrans-349
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 限制连接频率
- en: To limit the frequency of connections we can use the **limit req** module. It's
    syntactically similar with only some minor changes to control rate instead of
    concurrency.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 为了限制连接频率，我们可以使用 **limit req** 模块。其语法类似，只有少数的改动，主要是控制速率而非并发。
- en: '[PRE58]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '| Directive | Description |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | 描述 |'
- en: '| --- | --- |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `limit_req_zone` | This creates the memory zone. This specifies the variable
    to limit based on the variable used as well as the maximum size of the memory
    zone and the rate at which connections should be allowed. Requests exceeding this
    rate will be buffered until they reach the limit set by burst at which point they
    will return 503 instead. |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| `limit_req_zone` | 该指令用于创建内存区域。它指定了限制的变量以及内存区域的最大大小和允许连接的速率。超过该速率的请求将被缓冲，直到达到由
    burst 设置的限制，届时将返回 503 错误。|'
- en: '| `limit_req` | This specifies which zone to limit by and the size of the request
    buffer, called **burst**. |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| `limit_req` | 该指令指定要限制的区域以及请求缓冲区的大小，称为 **burst**。|'
- en: '| `limit_req_log_level` | This specifies the log level required before module
    will log that the connection frequency limit was exceeded. This defaults to error.
    Generally, it is not advised to set it lower unless needed, as it can quickly
    flood the error log and hide more useful data. |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| `limit_req_log_level` | 该参数指定在模块记录连接频率限制被超出之前需要的日志级别。默认值为 error。通常不建议将其设置得过低，除非有必要，因为这可能会迅速填满错误日志并掩盖更有用的数据。|'
- en: Using nginx for streaming videos
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 nginx 进行视频流传输
- en: Streaming videos with nginx is extremely easy. nginx has two optional modules
    for streaming videos, FLV and MP4, which enable it to stream flash video formats
    and MP4 containers with H.264/AAC encoding. These modules are compatible with
    all the traditional Flash and HTML5 players available today.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 nginx 进行视频流式传输非常简单。nginx 提供了两个可选模块来进行视频流传输，分别是 FLV 和 MP4，这使得它能够流式传输 Flash
    视频格式和带有 H.264/AAC 编码的 MP4 容器。这些模块与今天所有传统的 Flash 和 HTML5 播放器兼容。
- en: Streaming FLV files
  id: totrans-359
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 流式传输 FLV 文件
- en: 'The FLV module is the simplest of the two and contains only a single directive.
    To enable it, simply specify `flv` in a location as follows:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: FLV 模块是两个模块中最简单的，只有一个指令。要启用它，只需在位置中指定 `flv`，如以下示例所示：
- en: '[PRE59]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: That's literally everything there is to FLV streaming on the nginx side. If
    the `.flv` files are properly prepared with metadata and keyframes, they should
    stream smoothly and be seekable with this.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 nginx 端进行 FLV 流式传输的全部内容。如果 `.flv` 文件正确准备了元数据和关键帧，它们应该能够流畅地播放，并支持跳转。
- en: Streaming MP4 files
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 流式传输 MP4 文件
- en: The MP4 module is pretty much exactly the same with only a few extra directives
    for additional control.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: MP4 模块与 FLV 模块几乎完全相同，仅增加了一些额外的指令用于额外的控制。
- en: '[PRE60]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The buffers control how much memory nginx can use to process the file. This
    is only limiting during metadata parsing where a large buffer may be required.
    For this the maximum buffer size becomes relevant. If it''s set too small, nginx
    will output a 500 status error and log the error as:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区控制 nginx 用于处理文件的内存大小。这只在元数据解析期间限制内存使用，可能需要较大的缓冲区。在这种情况下，最大缓冲区大小变得至关重要。如果设置得太小，nginx
    会输出 500 状态错误，并记录错误：
- en: '[PRE61]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Using WebSockets with nginx
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 nginx 的 WebSocket
- en: Version 1.3.13 introduced connection upgrading support to nginx, which means
    WebSocket support. As WebSockets use the standard HTTP protocol for the initial
    handshake, nginx can make WebSocket support part of the standard proxy module.
    This means that all the features available to normal HTTP backends are also available
    to WebSocket proxying.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 版本 1.3.13 引入了连接升级支持到 nginx，这意味着支持 WebSocket。由于 WebSocket 在初始握手时使用标准的 HTTP 协议，nginx
    可以将 WebSocket 支持作为标准代理模块的一部分。这意味着，所有普通 HTTP 后端可用的功能，也可以应用于 WebSocket 代理。
- en: 'The configuration required for handling connection upgrading is as follows:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 处理连接升级所需的配置如下：
- en: '[PRE62]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: A few things to notice about WebSocket support are that they can time out just
    like any other HTTP proxied request. WebSockets are affected by `proxy_read_timeout`
    that defaults to 60 seconds. The **keepalive** feature in nginx is not of use
    here, as keepalive pings are empty packets and as such contain no data for nginx
    to pass to the backend. To combat this, you either need to raise the time out,
    or implement your own keepalive ping message. The added benefit of the latter
    solution is that it will also function as a health check for the connection itself.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 WebSocket 支持，有几点需要注意：它们可能会超时，就像任何其他通过 HTTP 代理的请求一样。WebSocket 会受到 `proxy_read_timeout`
    的影响，默认时间为 60 秒。nginx 中的 **keepalive** 功能在这里无效，因为 keepalive 心跳包是空的数据包，因此不包含任何数据供
    nginx 转发给后端。为了解决这个问题，你需要提高超时时间，或者实现你自己的 keepalive 心跳消息。后者的额外好处是它还可以作为连接本身的健康检查。
- en: People and places you should get to know
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你应该了解的人和地点
- en: The following links are a collection of individuals, aggregating sites, and
    articles that are worth following for the occasional nugget of nginx wisdom.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 以下链接集合了值得关注的个人、聚合网站和文章，偶尔能找到一些有价值的nginx经验分享。
- en: Official links
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 官方链接
- en: 'Website for nginx, Inc, the company behind the nginx software:'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: nginx公司官网，nginx软件的背后公司：
- en: '[http://nginx.com](http://nginx.com)'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://nginx.com](http://nginx.com)'
- en: 'Website for the nginx software, includes documentation and links to resources,
    such as books:'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: nginx软件官网，包含文档以及指向其他资源的链接，如书籍：
- en: '[http://nginx.org](http://nginx.org)'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://nginx.org](http://nginx.org)'
- en: Articles and tutorials
  id: totrans-380
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文章和教程
- en: 'The following link is community-curated but is also the officially hosted documentation,
    which sometimes contains additional information compared to official documentation,
    not always updated, though:'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下链接是由社区整理的，但也是官方托管的文档，某些情况下包含与官方文档不同的附加信息，更新频率不一：
- en: '[http://wiki.nginx.org](http://wiki.nginx.org)'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://wiki.nginx.org](http://wiki.nginx.org)'
- en: Community
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 社区
- en: 'A web interface for the mailing list, the only official way to get help:'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 邮件列表的网页界面，获取帮助的唯一官方途径：
- en: '[http://forum.nginx.org](http://forum.nginx.org)'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://forum.nginx.org](http://forum.nginx.org)'
- en: 'Community supported IRC channel with high activity:'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 社区支持的IRC频道，活跃度较高：
- en: '[Irc://irc.freenode.org/nginx](http://Irc://irc.freenode.org/nginx) (#nginx
    channel on [irc.freenode.org](http://irc.freenode.org))'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[Irc://irc.freenode.org/nginx](http://Irc://irc.freenode.org/nginx) （#nginx频道位于[irc.freenode.org](http://irc.freenode.org)）'
- en: Blogs
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 博客
- en: 'An aggregator of various nginx blogs at:'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个聚合各种nginx博客的网站：
- en: '[http://planet.ngx.cc/](http://planet.ngx.cc/)'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://planet.ngx.cc/](http://planet.ngx.cc/)'
- en: 'A community supporter who blogs about nginx:'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个支持社区的博客作者，分享关于nginx的内容：
- en: '[http://kbeezie.com/tag/nginx/](http://kbeezie.com/tag/nginx/)'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://kbeezie.com/tag/nginx/](http://kbeezie.com/tag/nginx/)'
- en: 'A community supporter who blogs about nginx:'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个支持社区的博客作者，分享关于nginx的内容：
- en: '[http://michael.lustfield.net/category/linux/nginx](http://michael.lustfield.net/category/linux/nginx)'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://michael.lustfield.net/category/linux/nginx](http://michael.lustfield.net/category/linux/nginx)'
- en: 'Blog of a prolific module creator; mostly writes about his own third party
    modules but occasionally has insights into nginx internals:'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个高产模块创建者的博客；大多写自己的第三方模块，但偶尔也有关于nginx内部实现的见解：
- en: '[http://agentzh.blogspot.com](http://agentzh.blogspot.com)'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://agentzh.blogspot.com](http://agentzh.blogspot.com)'
- en: 'Blog of a module creator, Valery Kholodkov, who also blogs about the internals
    of nginx:'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个模块创建者Valery Kholodkov的博客，他也会分享关于nginx内部实现的内容：
- en: '[http://www.nginxguts.com/category/nginx/](http://www.nginxguts.com/category/nginx/)'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://www.nginxguts.com/category/nginx/](http://www.nginxguts.com/category/nginx/)'
- en: 'An editorial on the nginx code architecture by Andrew Alexeev of nginx, Inc:'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: nginx公司Andrew Alexeev关于nginx代码架构的编辑文章：
- en: '[http://www.aosabook.org/en/nginx.html](http://www.aosabook.org/en/nginx.html)'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://www.aosabook.org/en/nginx.html](http://www.aosabook.org/en/nginx.html)'
- en: A somewhat outdated, but still relevant guide to nginx module development
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个稍微过时，但仍然相关的nginx模块开发指南
- en: '[http://www.evanmiller.org/nginx-modules-guide.html](http://www.evanmiller.org/nginx-modules-guide.html)'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://www.evanmiller.org/nginx-modules-guide.html](http://www.evanmiller.org/nginx-modules-guide.html)'
- en: A somewhat outdated, but still relevant guide to advanced nginx module development
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个稍微过时，但仍然相关的高级nginx模块开发指南
- en: '[http://www.evanmiller.org/nginx-modules-guide-advanced.html](http://www.evanmiller.org/nginx-modules-guide-advanced.html)'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://www.evanmiller.org/nginx-modules-guide-advanced.html](http://www.evanmiller.org/nginx-modules-guide-advanced.html)'
- en: 'As a community supporter, I blog about nginx at:'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为社区支持者，我在博客中分享关于nginx的内容：
- en: '[http://blog.martinfjordvald.com/category/nginx/](http://blog.martinfjordvald.com/category/nginx/)'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://blog.martinfjordvald.com/category/nginx/](http://blog.martinfjordvald.com/category/nginx/)'
- en: Twitter
  id: totrans-407
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Twitter
- en: 'The official nginx Twitter account:'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方nginx Twitter账号：
- en: '[https://twitter.com/nginxorg](https://twitter.com/nginxorg)'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://twitter.com/nginxorg](https://twitter.com/nginxorg)'
- en: 'Core developer of nginx; tends to be active in support channels:'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: nginx的核心开发者；倾向于活跃在支持渠道中：
- en: '[https://twitter.com/mdounin](https://twitter.com/mdounin)'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://twitter.com/mdounin](https://twitter.com/mdounin)'
- en: 'My Twitter account is:'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我的Twitter账号是：
- en: '[https://twitter.com/mfjordvald](https://twitter.com/mfjordvald)'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://twitter.com/mfjordvald](https://twitter.com/mfjordvald)'
- en: 'A Twitter search for nginx sometimes reveals some interesting articles:'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时在Twitter上搜索nginx会发现一些有趣的文章：
- en: '[https://twitter.com/search?q=nginx](https://twitter.com/search?q=nginx)'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://twitter.com/search?q=nginx](https://twitter.com/search?q=nginx)'
