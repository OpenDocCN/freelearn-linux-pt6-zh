- en: Chapter 4. NGINX as a Reverse Proxy
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 章 NGINX 作为反向代理
- en: A **reverse proxy** is a web server that terminates connections with clients
    and makes new ones to upstream servers on their behalf. An **upstream server**
    is defined as a server that NGINX makes a connection with in order to fulfill
    the client's request. These upstream servers can take various forms, and NGINX
    can be configured differently to handle each of them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**反向代理**是一个 web 服务器，它与客户端建立连接并代表客户端向上游服务器发起新的连接。**上游服务器**被定义为 NGINX 为了满足客户端请求而与之建立连接的服务器。上游服务器可以采取各种形式，NGINX
    可以根据不同的上游服务器配置进行不同的处理。'
- en: NGINX configuration, which you have been learning about in detail, can be difficult
    to understand at times. There are different directives that may be used to fulfill
    similar configuration needs. Some of these options should not really be used,
    as they can lead to unexpected results.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: NGINX 配置，您已经详细学习过，某些时候可能比较难理解。有不同的指令可以用来满足类似的配置需求。某些选项最好不要使用，因为它们可能导致意想不到的结果。
- en: At times, an upstream server may not be able to fulfill a request. NGINX has
    the capability to deliver an error message to the client, either directly from
    this upstream server, from its local disk, or as a redirect to a page on a completely
    different server.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，上游服务器可能无法满足请求。NGINX 有能力向客户端传递错误消息，错误消息可以直接来自该上游服务器，也可以来自其本地磁盘，或重定向到另一个完全不同的服务器上的页面。
- en: Due to the nature of a reverse proxy, the upstream server doesn't obtain information
    directly from the client. Some of this information, such as the client's real
    IP address, is important for debugging purposes, as well as tracking requests.
    This information may be passed to the upstream server in the form of headers.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 由于反向代理的特性，上游服务器无法直接从客户端获取信息。某些信息，例如客户端的真实 IP 地址，对于调试和请求追踪非常重要。这些信息可能以头部的形式传递给上游服务器。
- en: 'We will cover these topics, as well as an overview of some proxy module directives,
    in the following sections:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下章节中介绍这些主题，以及一些代理模块指令的概述：
- en: Introduction to reverse proxying
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反向代理简介
- en: Types of upstream servers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上游服务器的类型
- en: Converting an "if"-fy configuration to a more modern interpretation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 "if"-fy 配置转换为更现代的解释方式
- en: Using error documents to handle upstream problems
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用错误文档处理上游问题
- en: Determining the client's real IP address
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定客户端的真实 IP 地址
- en: Introduction to reverse proxying
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反向代理简介
- en: NGINX can serve as a reverse proxy by terminating requests from clients and
    opening new ones to its upstream servers. On the way, the request can be split
    up according to its URI, client parameters, or some other logic, in order to best
    respond to the request from the client. Any part of the request's original URL
    can be transformed on its way through the reverse proxy.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: NGINX 可以作为反向代理，通过终止来自客户端的请求并向上游服务器发起新的请求。在传递过程中，按照 URI、客户端参数或其他逻辑，可以将请求拆分，以最佳方式响应客户端的请求。请求原始
    URL 的任何部分都可以在通过反向代理时进行转换。
- en: 'The most important directive when proxying to an upstream server is the `proxy_pass`
    directive. This directive takes one parameter—the URL to which the request should
    be transferred. Using `proxy_pass` with a URI part will replace the `request_uri`
    with this part. For example, `/uri` in the following example will be transformed
    to `/newuri` when the request is passed on to the upstream:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在代理到上游服务器时，最重要的指令是 `proxy_pass` 指令。此指令接受一个参数——请求应传输到的 URL。使用 `proxy_pass` 和
    URI 部分时，将用该部分替换 `request_uri`。例如，以下示例中的 `/uri` 在请求传递给上游服务器时将被转换为 `/newuri`：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'There are two exceptions to this rule, however. First, if the location is defined
    with a regular expression, no transformation of the URI occurs. In this example,
    the URI `/local` will be passed directly to the upstream, and not be transformed
    to `/foreign` as intended:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个规则有两个例外。首先，如果位置是通过正则表达式定义的，则 URI 不会发生转换。在这个示例中，URI `/local` 将直接传递给上游服务器，而不会像预期的那样转换为
    `/foreign`：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The second exception is that if within the location a rewrite rule changes
    the URI, and then NGINX uses this URI to process the request, no transformation
    occurs. In this example, the URI passed to the upstream will be `/index.php?page=<match>`,
    with `<match>` being whatever was captured in the parentheses, and not `/index`,
    as indicated by the URI part of the `proxy_pass` directive:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个例外是，如果在某个位置的重写规则更改了 URI，然后 NGINX 使用此 URI 来处理请求，则不会发生任何转换。在此示例中，传递给上游的 URI
    将是 `/index.php?page=<match>`，其中 `<match>` 是括号内捕获的内容，而不是 `/index`，如 `proxy_pass`
    指令中的 URI 部分所示：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Tip
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `break` flag to the rewrite directive is used here to immediately stop all
    processing of rewrite module directives.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`break` 标志用于重写指令中，用来立即停止所有重写模块指令的处理。'
- en: 'In both of these cases, the URI part of the `proxy_pass` directive is not relevant,
    so the configuration would be complete without it:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，`proxy_pass` 指令中的 URI 部分并不相关，因此可以在没有它的情况下完成配置：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The proxy module
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代理模块
- en: 'The following table summarizes some of the commonly used directives in the
    proxy module:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格总结了代理模块中一些常用的指令：
- en: 'Table: Proxy module directives'
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表格：代理模块指令
- en: '| Directive | Explanation |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | 说明 |'
- en: '| --- | --- |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `proxy_connect_timeout` | The maximum amount of time NGINX will wait for
    its connection to be accepted when making a request to an upstream server. |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `proxy_connect_timeout` | NGINX 在向上游服务器发起请求时，等待连接被接受的最大时间。 |'
- en: '| `proxy_cookie_domain` | Replaces the domain attribute of the `Set-Cookie`
    header from the upstream server; the domain to be replaced can either be a string
    or a regular expression, or reference a variable. |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `proxy_cookie_domain` | 替换来自上游服务器的 `Set-Cookie` 头部中的域名属性；要替换的域名可以是字符串、正则表达式，或者引用一个变量。
    |'
- en: '| `proxy_cookie_path` | Replaces the `path` attribute of the `Set-Cookie` header
    from the upstream server; the path to be replaced can either be a string or a
    regular expression, or reference a variable. |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `proxy_cookie_path` | 替换来自上游服务器的 `Set-Cookie` 头部中的 `path` 属性；要替换的路径可以是字符串、正则表达式，或者引用一个变量。
    |'
- en: '| `proxy_headers_hash_bucket_size` | The maximum size of header names. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `proxy_headers_hash_bucket_size` | 头部名称的最大大小。 |'
- en: '| `proxy_headers_hash_max_size` | The total size of headers received from the
    upstream server. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `proxy_headers_hash_max_size` | 从上游服务器接收到的头部的总大小。 |'
- en: '| `proxy_hide_header` | A list of header fields that should not be passed on
    to the client. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `proxy_hide_header` | 一个头部字段的列表，这些字段不应传递给客户端。 |'
- en: '| `proxy_http_version` | The HTTP protocol version used to communicate with
    upstream servers (use `1.1` for `keepalive` connections). |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `proxy_http_version` | 用于与上游服务器通信的 HTTP 协议版本（对于 `keepalive` 连接，使用 `1.1`）。
    |'
- en: '| `proxy_ignore_client_abort` | If set to `on`, NGINX will not abort the connection
    to an upstream server if the client aborts the connection. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `proxy_ignore_client_abort` | 如果设置为 `on`，当客户端中止连接时，NGINX 将不会中止与上游服务器的连接。
    |'
- en: '| `proxy_ignore_headers` | Sets which headers can be disregarded when processing
    the response from the upstream server. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `proxy_ignore_headers` | 设置在处理来自上游服务器的响应时，可以忽略哪些头部。 |'
- en: '| `proxy_intercept_errors` | If enabled, NGINX will display a configured `error_page`
    error instead of the response directly from the upstream server. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `proxy_intercept_errors` | 如果启用，NGINX 将显示配置的 `error_page` 错误，而不是直接显示来自上游服务器的响应。
    |'
- en: '| `proxy_max_temp_file_size` | The maximum size of the overflow file, written
    when the response doesn''t fit into memory buffers. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `proxy_max_temp_file_size` | 当响应无法适应内存缓冲区时，溢出文件的最大大小。 |'
- en: '| `proxy_pass` | Specifies the upstream server to which the request is passed,
    in the form of a URL. |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `proxy_pass` | 指定请求传递给的上游服务器，采用 URL 形式。 |'
- en: '| `proxy_pass_header` | Overrides the disabled headers set in `proxy_hide_header`,
    allowing them to be sent to the client. |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `proxy_pass_header` | 覆盖在 `proxy_hide_header` 中禁用的头部，使其能够发送到客户端。 |'
- en: '| `proxy_pass_request_body` | Prevents sending the body of the request to the
    upstream server if set to `off`. |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `proxy_pass_request_body` | 如果设置为 `off`，则阻止将请求的正文发送到上游服务器。 |'
- en: '| `proxy_pass_request_headers` | Prevents sending the headers of the request
    to the upstream server if set to `off`. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `proxy_pass_request_headers` | 如果设置为 `off`，则阻止将请求的头部发送到上游服务器。 |'
- en: '| `proxy_read_timeout` | Specifies the length of time that needs to elapse
    between two successive read operations from an upstream server, before the connection
    is closed. Should be set to a higher value if the upstream server processes requests
    slowly. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `proxy_read_timeout` | 指定从上游服务器执行两次读取操作之间需要经过的时间长度，在此时间之后连接将被关闭。如果上游服务器处理请求较慢，应设置较高的值。
    |'
- en: '| `proxy_redirect` | Rewrites the `Location` and `Refresh` headers received
    from the upstream servers; useful for working around assumptions made by an application
    framework. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `proxy_redirect` | 重写从上游服务器接收到的 `Location` 和 `Refresh` 头；有助于绕过应用框架的假设。 |'
- en: '| `proxy_send_timeout` | The length of time that needs to elapse between two
    successive write operations to an upstream server, before the connection is closed.
    |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `proxy_send_timeout` | 指定在执行两次写操作到上游服务器之间需要经过的时间长度，在此时间之后连接将被关闭。 |'
- en: '| `proxy_set_body` | The body of a request sent to an upstream server may be
    altered by setting this directive. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `proxy_set_body` | 可以通过设置该指令来更改发送到上游服务器的请求体。 |'
- en: '| `proxy_set_header` | Rewrites the contents of headers sent to an upstream
    server; may also be used to not send certain headers by setting its value to the
    empty string. |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `proxy_set_header` | 重写发送到上游服务器的头内容；也可以通过将其值设置为空字符串来不发送某些头。 |'
- en: '| `proxy_temp_file_write_size` | Limits the amount of data buffered to a temporary
    file at one time, so that NGINX will not block too long on a single request. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `proxy_temp_file_write_size` | 限制一次缓冲到临时文件的数据量，以防止 NGINX 在单个请求上阻塞过久。 |'
- en: '| `proxy_temp_path` | A directory where temporary files may be buffered as
    they are proxied from the upstream server, optionally multi-level deep. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `proxy_temp_path` | 一个目录，用于缓存临时文件，这些文件在从上游服务器代理时可能会被存储，可以选择性地多层嵌套。 |'
- en: The following listing brings many of these directives together in a file that
    can be included in the configuration within the same location as the `proxy_pass`
    directive.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表将许多这些指令组合在一起，并可在与 `proxy_pass` 指令位于同一位置的配置文件中包含。
- en: 'Contents of `proxy.conf`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`proxy.conf` 的内容：'
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We are setting a number of common directives to values that we think would
    be useful for reverse-proxying scenarios:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在设置一些常见的指令值，这些值在反向代理场景中可能会很有用：
- en: The `proxy_redirect` directive has been set to `off` because there is no need
    to rewrite the `Location` header in most situations.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`proxy_redirect` 指令已设置为 `off`，因为在大多数情况下没有必要重写 `Location` 头。'
- en: The `Host` header is set so the upstream server can map the request to a virtual
    server or otherwise make use of the host portion of the URL the user entered.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Host` 头被设置，以便上游服务器可以将请求映射到虚拟服务器，或者利用用户输入的 URL 中的主机部分。'
- en: The `X-Real-IP` and `X-Forwarded-For` headers serve similar purposes—to relay
    the information about the connecting client's IP address to the upstream server.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`X-Real-IP` 和 `X-Forwarded-For` 头具有相似的功能——将连接客户端的 IP 地址信息转发给上游服务器。'
- en: The `$remote_addr` variable used in the `X-Real-IP` header is the IP address
    of the client as NGINX perceives it.
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于 `X-Real-IP` 头中的 `$remote_addr` 变量是 NGINX 感知到的客户端 IP 地址。
- en: The `$proxy_add_x_forwarded_for` variable contains the contents of the `X-Forwarded-For`
    header field from the client's request, followed by the `$remote_addr` variable.
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$proxy_add_x_forwarded_for` 变量包含客户端请求中的 `X-Forwarded-For` 头字段的内容，后接 `$remote_addr`
    变量。'
- en: The `client_max_body_size` directive, while not strictly a proxy module directive,
    is mentioned here because of its relevance to proxy configurations. If this value
    is set too low, uploaded files will not make it to the upstream server. When setting
    this directive, keep in mind that files uploaded via a web form will usually have
    a larger file size than that shown in the filesystem.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`client_max_body_size` 指令，虽然严格来说不是反向代理模块的指令，但由于与代理配置的相关性，这里提到它。如果该值设置得太低，上传的文件将无法到达上游服务器。在设置此指令时，请记住，通过
    Web 表单上传的文件通常比文件系统中的文件大小更大。'
- en: The `proxy_connect_timeout` directive indicates how long NGINX will wait when
    establishing initial contact with the upstream server.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`proxy_connect_timeout` 指令表示 NGINX 在与上游服务器建立初始连接时的等待时间。'
- en: The `proxy_read_timeout` and `proxy_send_timeout` directives define how long
    NGINX will wait between successive operations with the upstream server.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`proxy_read_timeout` 和 `proxy_send_timeout` 指令定义了 NGINX 在与上游服务器的连续操作之间等待的时间。'
- en: The `proxy_send_lowat` directive is only effective on FreeBSD systems and specifies
    the number of bytes the socket send buffer should hold before passing the data
    on to the protocol.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`proxy_send_lowat` 指令仅在FreeBSD系统上有效，并指定套接字发送缓冲区在将数据传递给协议之前应持有的字节数。'
- en: The `proxy_buffer_size`, `proxy_buffers`, and `proxy_busy_buffers_size` directives
    will be discussed in detail in the next chapter. Suffice it to say that these
    buffers control how quickly NGINX appears to respond to user requests.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`proxy_buffer_size`、`proxy_buffers` 和 `proxy_busy_buffers_size` 指令将在下一章详细讨论。简单来说，这些缓冲区控制NGINX对用户请求的响应速度。'
- en: 'The `proxy_temp_file_write_size` directive controls how long a worker process
    blocks while spooling data: the higher the value, the longer the process blocks.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`proxy_temp_file_write_size` 指令控制工作进程在缓存数据时阻塞的时间：值越高，进程阻塞的时间越长。'
- en: 'These directives are included in a file as follows, and may be used multiple
    times in the same configuration:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令包含在一个文件中，如下所示，并且可以在同一配置中多次使用：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If one of these directives should have a different value than what's in the
    include file, then override it in that particular location.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些指令中的任何一个值与包含文件中的值不同，则在特定位置覆盖它。
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Tip
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The order is important here. If there is more than one occurrence of a directive
    in a configuration file (or include), NGINX will take the value of the directive
    defined last.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的顺序很重要。如果配置文件（或包含的文件）中出现多个指令，NGINX将采用最后定义的指令值。
- en: Legacy servers with cookies
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 带有cookie的旧版服务器
- en: 'You may find yourself in a situation where you will need to place multiple
    legacy applications behind one common endpoint. The legacy applications were written
    for a case where they were the only servers talking directly with the client.
    They set cookies from their own domain, and assumed that they would always be
    reachable via the `/` URI. In placing a new endpoint in front of these servers,
    these assumptions no longer hold true. The following configuration will rewrite
    the cookie domain and path to match that of the new application endpoint:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会遇到需要将多个旧版应用程序放置在同一个公共端点后面的情况。这些旧版应用程序是为它们作为唯一与客户端直接通信的服务器而编写的。它们从自己的域设置了cookie，并假设它们总是可以通过`/`
    URI访问。在将新端点放置在这些服务器前面时，这些假设不再成立。以下配置将重写cookie的域和路径，以匹配新应用程序端点：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Tip
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The value of the `$uri` variable already includes the beginning slash (`/`),
    so it is not necessary to duplicate it here.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`$uri` 变量的值已经包括了开头的斜杠（`/`），因此这里无需重复它。'
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The upstream module
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上游模块
- en: Closely paired with the `proxy` module is the `upstream` module. The `upstream`
    directive starts a new context, in which a group of upstream servers is defined.
    These servers may be given different weights (the higher the weight, the greater
    the number of connections NGINX will pass to that particular upstream server),
    may be of different types (TCP versus UNIX domain), and may even be marked as
    `down` for maintenance reasons.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 与`proxy`模块紧密配合的是`upstream`模块。`upstream`指令启动一个新的上下文，在其中定义了一组上游服务器。这些服务器可以赋予不同的权重（权重越高，NGINX将传递给该上游服务器的连接越多），可以是不同类型（TCP与UNIX域），甚至可以因维护原因标记为`down`。
- en: 'The following table summarizes the directives valid within the upstream context:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格总结了在上游上下文中有效的指令：
- en: 'Table: Upstream module directives'
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表格：上游模块指令
- en: '| Directive | Explanation |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | 解释 |'
- en: '| --- | --- |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `ip_hash` | Ensures the distribution of connecting clients evenly over all
    servers by hashing the IP address, keying on its class-C network. |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `ip_hash` | 通过对IP地址进行哈希并基于其类C网络进行键控，确保客户端连接均匀分布在所有服务器上。 |'
- en: '| `keepalive` | The number of connections to upstream servers that are cached
    per worker process. When used with HTTP connections, `proxy_http_version` should
    be set to `1.1` and `proxy_set_header` to `Connection "".` |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `keepalive` | 每个工作进程缓存到上游服务器的连接数。与HTTP连接一起使用时，应将`proxy_http_version`设置为`1.1`，并将`proxy_set_header`设置为`Connection
    "".` |'
- en: '| `least_conn` | Activates the load-balancing algorithm where the server with
    the least number of active connections is chosen for the next new connection.
    |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `least_conn` | 启动负载均衡算法，其中选择活动连接数最少的服务器来处理下一个新连接。 |'
- en: '| `server` | Defines an address (domain name or IP address with an optional
    TCP port, or path to a UNIX-domain socket) and optional parameters for an upstream
    server. The parameters are:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '| `server` | 定义一个地址（域名或带可选 TCP 端口的 IP 地址，或 UNIX 域套接字的路径）和上游服务器的可选参数。参数包括：'
- en: '`weight`: It sets the preference for one server over another'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`weight`：它设置了一个服务器相对于另一个服务器的优先级'
- en: '`max_fails`: It is the maximum number of unsuccessful communication attempts
    to a server within `fail_timeout` before the server is marked as `down`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max_fails`：它是指在 `fail_timeout` 内，服务器未成功通信的最大尝试次数，超过此次数后，服务器将被标记为 `down`'
- en: '`fail_timeout`: It is the length of time a server has to respond to a request
    and the length of time a server will be marked as down'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fail_timeout`：它是指服务器必须响应请求的时间长度，以及服务器被标记为宕机的时间长度'
- en: '`backup`: It will only receive requests once the other servers are down'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`backup`：只有在其他服务器不可用时，它才会接收请求'
- en: '`down`: It marks a server as not able to process requests'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`down`：它标记服务器无法处理请求'
- en: '|'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Keepalive connections
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保持连接
- en: The `keepalive` directive deserves special mention. NGINX will keep this number
    of connections per worker open to an upstream server. This connection cache is
    useful in situations where NGINX has to constantly maintain a certain number of
    open connections to an upstream server. If the upstream server speaks HTTP, NGINX
    can use the HTTP/1.1 Persistent Connections mechanism for maintaining these open
    connections.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`keepalive` 指令值得特别提及。NGINX 会为每个工作进程保持一定数量的与上游服务器的连接。这种连接缓存对于需要始终保持一定数量打开连接的情况非常有用。如果上游服务器使用
    HTTP，NGINX 可以使用 HTTP/1.1 持久连接机制来维持这些连接。'
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we've indicated that we'd like to hold open 32 connections to Apache running
    on port `8080` of the localhost. NGINX need only negotiate the TCP handshake for
    the initial 32 connections per worker, and will then keep these connections open
    by not sending a Connection header with the `close` token. With `proxy_http_version`,
    we specify that we'd like to speak HTTP/1.1 with the upstream server. We also
    clear the contents of the `Connection` header with `proxy_set_header`, so that
    we are not proxying the client connection properties directly.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经指示希望保持 32 个与运行在本地主机 `8080` 端口上的 Apache 的连接。NGINX 只需为每个工作进程的前 32 个连接完成
    TCP 握手，然后通过不发送带有 `close` 标记的 Connection 头来保持这些连接的开放。通过 `proxy_http_version`，我们指定希望与上游服务器使用
    HTTP/1.1 进行通信。我们还通过 `proxy_set_header` 清除了 `Connection` 头的内容，以避免直接代理客户端连接属性。
- en: If more than 32 connections are needed, NGINX will, of course, open them to
    satisfy requests. After this peak has passed, NGINX will close the least recently
    used connections, to bring the number back down to 32, as we indicated in the
    `keepalive` directive.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要超过 32 个连接，NGINX 当然会打开足够的连接以满足请求。在这个高峰期过后，NGINX 将关闭最久未使用的连接，将连接数降回到 32，这正是我们在
    `keepalive` 指令中所指定的。
- en: 'This mechanism can also be used to proxy non-HTTP connections, as well. In
    the following example, we show that NGINX maintains 64 connections to two instances
    of `memcached`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 此机制也可以用于代理非 HTTP 连接。以下示例中，我们展示了 NGINX 如何保持与两个 `memcached` 实例的 64 个连接：
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If we were to switch load-balancing algorithms from the default round-robin
    to either `ip_hash` or `least_conn`, we would need to specify this before using
    the `keepalive` directive:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将负载均衡算法从默认的轮询算法切换到 `ip_hash` 或 `least_conn`，我们需要在使用 `keepalive` 指令之前指定这一点：
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Load-balancing algorithms
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 负载均衡算法
- en: The `upstream` module can select which upstream server to connect to in the
    next step by using one of three load-balancing algorithms—round-robin, IP hash,
    or least connections. The **round-robin** algorithm is selected by default, and
    doesn't need a configuration directive to activate it. This algorithm selects
    the next server, based on which server was selected previously, which server is
    next in the configuration block, and what weight each server carries. The round-robin
    algorithm tries to ensure a fair distribution of traffic, based on a concept of
    who's turn it is next.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`upstream` 模块可以通过使用三种负载均衡算法之一——轮询、IP 哈希或最少连接——来选择下一个连接的上游服务器。**轮询**算法是默认选择的，无需配置指令来启用它。此算法基于上一个选择的服务器、配置块中下一个服务器以及每个服务器的权重来选择下一个服务器。轮询算法尝试确保流量的公平分配，基于“轮到谁了”的概念。'
- en: The **IP hash** algorithm, activated by the `ip_hash` directive, instead takes
    the view that certain IP addresses should always be mapped to the same upstream
    server. NGINX does this by using the first three octets of an IPv4 address or
    the entire IPv6 address, as a hashing key. The same pool of IP addresses are therefore
    always mapped to the same upstream server. So, this mechanism isn't designed to
    ensure a fair distribution, but rather a consistent mapping between the client
    and upstream server.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**IP哈希**算法，通过`ip_hash`指令启用，采取的是将特定IP地址始终映射到同一上游服务器的观点。NGINX通过使用IPv4地址的前三个八位字节或整个IPv6地址作为哈希键来实现这一点。因此，相同的IP地址池始终会映射到相同的上游服务器。因此，这一机制并不是为了确保公平分配，而是为了在客户端和上游服务器之间实现一致的映射。'
- en: The third load-balancing algorithm supported by the default upstream module**,
    least connections** , is activated by the `least_conn` directive. This algorithm
    is designed to distribute the load evenly among upstream servers, by selecting
    the one with the fewest number of active connections. If the upstream servers
    do not all have the same processing power, this can be indicated using the `weight`
    parameter to the `server` directive. The algorithm will take into account the
    differently-weighted servers when calculating the number of least connections.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 默认上游模块支持的第三种负载均衡算法**最少连接数**，通过`least_conn`指令启用。该算法旨在通过选择具有最少活动连接数的上游服务器，均匀分配负载。如果上游服务器的处理能力不完全相同，可以使用`weight`参数在`server`指令中指定。该算法在计算最少连接数时会考虑到不同权重的服务器。
- en: Types of upstream servers
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上游服务器类型
- en: An upstream server is a server to which NGINX proxies a connection. This can
    be on a different physical or virtual machine, but doesn't have to be. The upstream
    server may be a daemon listening on a UNIX domain socket for connections on the
    local machine or could be one of many on a different machine listening over TCP.
    It may be an Apache server, with multiple modules to handle different kinds of
    requests, or a Rack middleware server, providing an HTTP interface to Ruby applications.
    NGINX can be configured to proxy to each of them.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 上游服务器是NGINX代理连接的服务器。这可以是不同的物理机或虚拟机，但不一定是。上游服务器可以是一个守护进程，在本地机器上的UNIX域套接字上监听连接，也可以是不同机器上的多个服务器，通过TCP监听。它可以是一个Apache服务器，带有多个模块来处理不同类型的请求，或者是一个Rack中间件服务器，为Ruby应用程序提供HTTP接口。NGINX可以配置为代理到它们中的每一个。
- en: Single upstream server
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单一上游服务器
- en: 'The Apache web server is used in common hosting scenarios to serve static files
    as well as multiple types of interpreted files. The extensive documentation and
    how-to''s (found online) help users to get up-and-running quickly with their favorite
    CMS. Unfortunately, the typical Apache configuration, due to resource limits,
    is not able to handle many simultaneous requests. NGINX, though, is designed to
    handle this kind of traffic and performs very well with little resource consumption.
    Since most CMSs come pre-configured for Apache, integrating the use of `.htaccess`
    files for extended configuration, the easiest way to take advantage of NGINX''s
    strengths is for NGINX to simply proxy connections to an Apache instance:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Web服务器在常见的托管场景中用于提供静态文件以及多种类型的解释文件。广泛的文档和在线教程帮助用户快速启动并运行自己喜欢的CMS。不幸的是，由于资源限制，典型的Apache配置无法处理大量的并发请求。然而，NGINX被设计用于处理这种流量，且资源消耗极低。由于大多数CMS预配置为Apache，并通过`.htaccess`文件集成扩展配置，因此利用NGINX优势的最简单方法是让NGINX直接将连接代理到Apache实例：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is the most basic proxy configuration possible. NGINX will terminate all
    client connections, and then proxy all requests to the local host on TCP port
    8080\. We assume here that Apache has been configured to listen on `localhost:8080`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最基本的代理配置。NGINX将终止所有客户端连接，然后将所有请求代理到本地主机的TCP端口8080。我们假设Apache已经配置为在`localhost:8080`上监听。
- en: 'A configuration such as this is typically extended so that NGINX will serve
    any static files directly, and then proxy the remaining requests to Apache:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样的配置通常会扩展，使得NGINX能够直接提供任何静态文件，然后将剩余的请求代理到Apache：
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `try_files` directive (included in the `http` core module) does just what
    its name implies—it tries files, in order, until it finds a match. So, in the
    preceding example, NGINX will deliver any files it finds in its root that match
    the URI given by the client. If it doesn't find any files, it will proxy the request
    to Apache for further processing. We use a named location here to proxy the request
    after an unsuccessful try to locate the file locally.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`try_files` 指令（包含在 `http` 核心模块中）正如其名所示——它按顺序尝试文件，直到找到匹配的文件。所以，在前面的示例中，NGINX
    将提供它在根目录中找到的与客户端提供的 URI 匹配的任何文件。如果没有找到任何文件，它将把请求代理到 Apache 进行进一步处理。我们在这里使用了一个命名位置，在本地查找文件失败后将请求代理过去。'
- en: Multiple upstream servers
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多个上游服务器
- en: 'It is also possible to configure NGINX to pass the request to more than one
    upstream server. This is done by declaring an upstream context, defining multiple
    servers, and referencing the upstream in a `proxy_pass` directive:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以配置 NGINX 将请求传递给多个上游服务器。这是通过声明一个上游上下文，定义多个服务器，并在 `proxy_pass` 指令中引用该上游来实现的：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Using this configuration, NGINX will pass consecutive requests in a round-robin
    fashion to the three upstream servers. This is useful when an application can
    handle only one request at a time, and you''d like NGINX to handle the client
    communication so that none of the application servers get overloaded. The configuration
    is illustrated in the following diagram:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此配置，NGINX 会按轮询的方式将连续请求传递给三个上游服务器。当应用程序只能同时处理一个请求时，您希望 NGINX 处理客户端的通信，以避免任何一个应用服务器过载时，这种方法会很有用。此配置在以下图示中说明：
- en: '![Multiple upstream servers](img/7447OS_04_01.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![多个上游服务器](img/7447OS_04_01.jpg)'
- en: Other load-balancing algorithms are available, as detailed in the *Load-balancing
    algorithms* section earlier in this chapter. Which one should be used in a particular
    configuration depends on the situation.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 本章前面 *负载均衡算法* 部分中详细介绍了其他负载均衡算法。应使用哪种算法取决于具体配置和实际情况。
- en: If a client should always get the same upstream server, to effect a poor-man's
    session-stickiness, the `ip_hash` directive should be used. When the distribution
    of requests leads to widely varying response times per request, the `least_conn`
    algorithm should be selected. The default round-robin algorithm is good for a
    general case where no special consideration of either the client or upstream server
    is required.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要确保客户端始终连接到相同的上游服务器，以实现一种简易的会话粘性（poor-man's session-stickiness），则应使用 `ip_hash`
    指令。当请求的分发导致每个请求的响应时间差异较大时，应选择 `least_conn` 算法。默认的轮询算法适用于一般情况，无需特殊考虑客户端或上游服务器。
- en: Non-HTTP upstream servers
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非 HTTP 上游服务器
- en: So far, we've focused on communicating with upstream servers over HTTP. For
    this, we use the `proxy_pass` directive. As hinted at earlier in this chapter,
    in the *Keepalive connections* section, NGINX can proxy requests to a number of
    different kinds of upstream servers. Each has its corresponding *`_pass` directive.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经集中讨论了如何通过 HTTP 与上游服务器进行通信。为此，我们使用 `proxy_pass` 指令。正如本章早些时候在 *保持连接*
    部分所提到的，NGINX 可以将请求代理到不同类型的上游服务器。每种类型都有相应的 *`_pass` 指令。
- en: Memcached upstream servers
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Memcached 上游服务器
- en: 'The `memcached` NGINX module (enabled by default) is responsible for communicating
    with a `memcached` daemon. As such, there is no direct communication between the
    client and the `memcached` daemon; that is, NGINX does not act as a reverse-proxy
    in this sense. The `memcached` module enables NGINX to speak the `memcached` protocol,
    so that a key lookup can be done before a request is passed to an application
    server:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`memcached` NGINX 模块（默认启用）负责与 `memcached` 守护进程进行通信。因此，客户端与 `memcached` 守护进程之间没有直接通信；也就是说，NGINX
    在此意义上并不充当反向代理。`memcached` 模块使 NGINX 能够使用 `memcached` 协议，从而在将请求传递到应用服务器之前进行键查找：'
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `memcached_pass` directive uses the `$memcached_key` variable to make the
    key lookup. If there is no corresponding value (`error_page 404`), we pass the
    request on to `localhost`, where there is presumably a server running that will
    handle this request and insert a key/value pair into the `memcached` instance.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`memcached_pass` 指令使用 `$memcached_key` 变量进行键查找。如果没有对应的值（`error_page 404`），我们将请求传递给
    `localhost`，假设该处有一个正在运行的服务器，能够处理此请求并将键/值对插入到 `memcached` 实例中。'
- en: FastCGI upstream servers
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: FastCGI 上游服务器
- en: 'Using a FastCGI server is a popular way to run PHP applications behind an NGINX
    server. The `fastcgi` module is compiled in by default, and is activated with
    the `fastcgi_pass` directive. This enables NGINX to speak the FastCGI protocol
    with one or more upstream servers. We define a set of FastCGI upstream servers
    as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 FastCGI 服务器是一种常见的将 PHP 应用程序运行在 NGINX 服务器背后的方式。`fastcgi` 模块默认编译并可以通过 `fastcgi_pass`
    指令激活。这使得 NGINX 能够与一个或多个上游服务器进行 FastCGI 协议通信。我们定义一组 FastCGI 上游服务器，如下所示：
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'And pass connections to them from the root location:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 并将连接传递给根位置的这些服务器：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is a very minimalist configuration to illustrate the basics of using FastCGI.
    The `fastcgi` module contains a number of directives and configuration possibilities,
    which we will discuss in [Chapter 6](ch06.html "Chapter 6. The NGINX HTTP Server"),
    *The NGINX HTTP Server*.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简约的配置，用于说明使用 FastCGI 的基本知识。`fastcgi` 模块包含许多指令和配置选项，我们将在[第 6 章](ch06.html
    "第 6 章. NGINX HTTP 服务器")中讨论这些内容，*NGINX HTTP 服务器*。
- en: SCGI upstream servers
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SCGI 上游服务器
- en: NGINX can also speak the SCGI protocol by using its built-in `scgi` module.
    The principle is the same as for the `fastcgi` module. NGINX communicates with
    an upstream server indicated with the `scgi_pass` directive.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: NGINX 还可以通过其内置的 `scgi` 模块支持 SCGI 协议。原理与 `fastcgi` 模块相同。NGINX 通过 `scgi_pass`
    指令与指定的上游服务器通信。
- en: uWSGI upstream servers
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: uWSGI 上游服务器
- en: The `uWSGI` protocol has been very popular with Python developers. NGINX provides
    support for connecting to a Python-based upstream server through its `uwsgi` module.
    The configuration is similar to the `fastcgi` module, using the `uwsgi_pass` directive
    instead to indicate an upstream server. An example configuration will be shown
    in [Chapter 6](ch06.html "Chapter 6. The NGINX HTTP Server"), *The NGINX HTTP
    Server*.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`uWSGI` 协议在 Python 开发者中非常流行。NGINX 提供了通过其 `uwsgi` 模块连接到基于 Python 的上游服务器的支持。配置与
    `fastcgi` 模块类似，使用 `uwsgi_pass` 指令来指示一个上游服务器。一个示例配置将在[第 6 章](ch06.html "第 6 章.
    NGINX HTTP 服务器")中展示，*NGINX HTTP 服务器*。'
- en: Converting an "if"-fy configuration to a more modern interpretation
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将“if”-fy 配置转换为更现代的解释方式
- en: 'Using the `if` directive within a location is really only considered valid
    for certain cases. It may be used in combination with a return and with a rewrite
    with a `last` or `break` flag, but should generally be avoided in other situations.
    This is due in part to the fact that it can produce some very unexpected results.
    Consider the following example:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在位置内使用 `if` 指令仅在某些情况下被认为是有效的。它可以与返回和重写结合使用，并带有 `last` 或 `break` 标志，但在其他情况下应尽量避免使用。这部分是因为它可能会产生一些非常意外的结果。请考虑以下示例：
- en: '[PRE18]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we're trying to determine which upstream to pass the request to, based
    on the value of the `$request_uri` variable. This seems like a very reasonable
    configuration at first glance, because it works for our simple test cases. But
    the images will neither be served from the `/img` filesystem location, the `/static`
    filesystem location, nor from the `@imageserver` named location. `try_files` simply
    doesn't work when an `if` directive is present in the same location. `if` creates
    an implicit location with its own content handler; in this case, the `proxy` module.
    So the outer content handler, where `try_files` is registered, won't ever get
    invoked. There is a way to write this configuration differently to make it do
    what we want.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们试图根据 `$request_uri` 变量的值来确定将请求传递给哪个上游服务器。乍一看，这似乎是一个非常合理的配置，因为它适用于我们的简单测试用例。但实际上，图片既不会从
    `/img` 文件系统位置提供，也不会从 `/static` 文件系统位置提供，或者从 `@imageserver` 命名位置提供。`try_files`
    在同一位置出现 `if` 指令时根本无法工作。`if` 会创建一个隐式的位置，并且有自己的内容处理程序；在此情况下是 `proxy` 模块。因此，外部内容处理程序（即注册了
    `try_files` 的地方）将永远不会被调用。实际上，存在一种不同的写法，使得该配置能够按预期工作。
- en: 'Let''s think about our request as NGINX processes it. After having found a
    matching IP and port, it first selects a virtual host (server) based on the `Host`
    header. Then, it scans all locations under this server, looking for a matching
    URI. So, we see that the better way to configure a selector based on the URI is
    in fact by defining multiple locations, as shown in the following example:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一下 NGINX 如何处理我们的请求。在找到匹配的 IP 和端口后，它首先根据 `Host` 头部选择一个虚拟主机（服务器）。然后，它扫描该服务器下的所有位置，查找匹配的
    URI。因此，我们看到，基于 URI 配置选择器的更好方式实际上是通过定义多个位置，如以下示例所示：
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This configuration can be illustrated by the following diagram:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配置可以通过以下图示来说明：
- en: '![Converting an "if"-fy configuration to a more modern interpretation](img/7447OS_04_02.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![将 "if"-fy 配置转换为更现代的解释](img/7447OS_04_02.jpg)'
- en: 'Another example of an `"if"-fy` configuration is the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个 `"if"-fy` 配置示例如下：
- en: '[PRE20]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we have a number of `if` directives matching the Host header (or, if not
    present, `server_name`). After each `if`, the URI is rewritten to lead directly
    to the correct application component. Besides being terribly inefficient due to
    the processing required to match each regular expression for every URI, it breaks
    our "no ifs within a location" rule.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有多个匹配 Host 头部（如果没有，匹配 `server_name`）的 `if` 指令。在每个 `if` 后，URI 会重写为直接指向正确的应用组件。除了因为每个
    URI 都需要匹配正则表达式而导致效率极低之外，这还违反了我们的“位置内不使用 if”规则。
- en: 'This type of configuration is better rewritten as a series of separate server
    contexts, in which the URL is rewritten to the application component:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这种配置更适合重写为一系列独立的服务器上下文，在这些上下文中，URL 会重写为应用组件：
- en: '[PRE21]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In each block, we have placed only those `server_name` that are relevant to
    the respective rewrite, so that no `if` is needed. In each `rewrite` rule, we
    have replaced the `redirect` flag with the `permanent` flag to indicate that this
    is a full URL that the browser should remember and automatically use the next
    time the domain is requested. In the last rewrite rule, we have also replaced
    the match (`^/(.*)$`) with a readily-available variable, `$request_uri`, which
    contains the same information but saves the trouble of matching the regular expression
    and saving the capture variable.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个块中，我们只放置了与各自重写相关的 `server_name`，因此不需要使用 `if`。在每条 `rewrite` 规则中，我们将 `redirect`
    标志替换为 `permanent` 标志，表示这是一个完整的 URL，浏览器应记住并在下次请求该域名时自动使用。在最后一条重写规则中，我们还将匹配（`^/(.*)$`）替换为现成的变量
    `$request_uri`，该变量包含相同的信息，但省去了匹配正则表达式和保存捕获变量的麻烦。
- en: Using error documents to handle upstream problems
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用错误文档处理上游问题
- en: 'There are situations in which the upstream server cannot respond to a request.
    In these cases, NGINX can be configured to supply a document from its local disk:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，上游服务器无法响应请求。在这些情况下，NGINX 可以配置为从本地磁盘提供文档：
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Or from an external site:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 或者来自外部站点：
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When proxying to a set of upstream servers, you may want to define an extra
    upstream as being a "fallback" server, to handle requests when the others cannot.
    This is useful in scenarios when the fallback server is able to deliver a customized
    response based on the requested URI:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当代理到一组上游服务器时，您可能希望定义一个额外的上游作为“后备”服务器，以在其他服务器无法处理请求时进行处理。当后备服务器能够根据请求的 URI 提供定制的响应时，这在某些场景中非常有用：
- en: '[PRE24]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Tip
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The "`=`" notation shown in the preceding `error_page` line is used to indicate
    that we want to return the status code resulting from the last parameter; in this
    case, the `@fallback` location.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 `error_page` 行中显示的 "`=`" 符号用于表示我们希望返回由最后一个参数生成的状态码；在这种情况下是 `@fallback`
    位置。
- en: 'These examples cover cases in which the error code was 500 or greater. NGINX
    can also supply an `error_page` for error codes 400 or greater, when the `proxy_intercept_errors`
    directive is set to `on`, as in the following example:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例涵盖了错误码为 500 或更高的情况。当 `proxy_intercept_errors` 指令设置为 `on` 时，NGINX 还可以为错误码
    400 或更高的错误提供 `error_page`，如下例所示：
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When HTTP error code 401 is configured to be served from an `error_page`, the
    authentication will not complete. You may want to do this in situations when the
    authentication backend is offline, for maintenance or other reasons, but you should
    otherwise avoid them.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当 HTTP 错误码 401 被配置为从 `error_page` 提供时，身份验证将不会完成。您可能希望在身份验证后端离线时（例如，进行维护或其他原因）这样做，但通常应避免这种做法。
- en: Determining the client's real IP address
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定客户端的真实 IP 地址
- en: 'When using a proxy server, the clients don''t have a direct connection to the
    upstream servers. The upstream servers, therefore, aren''t able to get information
    directly from those clients. Any information, such as the client''s IP address,
    would need to be passed via headers. NGINX provides this with the `proxy_set_header`
    directive:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用代理服务器时，客户端与上游服务器没有直接连接。因此，上游服务器无法直接从这些客户端获取信息。任何信息，如客户端的 IP 地址，都需要通过头部传递。NGINX
    使用 `proxy_set_header` 指令提供这一功能：
- en: '[PRE26]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The client's IP address will then be available in both the `X-Real-IP` and `X-Forwarded-For`
    headers. The second form takes a client request header into account. If present,
    the IP address of the request will be added to the `X-Forwarded-For` header from
    the client, separated by a comma. Depending on your upstream server configuration,
    you will need one or the other of these. Configuring Apache, for example, to use
    the `X-Forwarded-For` header for the client's IP address in its logs is done using
    the `%{<header-name>}i` formatting option.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端的IP地址将同时出现在`X-Real-IP`和`X-Forwarded-For`头部。第二种形式会考虑客户端请求头。如果存在，它将把请求的IP地址添加到客户端的`X-Forwarded-For`头部，地址之间用逗号分隔。根据你的上游服务器配置，你可能需要其中之一。例如，配置Apache以使用`X-Forwarded-For`头部来记录客户端的IP地址，可以通过使用`%{<header-name>}i`格式选项来实现。
- en: 'The following example shows how to change the default ''combined'' Apache log
    format:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何更改默认的“combined”Apache日志格式：
- en: '[PRE27]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If your upstream server, on the other hand, requires a non-standard header
    such as `Client-IP`, then this can easily be configured with the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的上游服务器需要一个非标准的头部，如`Client-IP`，则可以通过以下方式轻松配置：
- en: '[PRE28]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Other information, such as the `Host` header, can be passed to the upstream
    servers in the same manner:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 其他信息，例如`Host`头部，也可以以相同的方式传递给上游服务器：
- en: '[PRE29]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Summary
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have seen how NGINX can be used as a reverse proxy. Its efficient connection-handling
    model is ideal for interfacing directly with clients. After having terminated
    requests, NGINX can then open new ones to upstream servers, taking into account
    the strengths and weaknesses of each upstream server. Using `if` inside a location
    is only considered valid under certain situations. By thinking about how NGINX
    actually handles a request, we can develop a configuration that is more suited
    to what we want to achieve. If NGINX cannot reach an upstream server for any reason,
    it can serve another page instead. As NGINX terminates the clients' requests,
    the upstream servers can obtain information about the client only via headers
    passed in NGINX's proxied request. These concepts will help you design an ideal
    NGINX configuration to match your needs.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了NGINX如何作为反向代理使用。它高效的连接处理模型非常适合直接与客户端接口。在处理完请求后，NGINX可以向上游服务器发起新请求，考虑到每个上游服务器的优缺点。在某些情况下，`if`语句在location内是有效的。通过了解NGINX如何实际处理请求，我们可以制定更符合我们需求的配置。如果NGINX因某些原因无法连接到上游服务器，它可以提供另一个页面作为替代。当NGINX终止客户端请求时，上游服务器只能通过NGINX代理请求中传递的头部信息获取客户端信息。这些概念将帮助你设计一个理想的NGINX配置，以满足你的需求。
- en: Coming up in the next chapter, we will explore more advanced reverse-proxy techniques.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨更多高级的反向代理技术。
