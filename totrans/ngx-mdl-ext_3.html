<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Installing and Configuring HTTP Modules"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Installing and Configuring HTTP Modules</h1></div></div></div><p>In this chapter, we will explore the installation and configuration of standard HTTP modules. Standard HTTP modules are built into Nginx by default unless you disable them while running the configure script. The optional HTTP modules are only installed if you specify them explicitly while running <code class="literal">configure</code>. These modules deal with functionalities such as SSL, HTTP authentication, HTTP proxy, gzip compression, and many others. We will look at some optional HTTP modules in the next chapter.</p><p>All the configuration directives we have talked about so far and the ones that we will be discussing in this and the remaining chapters are specified in the <code class="literal">nginx.conf</code> file. The default location of this file is <code class="literal">/usr/local/conf/nginx.conf</code>.</p><div class="section" title="Standard HTTP modules"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec14"/>Standard HTTP modules</h1></div></div></div><p>As mentioned earlier, standard HTTP modules are built into Nginx by default unless you explicitly disable them. As the name suggests, these modules provide standard HTTP functionality to the web server. We will now have a look at some of the important standard HTTP modules.</p><div class="section" title="The core module (HttpCoreModule)"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec18"/>The core module (HttpCoreModule)</h2></div></div></div><p>The core module deals with the core HTTP features. This includes the protocol version, HTTP keepalive, location<a id="id162" class="indexterm"/> (different configurations based on URI), documents' roots, and so on. There are over 74 configuration directives and over 30 environment variables related to the HTTP Core module. We will discuss the most important ones briefly.</p></div><div class="section" title="Explaining directives"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec19"/>Explaining directives</h2></div></div></div><p>The following is <a id="id163" class="indexterm"/>an explanation of some of the key core module directives. This list is not exhaustive, and you can find the full list at <a class="ulink" href="http://wiki.nginx.org/HttpCoreModule">http://wiki.nginx.org/HttpCoreModule</a>.</p><div class="section" title="server"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec35"/>server</h3></div></div></div><p>The <code class="literal">server</code> directive <a id="id164" class="indexterm"/>defines the server context. It is defined as a <code class="literal">server {...}</code> block in the configuration file. <a id="id165" class="indexterm"/>Each <code class="literal">server</code> block refers to a virtual server. You have to specify a <code class="literal">listen</code> directive inside a <code class="literal">server</code> block to define the host IP and the port for this virtual server. Alternatively, you can specify a <code class="literal">server_name</code> directive to define all the hostnames of this virtual server.</p><div class="informalexample"><pre class="programlisting">server {
  server_name www.acme.com *.acme.com www.acme.org;
  ....
  ....
}
server {
  listen myserver.com:8001;
  ....
  ....
}</pre></div></div><div class="section" title="server_name"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec36"/>server_name</h3></div></div></div><p>The <code class="literal">server_name</code> directive <a id="id166" class="indexterm"/>defines the name of the virtual server. It can contain a list of hostnames, and the first one becomes the default name of the server. The hostnames can be exact string literals,<a id="id167" class="indexterm"/> wildcards, regular expressions, or a combination of all of these. You can also define an empty hostname as <code class="literal">""</code>. This allows the processing of <a id="id168" class="indexterm"/>requests when the host HTTP header is empty.</p><p>The wildcard name can only<a id="id169" class="indexterm"/> use the asterisk (<code class="literal">*</code>) on the dot border and at the beginning or ending of the name. For example, <code class="literal">*.example.com</code> is a valid name; however, <code class="literal">ac*e.example.com</code> is an invalid name.</p><p>The regular expression server name can be any PCRE-compatible regular expression that must start with <code class="literal">~</code>.</p><div class="informalexample"><pre class="programlisting">server_name ~^www\d+\.acme\.org$</pre></div><p>If you specify the environment variable <code class="literal">$hostname</code> in this directive, the hostname of the machine is used.</p><div class="section" title="listen"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec02"/>listen</h4></div></div></div><p>The <code class="literal">listen</code> directive specifies<a id="id170" class="indexterm"/> the <code class="literal">listen</code> address of the server. The <a id="id171" class="indexterm"/>
<code class="literal">listen</code> address can be a combination of an IP address and a port, hostname and port, or just a port.</p><div class="informalexample"><pre class="programlisting">server {
  listen 8001
  server_name www.acme.com *.acme.com www.acme.org
  ...
}</pre></div><p>If no port is specified in the <code class="literal">listen</code> directive, the port 80 is used by default if the Nginx server is running as<a id="id172" class="indexterm"/> a <code class="literal">superuser</code>, otherwise the port 8000 is<a id="id173" class="indexterm"/> used.</p><p>Nginx can also listen on a UNIX socket using the following syntax:</p><div class="informalexample"><pre class="programlisting">listen unix:/var/lock/nginx</pre></div><p>IPv6 addresses can be specified using the <code class="literal">[]</code> brackets:</p><div class="informalexample"><pre class="programlisting">listen [::]:80
listen [2001:db8::1]</pre></div><p>Specifying an IPv6 address <a id="id174" class="indexterm"/>can enable the IPv4 address as well. In the first of the preceding examples, when you enable the <code class="literal">[::]:80</code> address, binding port 80 using IPv6 in the <code class="literal">listen</code> directive, the IPv4 port 80 is also enabled by default in Linux.</p><p>The <code class="literal">listen</code> directive accepts several parameters as well; a couple of important ones are stated in the following paragraphs.</p><div class="section" title="SSL"><div class="titlepage"><div><div><h5 class="title"><a id="ch03lvl5sec02"/>SSL</h5></div></div></div><p>The <code class="literal">listen</code> parameter<a id="id175" class="indexterm"/> allows you to specify that the connection accepted on this <code class="literal">listen</code> address will work in the SSL mode.</p></div><div class="section" title="default_server"><div class="titlepage"><div><div><h5 class="title"><a id="ch03lvl5sec03"/>default_server</h5></div></div></div><p>The <code class="literal">default_server</code> parameter <a id="id176" class="indexterm"/>sets the <code class="literal">listen</code> address as the default location. If none of the <code class="literal">listen</code> addresses have a<a id="id177" class="indexterm"/> default specification, the first <code class="literal">listen</code> declaration becomes the default. For an HTTP request, Nginx tests the request's header field, <code class="literal">Host</code>, to determine which server the request should be routed. If its value does not match any server name or the request does not contain this header field at all, Nginx will route the request to the default server.</p><div class="informalexample"><pre class="programlisting">listen  8001
listen  443 default_server ssl</pre></div><p>The <code class="literal">ssl</code> option specifies that all connections on this address should work with SSL. The <code class="literal">ssl</code> option will only work if the server was compiled using SSL support.</p><p>There are other parameters of the <code class="literal">listen</code> directive that correspond to the <code class="literal">listen</code> and <code class="literal">bind</code> system calls. For example, you can modify the send and receive buffers of the listening socket by providing the <code class="literal">rcvbuf</code> and <code class="literal">sndbuf</code> parameters. You can read about them in more detail in the official documentation at <a class="ulink" href="http://nginx.org/en/docs/http/ngx_http_core_module.html">http://nginx.org/en/docs/http/ngx_http_core_module.html</a>.</p></div></div><div class="section" title="location"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec03"/>location</h4></div></div></div><p>The <code class="literal">location</code> directive is a server context configuration. There can be several location configuration blocks inside the <code class="literal">server</code> block, each referring to a unique URI within that server. It is one <a id="id178" class="indexterm"/>of the most important and widely used directives, which allows you to <a id="id179" class="indexterm"/>specify a configuration based on a URI. A location matching the user request URI will result in that specific configuration block to be the handler of user request. You have a lot of flexibility in how you want to specify the configuration. This can be a string literal or a regular expression. The regular expressions can be used to <a id="id180" class="indexterm"/>do a case-sensitive (prefixed with <code class="literal">~</code>) or a case-insensitive comparison (prefixed with <code class="literal">~*</code>). You can also disable the regular expression matching by prefixing the string with <code class="literal">^~</code>.</p><p>The order of matching is as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, string literals with <code class="literal">=</code> are evaluated, and the searching stops on a match.</li><li class="listitem">Remaining strings are matched; a match encountering <code class="literal">^~</code> also stops the search. Among all the non-regular-expression strings, the one with the longest matched prefix is chosen.</li><li class="listitem">Regular expressions are searched in the order in which they appear in the <code class="literal">nginx.conf</code> file.</li><li class="listitem">In case there are two matches, one from a regular expression and one from a string, the string is used.<div class="informalexample"><pre class="programlisting">location = / matches only /
location / matches any URI
location ~/index matches a lower case /index as a subsring in anyposition</pre></div></li></ol></div><p>It does not matter in which order the configurations are defined. They will always be evaluated in the order mentioned previously.</p><div class="informalexample"><pre class="programlisting">location ^~/index/main.jpg
location ~^/index/.*\.jpg$</pre></div><p>In the example, a URI such as <code class="literal">/index/main.jpg</code> will select the first rule even though both the patterns match. This is due to the <code class="literal">^~</code> prefix, which disables regular expression search.</p><p>It is also possible to define named locations with <code class="literal">@</code>, which are for internal use. For example:</p><div class="informalexample"><pre class="programlisting">location @internalerror (
  proxy_pass http://myserver/internalerror.html
)</pre></div><p>You can then use the <code class="literal">@internalerror</code> in another configuration, that is:</p><div class="informalexample"><pre class="programlisting">location / (
  error_page /500.html @internalerror;
)</pre></div></div><div class="section" title="server_names_hash_bucket_size"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec04"/>server_names_hash_bucket_size</h4></div></div></div><p>Nginx stores static data in hash tables for quick access. There is a hash table maintained for each set of static data, such as server names. The identical names go into a hash bucket, and the <code class="literal">server_names_hash_bucket_size</code> parameter controls the size of a hash bucket in the<a id="id181" class="indexterm"/> server name hash table.</p><p>This parameter<a id="id182" class="indexterm"/> (and other <code class="literal">hash_bucket_size</code> parameters) should be a multiple of the processor's cache line size. This allows for an optimized search within<a id="id183" class="indexterm"/> a hash bucket ensuring that any entry can be found in a maximum of two memory reads. On Linux, you can find the cache line size as follows:</p><div class="informalexample"><pre class="programlisting">$ getconf LEVEL1_DCACHE_LINESIZE</pre></div></div><div class="section" title="server_names_hash_max_size"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec05"/>server_names_hash_max_size</h4></div></div></div><p>The <code class="literal">server_names_hash_max_size</code> directive<a id="id184" class="indexterm"/> specifies the maximum size of the hash table, which contains<a id="id185" class="indexterm"/> the server names. The size of the hash table calculated using the <code class="literal">server_names_hash_bucket_size</code> parameter cannot exceed this value. The default value is <code class="literal">512</code>.</p><div class="informalexample"><pre class="programlisting">http {
  ...
  ...
  server_names_hash_bucket_size 128;
  server_names_hash_max_size 1024;

  server {
  ...
  ...

  }
}</pre></div></div><div class="section" title="tcp_nodelay/tcp_nopush"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec06"/>tcp_nodelay/tcp_nopush</h4></div></div></div><p>The <code class="literal">tcp_nodelay</code> <a id="id186" class="indexterm"/>and <code class="literal">tcp_nopush</code> directives<a id="id187" class="indexterm"/> allow you to control the socket settings of <code class="literal">tcp_nodelay</code> <a id="id188" class="indexterm"/>and <code class="literal">tcp_nopush</code> or <code class="literal">tcp_nocork</code> for Linux. <code class="literal">tcp_nodelay</code> is useful for servers that send frequent small bursts of packets without caring about the response. This directive essentially disables the Nagle algorithm on the TCP/IP socket. <code class="literal">tcp_nopush</code> or <code class="literal">tcp_nocork</code> will only have an effect if you use the <code class="literal">sendfile()</code> kernel <a id="id189" class="indexterm"/>option.</p></div><div class="section" title="sendfile"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec07"/>sendfile</h4></div></div></div><p>The <code class="literal">sendfile</code> directive<a id="id190" class="indexterm"/> activates or deactivates the usage of Linux kernel's <code class="literal">sendfile()</code>. This offers<a id="id191" class="indexterm"/> significant performance benefits to applications such as web servers that need to efficiently transfer files. A web server spends much of its time transferring files stored on a disk to a network connection connected to a client running a web browser. Typically, this includes the <code class="literal">read()</code> and <code class="literal">write()</code> calls, which require context switching and data copying to and from user or kernel buffers. The <code class="literal">sendfile</code> system call allows Nginx to copy files from the disk to the socket using the fast track <code class="literal">sendfile()</code>, which stays within the kernel space. As of Linux 2.6.22, if you want to use the Aio with direct I/O (O_DIRECT) you should<a id="id192" class="indexterm"/> turn off <code class="literal">sendfile</code>. This can be more efficient if the web server serves large files ( &gt; 4 MB). In FreeBSD before 5.2.1 and Nginx 0.8.12, you must disable <code class="literal">sendfile</code> support as well.</p></div><div class="section" title="sendfile_max_chunk"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec08"/>sendfile_max_chunk</h4></div></div></div><p>When set to a nonzero value, the<a id="id193" class="indexterm"/> <code class="literal">sendfile_max_chunk</code><a id="id194" class="indexterm"/> directive limits the amount of data that can be transferred in a single <code class="literal">sendfile()</code> call.</p></div><div class="section" title="root"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec09"/>root</h4></div></div></div><p>
<code class="literal">root</code> specifies the <a id="id195" class="indexterm"/>document root for the requests by appending a path to the request. For example, with the following configuration:</p><div class="informalexample"><pre class="programlisting">location  /images/ {
  root  /var/www;
}</pre></div><p>A request for <code class="literal">/web/logo.gif</code> will return the file <code class="literal">/var/www/images/logo.gif</code>.</p></div><div class="section" title="resolver/resolver_timeout"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec10"/>resolver/resolver_timeout</h4></div></div></div><p>This allows you to specify<a id="id196" class="indexterm"/> the DNS server address or name. You can also define the timeout for name resolution, for example:</p><div class="informalexample"><pre class="programlisting">resolver 192.168.220.1;
resolver_timeout 2s;</pre></div></div><div class="section" title="aio"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec11"/>aio</h4></div></div></div><p>The <code class="literal">aio</code> <a id="id197" class="indexterm"/>directive allows Nginx to use the POSIX <code class="literal">aio</code> support in Linux. This <a id="id198" class="indexterm"/>asynchronous I/O mechanism allows multiple nonblocking reads and writes.</p><div class="informalexample"><pre class="programlisting">location /audio {
  aio on;
  directio 512;
  output_buffers 1 128k;
}</pre></div><p>On Linux this will disable the <code class="literal">sendfile</code> support. In FreeBSD before 5.2.1 and Nginx 0.8.12, you must disable the <code class="literal">sendfile</code> support.</p><div class="informalexample"><pre class="programlisting">location /audio {
  aio on;
  sendfile off;
}</pre></div><p>As of FreeBSD 5.2.1 and Nginx 0.8.12, you can use it with <code class="literal">sendfile</code>.</p></div><div class="section" title="alias"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec12"/>alias</h4></div></div></div><p>The <code class="literal">alias</code> directive<a id="id199" class="indexterm"/> is similar to the <code class="literal">root</code> directive with a subtle<a id="id200" class="indexterm"/> difference. When you define an alias for a location, the alias path is searched instead of the actual location. This is slightly different from<a id="id201" class="indexterm"/> the root directive where the root path is appended to the location. For example:</p><div class="informalexample"><pre class="programlisting">location  /img/ {
  alias  /var/www/images/;
}</pre></div><p>A request for <code class="literal">/img/logo.gif</code> will instruct Nginx to serve the file <code class="literal">/var/www/images/logo.gif</code>.</p><p>Aliases can also be used in a location specified by a regular expression.</p></div><div class="section" title="error_page"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec13"/>error_page</h4></div></div></div><p>The <code class="literal">error_page</code> directive <a id="id202" class="indexterm"/>allows<a id="id203" class="indexterm"/> you to show error pages based on error code. For example:</p><div class="informalexample"><pre class="programlisting">error_page   404          /404.html;
error_page   502 503 504  /50x.html;</pre></div><p>It is possible to show a different error code instead of the original error. It is also possible to specify a script like a php file (which in turn generates the content of the error page). This can allow you to write one generic error handler that creates a customized page depending on the error code and type:</p><div class="informalexample"><pre class="programlisting">error_page 404 =200 /empty.gif;
error_page 500 =errors.php;</pre></div><p>If there is no need to change the URL in the browser during redirection, it is possible to redirect the processing<a id="id204" class="indexterm"/> of error pages to a named location:</p><div class="informalexample"><pre class="programlisting">location / (
  error_page 404 @errorhandler;
)
location @ errorhandler (
  proxy_pass http://backend/errors.php;
)</pre></div></div><div class="section" title="keepalive_disable, keepalive_timeout, and keepalive_requests"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec14"/>keepalive_disable, keepalive_timeout, and keepalive_requests</h4></div></div></div><p>The<a id="id205" class="indexterm"/> <code class="literal">keepalive_disable</code><a id="id206" class="indexterm"/> directive allows you to disable the HTTP <code class="literal">keepalive</code> for certain browsers.</p><p>
<code class="literal">keepalive_timeout</code><a id="id207" class="indexterm"/> assigns<a id="id208" class="indexterm"/> the timeout for the <code class="literal">keepalive</code> connections <a id="id209" class="indexterm"/>with the client. The server will close connections after this time. You can also specify a zero value to disable the keepalive for client connections. This adds an HTTP header Keep-Alive: timeout=time to the response.</p><p>
<code class="literal">keepalive_requests</code> parameter determines how many client requests will be served through a single keepalive connection. Once this limit is reached the connection is closed, and new keepalive session will be initiated.</p></div></div></div><div class="section" title="Controlling access (HttpAccessModule)"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec20"/>Controlling access (HttpAccessModule)</h2></div></div></div><p>The <code class="literal">HttpAccessModule</code> allows IP-based access control. You can specify both IPv4 and IPv6 addresses. Another alternative is using the GeoIP module.</p><p>Rules are checked according to the order of their declaration. There are two directives called <code class="literal">allow</code> and <code class="literal">deny</code> which <a id="id210" class="indexterm"/>control the access. The first rule that matches a particular address or a set of addresses is the one that is obeyed.</p><div class="informalexample"><pre class="programlisting">location / {
  deny    192.168.1.1;
  allow   192.168.1.0/24;
  allow   10.1.1.0/16;
  allow   2620:100:e000::8001;
  deny    all;
}</pre></div><p>In this example access is granted to the networks 10.1.1.0/16 and 192.168.1.0/24 with the exception of the address 192.168.1.1, which is denied access together with all the other addresses as defined by the <code class="literal">deny all</code> rule that is matched last in this location block. In addition, it allows one specific IPv6 address. All others would be denied.</p><p>The order is of utmost importance. The rules are interpreted according to the order. So, if you move <code class="literal">deny all</code> to the top of the list, all requests will be denied because that's the first rule that is encountered, and therefore, it takes precedence.</p></div><div class="section" title="Authenticating users (HttpBasicAuthModule)"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec21"/>Authenticating users (HttpBasicAuthModule)</h2></div></div></div><p>You can use the <code class="literal">HttpBasicAuthModule</code> to protect your site or parts of it with a username and password based on HTTP Basic authentication. It is the simplest technique for enforcing access controls<a id="id211" class="indexterm"/> to web resources because it doesn't require cookies, session identifier, and login pages. Rather, HTTP Basic authentication uses static, standard HTTP headers, which mean that no handshakes have to be done in anticipation.</p><p>The following is an example configuration:</p><div class="informalexample"><pre class="programlisting">location  /  {
  auth_basic            "Registered Users Only";
  auth_basic_user_file  htpasswd;
}</pre></div><div class="section" title="Explaining directives"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec37"/>Explaining directives</h3></div></div></div><p>Now let us look at some of the important directives of this module.</p><div class="section" title="auth_basic"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec15"/>auth_basic</h4></div></div></div><p>This <code class="literal">auth_basic</code> directive includes<a id="id212" class="indexterm"/> testing the name and <a id="id213" class="indexterm"/>password with HTTP Basic authentication. The <a id="id214" class="indexterm"/>assigned<a id="id215" class="indexterm"/> value is used as authentication realm.</p></div><div class="section" title="auth_basic_user_file"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec16"/>auth_basic_user_file</h4></div></div></div><p>The <code class="literal">auth_basic_user_file</code> directive<a id="id216" class="indexterm"/> sets the password filename for the authentication realm. The <a id="id217" class="indexterm"/>path is relative to the directory of the Nginx configuration file.</p><p>The format of the file is as follows:</p><div class="informalexample"><pre class="programlisting">user:pass
user2:pass2:comment
user3:pass3</pre></div><p>Passwords must be encoded by the function crypt (3). You can use <code class="literal">PLAIN</code>, <code class="literal">MD5</code>, <code class="literal">SSHA</code>, and <code class="literal">SHA1</code> encryption methods. If you have Apache installed on your system, you can use the <code class="literal">htpasswd</code> utility to generate the <code class="literal">htpasswd</code> file.</p><p>This file should be readable by Nginx worker processes, running from an unprivileged user.</p></div></div></div><div class="section" title="Load balancing (HttpUpstreamModule)"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec22"/>Load balancing (HttpUpstreamModule)</h2></div></div></div><p>The <code class="literal">HttpUpstreamModule</code> allows simple load balancing based on a variety of techniques such as Round-robin, weight, IP address, <a id="id218" class="indexterm"/>and so on to a collection of upstream servers.</p><p>Example:</p><div class="informalexample"><pre class="programlisting">upstream servers  {
  server server1.example.com weight=5;
  server server2.example.com:8080;
  server unix:/tmp/server3;
}
server {
  location / {
    proxy_pass  http://servers;
  }
}</pre></div><div class="section" title="Explaining directives"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec38"/>Explaining directives</h3></div></div></div><p>Some of the important directives of the <code class="literal">HttpUpstreamModule</code> are as follows:</p><div class="section" title="ip_hash"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec17"/>ip_hash</h4></div></div></div><p>The <code class="literal">ip_hash</code> directive causes requests to be distributed between servers based on the IP address of the client.</p><p>The key for the hash is the IP address<a id="id219" class="indexterm"/> (IPv4 or IPv6) of the client. This method <a id="id220" class="indexterm"/>guarantees that the client<a id="id221" class="indexterm"/> request will always be transferred to the same server. If the server is not available, the request is transferred to another server.</p><p>You can combine <code class="literal">ip_hash</code> and <code class="literal">weight</code> based methods. If one of the servers needs to be taken offline, you must mark that server as <code class="literal">down</code>.</p><p>For example:</p><div class="informalexample"><pre class="programlisting">upstream backend {
  ip_hash;
  server   server1.example.com weight=2;
  server   server2.example.com;
  server   server3.example.com  down;
  server   server4.example.com;
}</pre></div></div><div class="section" title="server"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec18"/>server</h4></div></div></div><p>The <code class="literal">server</code> directive<a id="id222" class="indexterm"/> is used to specify the name of the upstream server. It is possible to use a domain name, address,<a id="id223" class="indexterm"/> port, or UNIX socket. If the domain<a id="id224" class="indexterm"/> name resolves to several addresses, all are used.</p><p>This directive accepts several parameters,<a id="id225" class="indexterm"/> which are given as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">weight</code>: This sets the weight of the server. If it is not set, weight is equal to one.</li><li class="listitem" style="list-style-type: disc"><code class="literal">max_fails</code>: This is the number<a id="id226" class="indexterm"/> of unsuccessful attempts at communicating with the server within the time period <code class="literal">fail_timeout</code> after which it is considered <code class="literal">down</code>. If it is not set, only one attempt is made. A value of <code class="literal">0</code> turns off this check. What is considered a failure is defined by <code class="literal">proxy_next_upstream</code> or <code class="literal">fastcgi_next_upstream</code> (except <code class="literal">http_404</code> errors, which do not count toward <code class="literal">max_fails</code>).</li><li class="listitem" style="list-style-type: disc"><code class="literal">fail_timeout</code>: The time period<a id="id227" class="indexterm"/> within which failed attempts to connect to an upstream server are attempted before the server is considered <code class="literal">down</code>. It is also the time for which the server will be considered inoperative (before another attempt is made). The default value is 10 seconds.</li><li class="listitem" style="list-style-type: disc"><code class="literal">down</code>: This parameter<a id="id228" class="indexterm"/> marks the server as offline.</li></ul></div><p>If you use only one upstream server, Nginx will ignore the <code class="literal">max_fails</code> and <code class="literal">fail_timeout</code> parameters. This may cause your request to be lost if the upstream server is not available. You can use the same server name several times to simulate retries.</p></div><div class="section" title="upstream"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec19"/>upstream</h4></div></div></div><p>The <code class="literal">upstream</code> directive<a id="id229" class="indexterm"/> describes a set of upstream or backend servers to which the requests are sent. These are the servers that can be used in the<a id="id230" class="indexterm"/> directives <code class="literal">proxy_pass</code> and <code class="literal">fastcgi_pass</code> as a single entity. Each of the defined servers can be on different ports. You can also specify servers listening on local sockets.</p><p>Servers can be assigned different weights. If it is not specified, the weight is equal to one.</p><div class="informalexample"><pre class="programlisting">upstream servers {
  server server1.example.com weight=5;
  server 127.0.0.1:8080       max_fails=3  fail_timeout=30s;
  server unix:/tmp/localserver;
}</pre></div><p>Requests are distributed according to the servers in the Round-robin manner with respect to the server weight.</p><p>For example, for every seven requests given previously, their distribution will be as follows: five requests will be sent to <code class="literal">server1.example.com</code> and one request each to the second and the third server. If there is an error in connecting to the server, the request is sent to the next <a id="id231" class="indexterm"/>server. In the previous example, there will be three tries within 30 s for server 2 in case of a failure<a id="id232" class="indexterm"/> before the request is forwarded to server 3.</p></div></div></div><div class="section" title="Acting as a proxy (HttpProxyModule)"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec23"/>Acting as a proxy (HttpProxyModule)</h2></div></div></div><p>The <code class="literal">HttpProxyModule</code> allows<a id="id233" class="indexterm"/> Nginx to act as a proxy and pass requests to another server.</p><div class="informalexample"><pre class="programlisting">location / {
  proxy_pass        http://app.localhost:8000;
}</pre></div><p>Note when using the <code class="literal">HttpProxyModule</code> (or even when using FastCGI), the entire client request will be buffered in Nginx before being passed on to the proxy server.</p><div class="section" title="Explaining directives"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec39"/>Explaining directives</h3></div></div></div><p>Some of the important directives of the <code class="literal">HttpProxyModule</code> are as follows:</p><div class="section" title="proxy_pass"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec20"/>proxy_pass</h4></div></div></div><p>The <code class="literal">proxy_pass</code> directive <a id="id234" class="indexterm"/>sets the address of the proxy server and the URI to which the location will be mapped. The address may be given as a hostname or an<a id="id235" class="indexterm"/> address<a id="id236" class="indexterm"/> and port, for example:</p><div class="informalexample"><pre class="programlisting">proxy_pass http://localhost:8000/uri/;</pre></div><p>Or, the address may be given as an UNIX socket path:</p><div class="informalexample"><pre class="programlisting">proxy_pass http://unix:/path/to/backend.socket:/uri/;</pre></div><p>
<code class="literal">path</code> is given after the word <code class="literal">unix</code> between two colons.</p><p>You can use the <code class="literal">proxy_pass</code> directive to forward headers from the client request to the proxied server.</p><div class="informalexample"><pre class="programlisting">proxy_set_header Host $host;</pre></div><p>While passing requests, Nginx replaces the location in the URI with the location specified by the <code class="literal">proxy_pass</code> directive.</p><p>If inside the proxied location, URI is changed by the <code class="literal">rewrite</code> directive and this configuration will be used to process the request. For example:</p><div class="informalexample"><pre class="programlisting">location  /name/ {
  rewrite      /name/([^/] +)  /users?name=$1  break;
  proxy_pass   http://127.0.0.1;
}</pre></div><p>A request URI is passed to the proxy server after normalization as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Double slashes are replaced by a single slash</li><li class="listitem" style="list-style-type: disc">Any references to current directory like "./" are removed</li><li class="listitem" style="list-style-type: disc">Any references to the previous directory like "../" are removed.</li></ul></div><p>If <code class="literal">proxy_pass</code> is specified without a URI (for example in "<code class="literal">http://example.com/request</code>",<code class="literal"> /request</code> is the URI part), the request URI is passed to the server in the same form as sent by a client. </p><div class="informalexample"><pre class="programlisting"> location /some/path/ {
     proxy_pass http://127.0.0.1;
 }</pre></div><p>If you need the proxy<a id="id237" class="indexterm"/> connection to an upstream server group to use SSL, your <code class="literal">proxy_pass</code> rule should use <code class="literal">https://</code> and you will also have to set your SSL port explicitly in the upstream definition. For example:</p><div class="informalexample"><pre class="programlisting">upstream https-backend {
  server 10.220.129.20:443;
}
 
server {
  listen 10.220.129.1:443;
  location / {
    proxy_pass https://backend-secure;
  }
}</pre></div></div><div class="section" title="proxy_pass_header"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec21"/>proxy_pass_header</h4></div></div></div><p>The <code class="literal">proxy_pass_header</code> directive <a id="id238" class="indexterm"/>allows<a id="id239" class="indexterm"/> transferring header lines forbidden for response.</p><div class="informalexample"><pre class="programlisting">For example:
location / {
  proxy_pass_header X-Accel-Redirect;
}</pre></div></div><div class="section" title="proxy_connect_timeout"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec22"/>proxy_connect_timeout</h4></div></div></div><p>The <code class="literal">proxy_connect_timeout</code> directive<a id="id240" class="indexterm"/> sets a connection timeout to the upstream server. You can't set this timeout value to be more than 75 seconds. Please remember that this is not<a id="id241" class="indexterm"/> the response timeout, but only a connection timeout.</p><p>This is not the time until the server returns the pages which is configured through <code class="literal">proxy_read_timeout</code> directive. If your upstream server is up but hanging, this statement will not help as the connection to the server has been made.</p></div><div class="section" title="proxy_next_upstream"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec23"/>proxy_next_upstream</h4></div></div></div><p>The <code class="literal">proxy_next_upstream</code> directive <a id="id242" class="indexterm"/>determines in which<a id="id243" class="indexterm"/> cases the request will be transmitted to the next server:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">error</code>: An error occurred while connecting to the server, sending a request to it, or reading its response</li><li class="listitem" style="list-style-type: disc"><code class="literal">timeout</code>: The timeout occurred during the connection with the server, transferring the request, or while reading the response from the server</li><li class="listitem" style="list-style-type: disc"><code class="literal">invalid_header</code>: The server returned an empty or incorrect response</li><li class="listitem" style="list-style-type: disc"><code class="literal">http_500</code>: The server responded with code 500</li><li class="listitem" style="list-style-type: disc"><code class="literal">http_502</code>: The server responded with code 502</li><li class="listitem" style="list-style-type: disc"><code class="literal">http_503</code>: The server responded with code 503</li><li class="listitem" style="list-style-type: disc"><code class="literal">http_504</code>: The server<a id="id244" class="indexterm"/> responded with code 504</li><li class="listitem" style="list-style-type: disc"><code class="literal">http_404</code>: The server responded with code 404</li><li class="listitem" style="list-style-type: disc"><code class="literal">off</code>: Disables request forwarding</li></ul></div><p>Transferring the request to the next server is only possible if there is an error sending the request to one of the servers. If the request sending was interrupted due to an error or some other reason, the transfer of request will not take place.</p></div><div class="section" title="proxy_redirect"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec24"/>proxy_redirect</h4></div></div></div><p>The <code class="literal">proxy_redirect</code> directive<a id="id245" class="indexterm"/> allows you to manipulate the HTTP redirection by replacing the text in the response<a id="id246" class="indexterm"/> from the upstream server. Specifically, it replaces text in the <code class="literal">Location</code> and <code class="literal">Refresh</code> headers.</p><p>The HTTP <code class="literal">Location</code> header field is returned<a id="id247" class="indexterm"/> in response from a proxied server for the following reasons:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">To indicate that a resource has moved temporarily or permanently.</li><li class="listitem" style="list-style-type: disc">To provide information about the location of a newly created resource. This could be the result of an HTTP <code class="literal">PUT</code>.</li></ul></div><p>Let us suppose that the proxied server returned the following:</p><div class="informalexample"><pre class="programlisting">Location: http://localhost:8080/images/new_folder</pre></div><p>If you have the <code class="literal">proxy_redirect</code> directive set to the following:</p><div class="informalexample"><pre class="programlisting">proxy_redirect http://localhost:8080/images/ http://xyz/;</pre></div><p>The <code class="literal">Location</code> text will be rewritten to be similar to the following:</p><div class="informalexample"><pre class="programlisting">Location: http://xyz/new_folder/.</pre></div><p>It is possible to use some variables in the redirected address:</p><div class="informalexample"><pre class="programlisting">proxy_redirect http://localhost:8000/ http://$location:8000;</pre></div><p>You can also <a id="id248" class="indexterm"/>use regular<a id="id249" class="indexterm"/> expressions in this directive:</p><div class="informalexample"><pre class="programlisting">proxy_redirect ~^(http://[^:]+):\d+(/.+)$ $1$2;</pre></div><p>The value <code class="literal">off</code> disables all the <code class="literal">proxy_redirect</code> directives at its level.</p><div class="informalexample"><pre class="programlisting">proxy_redirect off;</pre></div></div><div class="section" title="proxy_set_header"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec25"/>proxy_set_header</h4></div></div></div><p>The <code class="literal">proxy_set_header</code> directive<a id="id250" class="indexterm"/> allows you to redefine and add<a id="id251" class="indexterm"/> new HTTP headers to the request sent to the proxied server.</p><p>You can use a combination of static text and variables as the value of the <code class="literal">proxy_set_header</code> directive.</p><p>By default, the following<a id="id252" class="indexterm"/> two headers will be redefined:</p><div class="informalexample"><pre class="programlisting">proxy_set_header Host $proxy_host;
proxy_set_header Connection Close;</pre></div><p>You can forward the original <code class="literal">Host</code> header value to the server as follows:</p><div class="informalexample"><pre class="programlisting">proxy_set_header Host $http_host;</pre></div><p>However, if this header is absent in the client request, nothing will be transferred.</p><p>It is better to use the variable <code class="literal">$host</code>; its value is equal to the request header <code class="literal">Host</code> or to the basic name of the server in case the header is absent from the client request.</p><div class="informalexample"><pre class="programlisting">proxy_set_header Host $host;</pre></div><p>You can transmit the name of the server together with the port of the proxied server:</p><div class="informalexample"><pre class="programlisting">proxy_set_header Host $host:$proxy_port;</pre></div><p>If you set the value to an empty string, the header is not passed to the upstream proxied server. For example, if you want to disable the gzip compression on upstream, you can do the following:</p><div class="informalexample"><pre class="programlisting">proxy_set_header  Accept-Encoding  "";</pre></div></div><div class="section" title="proxy_store"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec26"/>proxy_store</h4></div></div></div><p>The <code class="literal">proxy_store</code> directive<a id="id253" class="indexterm"/> sets the path in which upstream files<a id="id254" class="indexterm"/> are stored, with paths corresponding to the directives <code class="literal">alias</code> or <code class="literal">root</code>. The <code class="literal">off</code> directive value disables local file storage. Please note that <code class="literal">proxy_store</code> is different from <code class="literal">proxy_cache</code>. It is just a method to store proxied files on disk. It may be used to construct cache-like setups (usually involving error_page-based fallback). This <code class="literal">proxy_store</code> directive parameter is <code class="literal">off</code> by<a id="id255" class="indexterm"/> default. The value can contain a mix of static strings and variables.</p><div class="informalexample"><pre class="programlisting">proxy_store   /data/www$uri;</pre></div><p>The modification date of the file will be set to the value of the <code class="literal">Last-Modified</code> header in the response. A response is first written to a temporary file in the path specified by <code class="literal">proxy_temp_path</code> and then renamed. It is recommended to keep this location path and the path to store files the same to make sure it is a simple renaming instead of creating two copies of the file.</p><p>Example:</p><div class="informalexample"><pre class="programlisting">location /images/ {
  root                 /data/www;
  error_page           404 = @fetch;
}
 
location /fetch {
  internal;
  proxy_pass           http://backend;
  proxy_store          on;
  proxy_store_access   user:rw  group:rw  all:r;
  proxy_temp_path      /data/temp;
  alias                /data/www;
}</pre></div><p>In this example, <code class="literal">proxy_store_access</code> defines the access rights of the created file.</p><p>In the case of an error <code class="literal">404</code>, the fetch internal location proxies to a remote server and stores the local copies in the <code class="literal">/data/temp</code> folder.</p></div><div class="section" title="proxy_cache"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec27"/>proxy_cache</h4></div></div></div><p>The <code class="literal">proxy_cache</code> directive<a id="id256" class="indexterm"/> either turns off caching when you use the value <code class="literal">off</code> or sets the name of the cache. This name can then be used subsequently<a id="id257" class="indexterm"/> in other places as well. Let's look at the following example to enable caching on the Nginx server:</p><div class="informalexample"><pre class="programlisting">http {
  proxy_cache_path  /var/www/cache levels=1:2 keys_zone=my-cache:8m max_size=1000m inactive=600m;
  proxy_temp_path /var/www/cache/tmp;


  server {
    location / {
      proxy_pass http://example.net;
      proxy_cache my-cache;
      proxy_cache_valid  200 302  60m;
      proxy_cache_valid  404      1m;
    }
  }
}</pre></div><p>The previous example creates a named cache called <code class="literal">my-cache</code>. It sets up the validity of the cache for<a id="id258" class="indexterm"/> response codes <code class="literal">200</code> and <code class="literal">302</code> to <code class="literal">60m</code>, and for <code class="literal">404</code> to <code class="literal">1m</code>, respectively.</p><p>The cached data<a id="id259" class="indexterm"/> is stored in the <code class="literal">/var/www/cache</code> folder. The <code class="literal">levels</code> parameter sets the number of subdirectory<a id="id260" class="indexterm"/> levels in the cache. You can define up to three levels.</p><p>The name of <code class="literal">key_zone</code> is followed by an inactive interval. All the inactive items in <code class="literal">my-cache</code> will be purged after <code class="literal">600m</code>. The default value for inactive intervals is 10 minutes.</p></div></div></div><div class="section" title="Compressing content (HttpGzipModule)"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec24"/>Compressing content (HttpGzipModule)</h2></div></div></div><p>The <code class="literal">HttpGzipModule</code> allows<a id="id261" class="indexterm"/> for on-the-fly gzip compression.</p><div class="informalexample"><pre class="programlisting">  gzip             on;
  gzip_min_length  1000;
  gzip_proxied     expired no-cache no-store private auth;
  gzip_types       text/plain application/xml;</pre></div><p>The achieved compression ratio, computed as the ratio between the original and the compressed response size, is available via the variable <code class="literal">$gzip_ratio</code>.</p><div class="section" title="Explaining directives"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec40"/>Explaining directives</h3></div></div></div><p>Some of the important <a id="id262" class="indexterm"/>directives of the <code class="literal">HttpGzipModule</code> are as follows:</p><div class="section" title="gzip"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec28"/>gzip</h4></div></div></div><p>The <code class="literal">gzip</code> directive<a id="id263" class="indexterm"/> enables <a id="id264" class="indexterm"/>or disables gzip compression.</p></div><div class="section" title="gzip_buffers"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec29"/>gzip_buffers</h4></div></div></div><p>The <code class="literal">gzip_buffers</code> directive <a id="id265" class="indexterm"/>assigns the number and size of the <a id="id266" class="indexterm"/>buffers in which the compressed response will be stored. If unset, the size of one buffer is equal to the size of the page; depending on the platform, this is either <code class="literal">4K</code> or <code class="literal">8K</code>.</p></div><div class="section" title="gzip_comp_level"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec30"/>gzip_comp_level</h4></div></div></div><p>The <code class="literal">gzip_comp_level</code> directive<a id="id267" class="indexterm"/> sets a gzip compression<a id="id268" class="indexterm"/> level of a response. The compression level, between <code class="literal">1</code> and <code class="literal">9</code>, where <code class="literal">1</code> is the least compression (fastest) and <code class="literal">9</code> is the most compression (slowest).</p></div><div class="section" title="gzip_disable"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec31"/>gzip_disable</h4></div></div></div><p>The <code class="literal">gzip_disable</code> directive<a id="id269" class="indexterm"/> disables gzip compression for<a id="id270" class="indexterm"/> browsers<a id="id271" class="indexterm"/> or user agents matching the given regular expression. For example, to disable gzip compression for Internet Explorer 6 use:</p><div class="informalexample"><pre class="programlisting">gzip_disable     "msie6";</pre></div><p>This is a useful setting to have since some browsers such as MS Internet Explorer 6 don't handle the compressed response correctly.</p></div><div class="section" title="gzip_http_version"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec32"/>gzip_http_version</h4></div></div></div><p>The <a id="id272" class="indexterm"/>
<code class="literal">gzip_http_version</code> directive<a id="id273" class="indexterm"/> turns gzip compression on or off depending on the HTTP request version, which is 1.0 or 1.1.</p></div><div class="section" title="gzip_min_length"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec33"/>gzip_min_length</h4></div></div></div><p>The <code class="literal">gzip_min_length</code> directive <a id="id274" class="indexterm"/>sets the minimum length, in bytes, of the response that will be compressed. Responses shorter than this<a id="id275" class="indexterm"/> byte length will not be compressed. Length is determined from the <code class="literal">Content-Length</code> header.</p></div><div class="section" title="gzip_proxied"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec34"/>gzip_proxied</h4></div></div></div><p>The <code class="literal">gzip_proxied</code> directive<a id="id276" class="indexterm"/> enables or disables compression for proxied requests. The proxied requests are identified through the <code class="literal">Via</code> HTTP header. <a id="id277" class="indexterm"/>This header informs the server of proxies through which the request was sent. Depending on various HTTP headers, we can enable or disable the compression for proxied requests as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">off</code>: This disables compression for requests having a <code class="literal">Via</code> header</li><li class="listitem" style="list-style-type: disc"><code class="literal">expired</code>: This enables compression if a response header includes the field <code class="literal">Expires</code> with a value that disables caching</li><li class="listitem" style="list-style-type: disc"><code class="literal">no-cache</code>: This enables compression if the <code class="literal">Cache-Control</code> header is set to <code class="literal">no-cache</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">no-store</code>: This enables compression if the <code class="literal">Cache-Control</code> header is set to <code class="literal">no-store</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">private</code>: This enables compression if the <code class="literal">Cache-Control</code> header is set to <code class="literal">private</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">no_last_modified</code>: This enables compression if <code class="literal">Last-Modified</code> isn't set</li><li class="listitem" style="list-style-type: disc"><code class="literal">no_etag</code>: This enables compression if there is no <code class="literal">ETag</code> header</li><li class="listitem" style="list-style-type: disc"><code class="literal">auth</code>: This enables compression if there is an <code class="literal">Authorization</code> header</li><li class="listitem" style="list-style-type: disc"><code class="literal">any</code>: This enables<a id="id278" class="indexterm"/> compression for all proxied requests</li></ul></div></div><div class="section" title="gzip_types"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec35"/>gzip_types</h4></div></div></div><p>The <code class="literal">gzip_types</code> directive<a id="id279" class="indexterm"/> enables compression for additional MIME <a id="id280" class="indexterm"/>types besides<a id="id281" class="indexterm"/> text or html. <code class="literal">text/html</code> is always compressed.</p></div></div></div><div class="section" title="Controlling logging (HttpLogModule)"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec25"/>Controlling logging (HttpLogModule)</h2></div></div></div><p>The <code class="literal">HttpLogModule</code> controls<a id="id282" class="indexterm"/> how Nginx logs the requests for resources, for example:</p><div class="informalexample"><pre class="programlisting">access_log  /var/log/nginx/access.log  gzip  buffer=32k;</pre></div><p>Please note that this does not include logging errors.</p><div class="section" title="Explaining directives"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec41"/>Explaining directives</h3></div></div></div><p>Some of the important directives of <code class="literal">HttpLogModule</code> are the following.</p><div class="section" title="access_log"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec36"/>access_log</h4></div></div></div><p>The <code class="literal">access_log</code> directive sets the path, format, and buffer size for the access logfile. Using <code class="literal">off</code> as the value disables <a id="id283" class="indexterm"/>logging at the current level. If the format is not indicated, it defaults to <code class="literal">combined</code>. The size of the buffer must not exceed the <a id="id284" class="indexterm"/>size of the atomic record for writing into the disk file. This size is not limited for FreeBSD 3.0-6.0. If <a id="id285" class="indexterm"/>you specify gzip, the log is compressed before it's written to the disk. The default buffer size is 64K with compression level as 1.</p><p>The atomic size that can be written is called <code class="literal">PIPE_BUF</code>. The capacity of a pipe buffer varies across systems.</p><p>Mac OS X, for example, uses a capacity of 16,384 bytes by default but can switch to 65,336 byte capacities if large writes are made to the pipe. Or it will switch to a capacity of a single system page if too much kernel memory is already being used by pipe buffers (see <code class="literal">xnu/bsd/sys/pipe.h</code> and <code class="literal">xnu/bsd/kern/sys_pipe.c</code>; since these are from FreeBSD, the same behavior may happen here too). </p><p>According to the Linux pipe(7) man page, pipe capacity is 65,536 bytes since Linux 2.6.11 and a single system <a id="id286" class="indexterm"/>page prior to that (for example, 4096 bytes on 32-bit x86 systems). The buffer for each pipe can be changed using fcntl system call to the maximum of <code class="literal">/proc/sys/fs/pipe-max-size</code>.</p></div><div class="section" title="log_format"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec37"/>log_format</h4></div></div></div><p>The <code class="literal">log_format</code> directive <a id="id287" class="indexterm"/>describes the format of a log entry. You can use general variables in the format as well as variables that exist only at the moment of <a id="id288" class="indexterm"/>writing into the log. An example of log_format is as follows:</p><div class="informalexample"><pre class="programlisting">log_format gzip '$msec $request $remote-addr $status $bytes_sent';</pre></div><p>You can specify the format of a log entry by specifying what information should be logged. Some of the options you can specify are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">$body_bytes_sent</code>: This is the number of bytes transmitted to the client minus the response headers</li><li class="listitem" style="list-style-type: disc"><code class="literal">$bytes_sent</code>: This is the number of bytes transmitted to the client</li><li class="listitem" style="list-style-type: disc"><code class="literal">$connection</code>: This is the number of connections</li><li class="listitem" style="list-style-type: disc"><code class="literal">$msec</code>: This is the current time at the moment of writing the log entry (microsecond accuracy)</li><li class="listitem" style="list-style-type: disc"><code class="literal">$pipe</code>: This is <code class="literal">p</code> if request was pipelined</li><li class="listitem" style="list-style-type: disc"><code class="literal">$request_length</code>: This is the length of the body of the request</li><li class="listitem" style="list-style-type: disc"><code class="literal">$request_time</code>: This is the time it took Nginx to work on the request, in seconds, with millisecond precision</li><li class="listitem" style="list-style-type: disc"><code class="literal">$status</code>: This is the status of the answer</li><li class="listitem" style="list-style-type: disc"><code class="literal">$time_iso8601</code>: This is the time in ISO 8601 format, for example, 2011-03-21T18:52:25+03</li><li class="listitem" style="list-style-type: disc"><code class="literal">$time_local</code>: This is the local time in common log format</li></ul></div></div></div></div><div class="section" title="Setting response headers (HttpHeadersModule)"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec26"/>Setting response headers (HttpHeadersModule)</h2></div></div></div><p>The <code class="literal">HttpHeadersModule</code> allows <a id="id289" class="indexterm"/>setting arbitrary HTTP headers.</p><div class="section" title="Explaining directives"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec42"/>Explaining directives</h3></div></div></div><p>Some of the <a id="id290" class="indexterm"/>important directives of the <code class="literal">HttpHeadersModule</code> are the following:</p><div class="section" title="add_header"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec38"/>add_header</h4></div></div></div><p>The <code class="literal">add_header</code> directive<a id="id291" class="indexterm"/> adds a header to the header list of the response when the response code is 200, 201, 204, 206, 301, 302, 303, 304, or 307. The <a id="id292" class="indexterm"/>value can contain variables and can contain negative or positive time value.</p><p>Note that you should not use this directive to replace or override the value of a header. The headers specified with this directive are simply appended to the header list.</p></div><div class="section" title="expires"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec39"/>expires</h4></div></div></div><p>The <code class="literal">expires</code> directive<a id="id293" class="indexterm"/> is used to set the <code class="literal">Expires</code> and <code class="literal">Cache-Control</code> headers in the response. You can set the value to <code class="literal">off</code> to leave these headers as it is. The time in this field is computed as a sum of<a id="id294" class="indexterm"/> the current time and the time specified in the directive. If the modified parameter is used, time is <a id="id295" class="indexterm"/>computed as a sum of the file's modification time and the time specified in the directive.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">epoch</code>: This sets the <code class="literal">Expires</code> header to the absolute value of <code class="literal">1 January, 1970 00:00:01 GMT</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">max</code>: This sets the <code class="literal">Expires</code> header to <code class="literal">31 December 2037 23:59:59 GMT</code>, and the <code class="literal">Cache-Control</code> header to 10 years.</li></ul></div><p>You can specify a time interval using <code class="literal">@</code>:</p><div class="informalexample"><pre class="programlisting">@5h40m</pre></div><p>The contents of the <code class="literal">Cache-Control</code> header depend on the sign of the specified time. A negative value of time sets it to <code class="literal">no-cache</code>. A positive value sets it to time in seconds.</p><p>The following is an example configuration:</p><div class="informalexample"><pre class="programlisting">expires    12h;
expires    modified +14h;
expires    @5h;
expires    0;
expires    -1;
expires    epoch;
add_header X-Name example.org</pre></div></div></div></div><div class="section" title="Rewriting requests (HttpRewriteModule)"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec27"/>Rewriting requests (HttpRewriteModule)</h2></div></div></div><p>The <code class="literal">HttpRewriteModule</code> is used to <a id="id296" class="indexterm"/>change request URIs using regular expressions, redirect the client, and select different configurations based on conditions and variable values. In order to use this module, you should compile Nginx with PCRE support.</p><p>The processing of the directives starts at the server level. After this, the location block matching the request is searched and any rewrite directives there are executed. If this processing results in further<a id="id297" class="indexterm"/> rewrites, a new location block is search for the changed URI. This cycle continues 10 times before the server throws the <code class="literal">500</code> error.</p><div class="section" title="Explaining directives"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec43"/>Explaining directives</h3></div></div></div><p>Some of the important directives of the <code class="literal">HttpRewriteModule</code> are the following:</p><div class="section" title="break"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec40"/>break</h4></div></div></div><p>The <code class="literal">break</code> directive stops<a id="id298" class="indexterm"/> the processing of any other<a id="id299" class="indexterm"/> rewrite<a id="id300" class="indexterm"/> block<a id="id301" class="indexterm"/> directives in the current block.</p><div class="informalexample"><pre class="programlisting">if ($slow) {
  limit_rate  10k;
  break;
}</pre></div></div><div class="section" title="if"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec41"/>if</h4></div></div></div><p>The <code class="literal">if</code> directive <a id="id302" class="indexterm"/>checks a condition. If the condition evaluates to <code class="literal">true</code>, the code indicated in the curly braces is carried out and the request is processed in<a id="id303" class="indexterm"/> accordance with the configuration within the following block. The configuration inside the <code class="literal">if</code> block is inherited from the previous level.</p><p>Following are considered to be valid conditions.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The name of a variable is a condition. The condition evaluates to <code class="literal">false</code> if the variable contains an empty string <code class="literal">""</code> or a <code class="literal">0</code>.</li><li class="listitem" style="list-style-type: disc">Using comparison operator with the variable to compare it to another variable or a string.</li><li class="listitem" style="list-style-type: disc">Matching a variable against a regular expression using <code class="literal">~</code>, <code class="literal">*~</code>, or <code class="literal">!~</code> operator. <code class="literal">*~</code> is used for case-insensitive comparison, while <code class="literal">!~</code> is a not-equals operator.</li><li class="listitem" style="list-style-type: disc">You can check for the existence of a file using the <code class="literal">-f</code> or <code class="literal">!-f</code> operators (similar to BASH tests).</li><li class="listitem" style="list-style-type: disc">Checking for the existence of a directory using <code class="literal">-d</code> or <code class="literal">!-d</code>.</li><li class="listitem" style="list-style-type: disc">Checking for the existence of a file, directory, or symbolic link using <code class="literal">-e</code> or <code class="literal">!-e</code>.</li><li class="listitem" style="list-style-type: disc">Checking whether a file is executable using <code class="literal">-x</code> or <code class="literal">!-x</code>.</li></ul></div><p>By placing part of a regular expression inside round brackets or parentheses, you can group that part of the regular expression together. This allows you to apply a quantifier to the entire group or to restrict alternation to part of the regular expression. These parts can be accessed in the <code class="literal">$1</code> to <code class="literal">$9</code><a id="id304" class="indexterm"/> variables.</p><p>Example:</p><div class="informalexample"><pre class="programlisting">if ($http_user_agent ~ MSIE) {
  rewrite ^(.*)$  /msie/$1  break;
}
if ($http_cookie ~* "val=([^;] +)(?:;|$)" ) {
  set $val $1;
}
if ($request_method = GET ) {
  return 405;
}
if ($args ~ post=140){
  rewrite ^ http://acme.com/ permanent
}</pre></div></div><div class="section" title="return"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec42"/>return</h4></div></div></div><p>The <code class="literal">return</code> directive stops <a id="id305" class="indexterm"/>execution and returns a status code. It is possible to use any HTTP return code ranging in number from <code class="literal">0</code> to <code class="literal">999</code>.</p><p>If you want to terminate<a id="id306" class="indexterm"/> the connection and don't want to send any headers in response, use the return code <code class="literal">444</code>.</p></div><div class="section" title="rewrite"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec43"/>rewrite</h4></div></div></div><p>The <code class="literal">rewrite</code> directive<a id="id307" class="indexterm"/> does the actual rewrite and changes URI according to the regular expression and the replacement string. Directives are<a id="id308" class="indexterm"/> carried out in the order of definition in the configuration file. The <code class="literal">flag</code> parameter makes it possible to stop the rewriting process in the current block.</p><p>If the replacement string begins with <code class="literal">http://</code>, the client will be redirected and any further rewrite directives will be terminated.</p><p>The value of the <code class="literal">flag</code> parameter<a id="id309" class="indexterm"/> can be one of the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">last</code>: This completes the processing of current rewrite directives and searches for a new block that matches the rewritten URI</li><li class="listitem" style="list-style-type: disc"><code class="literal">break</code>: This stops the rewriting process in the current block</li><li class="listitem" style="list-style-type: disc"><code class="literal">redirect</code>: This returns a temporary redirect with the code <code class="literal">302</code>, and is used if a replacement string does not start with <code class="literal">http://</code> or <code class="literal">https://</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">permanent</code>: This returns a permanent redirect with code <code class="literal">301</code></li></ul></div><p>Note that outside location blocks, <code class="literal">last</code> and <code class="literal">break</code> are effectively the same.</p><p>Example:</p><div class="informalexample"><pre class="programlisting">rewrite  ^(/media/.*)/video/(.*)\..*$  $1/mp3/$2.avi last;
rewrite  ^(/media/.*)/audio/(.*)\..*$  $1/mp3/$2.ra break;
return 403;</pre></div><p>But if we place these directives<a id="id310" class="indexterm"/> in the <code class="literal">location</code> block, it is necessary<a id="id311" class="indexterm"/> to replace the flag <code class="literal">last</code> by <code class="literal">break</code>, otherwise Nginx will hit the 10-cycle limit and return error <code class="literal">500</code>:</p><div class="informalexample"><pre class="programlisting">location /download/ {
  rewrite  ^(/media/.*)/video/(.*)\..*$  $1/mp3/$2.avi  break;
  rewrite  ^(/media/.*)/audio/(.*)\..*$  $1/mp3/$2.ra   break;
  return   403;
}</pre></div><p>If there are arguments in the replacement string, the rest of the request arguments are appended to them. To avoid having them appended, place a question mark as the last character:</p><div class="informalexample"><pre class="programlisting">rewrite  ^/pages/(.*)$  /show?page=$1?  last;</pre></div><p>Note that for curly braces ( { and } ), as they are used both in regex and for block control, to avoid conflicts, regex with curly braces are to be enclosed with double quotes (or single quotes). For example, to rewrite URLs such as <code class="literal">/users/123456 </code>to <code class="literal">/path/to/users/12/1234/123456.html</code>, use the following (note the quotes):</p><div class="informalexample"><pre class="programlisting">rewrite  "/users/([0-9]{2})([0-9]{2})([0-9]{2})"/path/to/users/$1/$1$2/$1$2$3.html;</pre></div><p>If you specify a <code class="literal">?</code> at the end of a rewrite, Nginx will drop the original query string. A good use case is when using <code class="literal">$request_uri</code>, you should specify the <code class="literal">?</code> at the end of the rewrite to avoid Nginx doubling the query string.</p><p>An example of using <code class="literal">$request_uri</code> in a rewrite from <code class="literal">www.acme.com</code> to <code class="literal">acme.com</code>:</p><div class="informalexample"><pre class="programlisting">server {
  server_name www.acme.com;
  rewrite ^ http://acme.com$request_uri? permanent;
}</pre></div><p>Also, rewrite operates only on paths, not on parameters. To rewrite a URL with parameters to another URL, use the following instead:</p><div class="informalexample"><pre class="programlisting">if ($args ~ post=200){
  rewrite ^ http://acme.com/new-address.html?;
}</pre></div></div><div class="section" title="rewrite_log"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec44"/>rewrite_log</h4></div></div></div><p>The <code class="literal">rewrite_log</code> directive<a id="id312" class="indexterm"/> enables the logging of <a id="id313" class="indexterm"/>information about rewrites to the error log at notice level.</p></div><div class="section" title="set"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec45"/>set</h4></div></div></div><p>The <a id="id314" class="indexterm"/>
<code class="literal">set</code> directive<a id="id315" class="indexterm"/> establishes the value for the variable indicated. It is possible to use text, variables, and their combination as the value.</p><p>You can use set to define a new<a id="id316" class="indexterm"/> variable. Note that you can't set the value of a <code class="literal">$http_xxx</code> header variable.</p></div><div class="section" title="uninitialized_variable_warn"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec46"/>uninitialized_variable_warn</h4></div></div></div><p>The <code class="literal">uninitialized_variable_warn</code> <a id="id317" class="indexterm"/>directive enables or disables warnings of variables that are not initialized.</p></div></div></div><div class="section" title="Interacting with FastCGI (HttpFastcgiModule)"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec28"/>Interacting with FastCGI (HttpFastcgiModule)</h2></div></div></div><p>The <code class="literal">HttpFastcgiModule</code> allows<a id="id318" class="indexterm"/> Nginx to interact with the FastCGI processes (that is, PHP) and controls which parameters will be passed to the process.</p><p>Example:</p><div class="informalexample"><pre class="programlisting">location / {
  fastcgi_pass   localhost:9090;
  fastcgi_index  index.php;
   fastcgi_param  SCRIPT_FILENAME$document_root/php/$fastcgi_script_name;
  fastcgi_param  QUERY_STRING     $query_string;
  fastcgi_param  REQUEST_METHOD   $request_method;
  fastcgi_param  CONTENT_TYPE     $content_type;
  fastcgi_param  CONTENT_LENGTH   $content_length;
}</pre></div><p>The name of the FastCGI server is provided in the <code class="literal">fastcgi_pass</code> parameter. This name can be an IP address or a domain name with a port. This can also be an UNIX domain socket.</p><p>If you want to pass a parameter to the FastCGI server, you use the <code class="literal">fastcgi_param</code> parameter.<a id="id319" class="indexterm"/> The value of this parameter can be a static value, a variable, or a combination of both.</p><p>Following is a minimum configuration for PHP:</p><div class="informalexample"><pre class="programlisting">fastcgi_param SCRIPT_FILENAME /php$fastcgi_script_name;
fastcgi_param QUERY_STRING    $query_string;</pre></div></div><div class="section" title="Simple caching (HttpMemcachedModule)"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec29"/>Simple caching (HttpMemcachedModule)</h2></div></div></div><p>You can use this module<a id="id320" class="indexterm"/> to perform simple caching using <code class="literal">memcached</code>. <a id="id321" class="indexterm"/>
<code class="literal">Memcached</code> is an in-memory, key-value store for small chunks of arbitrary data (strings, objects) from the results of database calls, API calls, or page rendering.</p><p>Example:</p><div class="informalexample"><pre class="programlisting">server {
  location / {
    set $memcached_key $uri$args;
    memcached_pass     http://mem-server:1211
    default_type       text/html;
      error_page         404 502 504 @error;
  }
  location @error {
    proxy_pass http://backend;
  }
}</pre></div><div class="section" title="Explaining directives"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec44"/>Explaining directives</h3></div></div></div><p>Some of the important <a id="id322" class="indexterm"/>directives of the <code class="literal">HttpMemcachedModule</code> are as follows:</p><div class="section" title="memcached_pass"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec47"/>memcached_pass</h4></div></div></div><p>The <code class="literal">memcached_pass</code> directive <a id="id323" class="indexterm"/>specifies the memcached server name as an IP or domain name. It can also contain a port. If the <a id="id324" class="indexterm"/>domain name translates into various addresses, all of them are tried in the Round-robin fashion.</p></div><div class="section" title="memcached_connect_timeout"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec48"/>memcached_connect_timeout</h4></div></div></div><p>The <code class="literal">memcached_connect_timeout</code> directive<a id="id325" class="indexterm"/> is the timeout for connecting to the <a id="id326" class="indexterm"/>memcached server. The time of the timeout usually can be <code class="literal">75s</code> at maximum. The default value is <code class="literal">60s</code>.</p></div><div class="section" title="memcached_read_timeout"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec49"/>memcached_read_timeout</h4></div></div></div><p>The <code class="literal">memcached_read_timeout</code> directive<a id="id327" class="indexterm"/> is the timeout for reading keys from the memcached server. This time is measured between two successive reads, and if the memcached<a id="id328" class="indexterm"/> server does not respond, the timeout occurs. The default value is <code class="literal">60s</code>.</p></div><div class="section" title="memcached_send_timeout"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec50"/>memcached_send_timeout</h4></div></div></div><p>The <code class="literal">memcached_send_timeout</code> directive<a id="id329" class="indexterm"/> is the timeout for sending a request to the memcached server. A timeout is only set between two successive write operations and not <a id="id330" class="indexterm"/>for the transmission of the whole request. If a memcached server does not receive anything within this time, a connection is closed.</p></div><div class="section" title="memcached_buffer_size"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec51"/>memcached_buffer_size</h4></div></div></div><p>The <code class="literal">memcached_buffer_size</code> directive <a id="id331" class="indexterm"/>is the receive or send buffer size in bytes. It sets the size of the buffer used for reading a response received from the memcached server. <a id="id332" class="indexterm"/>A response is passed to a client synchronously and immediately when it is received. Default value is <code class="literal">4K</code> or <code class="literal">8K</code>.</p></div><div class="section" title="memcached_next_upstream"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec52"/>memcached_next_upstream</h4></div></div></div><p>Which failure conditions should cause<a id="id333" class="indexterm"/> the request to be forwarded to another memcached upstream server? The answer is only when the value in <code class="literal">memcached_pass</code> is an upstream<a id="id334" class="indexterm"/> block with two or more servers.</p></div></div></div><div class="section" title="Limiting requests (HttpLimitReqModule)"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec30"/>Limiting requests (HttpLimitReqModule)</h2></div></div></div><p>The <code class="literal">HttpLimitReqModule</code> allows limiting the request processing rate by key, in particular by the address. The<a id="id335" class="indexterm"/> limitation is done using the leaky bucket method. A counter associated with each address transmitting on a connection is incremented whenever the user sends a request and is decremented periodically. If the counter exceeds a threshold upon being incremented, Nginx delays the request.</p><p>The following is an example configuration:</p><div class="informalexample"><pre class="programlisting">http {
    limit_req_zone  $binary_remote_addr  zone=one:10m   rate=1r/s;
 
    ...
 
    server {
 
        ...
 
        location /search/ {
            limit_req   zone=one  burst=5;
        }</pre></div><div class="section" title="Explaining directives"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec45"/>Explaining directives</h3></div></div></div><p>Some of the important directives <a id="id336" class="indexterm"/>of the <code class="literal">HttpLimitReqModule</code> are as follows:</p><div class="section" title="limit_req"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec53"/>limit_req</h4></div></div></div><p>The <code class="literal">limit_req</code> directive <a id="id337" class="indexterm"/>sets a shared memory zone and the maximum burst size of requests. Excessive requests are delayed until their number exceeds the maximum burst size in which case the request is terminated with an error <code class="literal">503</code> (Service Temporarily Unavailable). By default, the maximum burst size is equal to zero. For example, for the directive <code class="literal">limit_req_zone</code>:</p><div class="informalexample"><pre class="programlisting">  $binary_remote_addr  zone=one:10m   rate=1r/s;
     server {
        location /search/ {
            limit_req   zone=one  burst=5;
        }</pre></div><p>It allows a user no more than one request per second on average with bursts of no more than five requests.</p><p>If delaying excess requests within a burst is not necessary, you should use the option <code class="literal">nodelay</code>:</p><div class="informalexample"><pre class="programlisting">limit_req zone=one burst=5 nodelay;</pre></div></div><div class="section" title="limit_req_log_level"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec54"/>limit_req_log_level</h4></div></div></div><p>The <code class="literal">limit_req_log_level</code> directive controls the log level of the delayed or rejected requests. The log levels can<a id="id338" class="indexterm"/> be <code class="literal">info</code>, <code class="literal">notice</code>, <code class="literal">warn</code>, or <code class="literal">error</code>. The default log level is <code class="literal">error</code> for rejected requests. Delays are logged at the next lower level, for example when limit_req_log_level is set to "error", delayed requests are logged at "warn".</p></div><div class="section" title="limit_req_zone"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec55"/>limit_req_zone</h4></div></div></div><p>The <code class="literal">limit_req_zone</code> directive<a id="id339" class="indexterm"/> sets the name and parameters of a shared memory zone that keeps states for various keys. The state stores the current number of excessive requests in particular. The key is any nonempty value of the specified variable (empty values are not accounted). An example usage of this is as follows:</p><div class="informalexample"><pre class="programlisting">limit_req_zone $binary_remote_addr zone=myzone:20m rate=5r/s;</pre></div><p>In this case, there is a 20 MB zone called <code class="literal">myzone</code>, and the average speed of queries for this zone is limited to 5 requests per second.</p><p>The sessions are tracked per user in this case. A 1 MB zone can hold approximately 16,000 states of 64 bytes. If the storage for a zone is exhausted, the server will return error <code class="literal">503</code> (Service Temporarily Unavailable) to all further requests.</p><p>The speed is set in requests per second or requests per minute. The rate must be an integer; so if you need to specify less than one request per second, say, one request every two seconds, you would <a id="id340" class="indexterm"/>specify it as <code class="literal">30r/m</code>.</p></div></div></div><div class="section" title="Limiting connections (HttpLimitConnModule)"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec31"/>Limiting connections (HttpLimitConnModule)</h2></div></div></div><p>The <code class="literal">HttpLimitConnModule</code> makes<a id="id341" class="indexterm"/> it possible to limit the number of concurrent connections for a key such as an IP address.</p><p>An example configuration:</p><div class="informalexample"><pre class="programlisting">http {
    limit_conn_zone $binary_remote_addr zone=addr:10m;

    ...

    server {

        ...

        location /download/ {
            limit_conn addr 1;
        }</pre></div><div class="section" title="Explaining directives"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec46"/>Explaining directives</h3></div></div></div><p>Some of the important<a id="id342" class="indexterm"/> directives of <code class="literal">HttpLimitConnModule</code> are as follows:</p><div class="section" title="limit_conn"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec56"/>limit_conn</h4></div></div></div><p>The value of the <code class="literal">limit_conn</code> directive <a id="id343" class="indexterm"/>defines the limit <a id="id344" class="indexterm"/>of connection per zone. When this limit is exceeded, the server will return a status error <code class="literal">503</code> (Service Temporarily Unavailable) in reply to the request.</p><p>Multiple limit directives for different zones can be used in the same context. For example:</p><div class="informalexample"><pre class="programlisting">limit_conn_zone $binary_remote_addr zone=addr:10m;

server {
    location /download/ {
        limit_conn addr 1;
    }</pre></div><p>This is allowed for only a single connection at a time per unique IP address.</p></div><div class="section" title="limit_conn_zone"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec57"/>limit_conn_zone</h4></div></div></div><p>The <code class="literal">limit_conn_zone</code> directive<a id="id345" class="indexterm"/> sets the parameters for a zone that keeps the state for various keys. This state stores the current number<a id="id346" class="indexterm"/> of connections in particular. The key is the value of the specified variable. For example:</p><div class="informalexample"><pre class="programlisting">limit_conn_zone $binary_remote_addr zone=addr:10m;</pre></div><p>Here, an IP address of the client serves as a key. If the storage for a zone is exhausted, the server will return error <code class="literal">503</code> (Service Temporarily Unavailable) to all further requests.</p></div><div class="section" title="limit_conn_log_level"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec58"/>limit_conn_log_level</h4></div></div></div><p>The <code class="literal">limit_conn_log_level</code> directive<a id="id347" class="indexterm"/> sets the error log level, which is used when a connection<a id="id348" class="indexterm"/> limit is reached. The default log level is <code class="literal">error</code>.</p></div><div class="section" title="limit_conn_status"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec59"/>limit_conn_status</h4></div></div></div><p>The <code class="literal">limit_conn_status</code> directive <a id="id349" class="indexterm"/>defines the<a id="id350" class="indexterm"/> response code when a limit is reached. The default value is <code class="literal">503</code> (Service Unavailable).</p></div></div></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec15"/>Summary</h1></div></div></div><p>In this chapter we looked at several standard HTTP modules. These modules provide a very rich set of functionalities by default. You can disable these modules if you please at the time of configuration. However, they will be installed by default if you don't. The list of modules and their directives in this chapter is by no means exhaustive. Nginx's online documentation can provide you with more details.</p><p>In the next chapter we will look into some optional HTTP modules.
</p></div></body></html>