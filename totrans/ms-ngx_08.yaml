- en: Chapter 8. Troubleshooting Techniques
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章 排错技巧
- en: We live in an imperfect world. Despite our best intentions and planning, sometimes
    things don't turn out the way we had expected. We need to be able to step back
    and take a look at what went wrong. When we cannot immediately see what is causing
    the error, we need to be able to reach into a toolbox of techniques for helping
    us discover the problem. This process of figuring out what went wrong and how
    to fix it is what we call troubleshooting.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们生活在一个不完美的世界里。尽管我们尽力而为并做好了计划，但有时事情并不会按预期的方式发展。我们需要能够退一步，看看哪里出了问题。当我们无法立即看到是什么导致了错误时，我们需要能够利用一套工具箱中的技巧来帮助我们发现问题。这个找出问题并解决问题的过程就是我们所说的排错。
- en: 'In this chapter, we will explore different techniques for troubleshooting NGINX:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们将探索用于排错NGINX的不同技巧：
- en: Analyzing log files
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析日志文件
- en: Configuring advanced logging
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置高级日志记录
- en: Common configuration errors
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见配置错误
- en: Operating system limits
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统限制
- en: Performance problems
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能问题
- en: Using the Stub Status module
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Stub Status模块
- en: Analyzing log files
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析日志文件
- en: Before going into a prolonged debugging session trying to track down the cause
    of a problem, it is usually helpful to first look at the log files. They will
    often provide the clue we need to track down the error and correct it. The messages
    that appear in the `error_log` can sometimes be a bit cryptic, however, so we
    will discuss the format of the log entries and then take a look at a few examples
    to show you how to interpret what they mean.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始长时间的调试会话以追踪问题的根源之前，通常首先查看日志文件是很有帮助的。它们通常会提供我们需要的线索，帮助我们追踪错误并加以修正。然而，`error_log`中出现的消息有时可能会有点难以理解，因此我们将讨论日志条目的格式，然后通过一些示例帮助你理解它们的含义。
- en: Error log file formats
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误日志文件格式
- en: 'NGINX uses a couple of different logging functions that produce the `error_log`
    entries. The formats used with these functions take on the following patterns:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: NGINX使用几种不同的日志记录函数来生成`error_log`条目。这些函数使用的格式呈现以下模式：
- en: '*<timestamp> [log-level] <master/worker pid>#0: message*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*<timestamp> [log-level] <master/worker pid>#0: 消息*'
- en: 'For example:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is an example of informational messages (log level `notice`). In this case,
    an `nginx` binary has replaced a previously-running one, and was able to successfully
    inherit the old binary's sockets.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个信息性消息的示例（日志级别`notice`）。在这种情况下，一个`nginx`二进制文件替换了之前运行的二进制文件，并成功继承了旧二进制文件的套接字。
- en: 'The error-level logger produces a message like the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 错误级别的日志记录器会生成如下消息：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Depending on the error, you will see messages from the operating system (such
    as in this case), or just from NGINX itself. In this case, we see the following
    components:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 根据错误的不同，你可能会看到来自操作系统的消息（如本例所示），或者仅来自NGINX本身。在这种情况下，我们看到以下组件：
- en: timestamp (`2012/10/14 18:50:34`)
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间戳（`2012/10/14 18:50:34`）
- en: log level (`error`)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志级别（`error`）
- en: worker pid (`2632`)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作进程pid（`2632`）
- en: connection number (`1`)
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接编号（`1`）
- en: system call (`open`)
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统调用（`open`）
- en: argument to the system call (`/opt/nginx/html/blog`)
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统调用的参数（`/opt/nginx/html/blog`）
- en: 'error message resulting from the system call (`2: No such file or directory`)'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '系统调用产生的错误消息（`2: No such file or directory`）'
- en: which client made the request resulting in the error (`127.0.0.1`)
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪个客户端发起了导致错误的请求（`127.0.0.1`）
- en: which server context was responsible for handling the request (`www.example.com`)
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪个服务器上下文负责处理请求（`www.example.com`）
- en: the request itself (`GET /blog HTTP/1.0`)
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求本身（`GET /blog HTTP/1.0`）
- en: the `Host` header sent in the request (`www.example.com`)
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求中发送的`Host`头（`www.example.com`）
- en: 'Here is an example of a critical-level log entry:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个关键级别日志条目的示例：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A critical-level message means that NGINX cannot perform the requested action.
    If it was not already running, this means that NGINX would not start.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 关键级别消息意味着NGINX无法执行请求的操作。如果它尚未运行，则意味着NGINX将无法启动。
- en: 'Here is an example of an emergency message:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个紧急消息的示例：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: An emergency message also means that NGINX could not do what was requested.
    It also means that NGINX won't start, or if it was already running when asked
    to read the configuration, it won't perform the requested change.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 紧急消息也意味着NGINX无法执行请求的操作。这也意味着NGINX无法启动，或者如果在被要求读取配置时已经在运行，它也不会执行请求的更改。
- en: Note
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are wondering why your configuration change is not taking effect, check
    the error log. NGINX has most likely encountered an error in the configuration
    and has not applied the change.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道为什么配置更改没有生效，请检查错误日志。NGINX 很可能在配置中遇到了错误，并且没有应用更改。
- en: Error log file entry examples
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误日志文件条目示例
- en: The following are some examples of error messages found in real log files. After
    each example, a short explanation of what it could mean follows. Please note that
    the exact text may be different from what you see in your log files, due to improvements
    made in newer releases of NGINX.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些在实际日志文件中发现的错误信息示例。每个示例后面跟着一个简短的解释，说明可能的含义。请注意，由于 NGINX 在新版中的改进，您看到的文本可能与示例中的有所不同。
- en: 'Look at the following log file entry example:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下日志文件条目示例：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here we have a message that could be interpreted in a couple of ways. It might
    mean that the server we are talking to has an error in its implementation, and
    does not speak the FastCGI protocol properly. It could also mean that we have
    mistakenly directed traffic to an HTTP server, instead of a FastCGI server. If
    that is the case, a simple configuration change (using `proxy_pass` instead of
    `fastcgi_pass`, or using the correct address for the FastCGI server) could fix
    the problem.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们看到一条消息，它可以有几种解释。这可能意味着我们正在与之通信的服务器在实现上有错误，没有正确地使用 FastCGI 协议。也可能意味着我们错误地将流量指向了
    HTTP 服务器，而不是 FastCGI 服务器。如果是这种情况，简单的配置更改（使用 `proxy_pass` 替代 `fastcgi_pass`，或使用正确的
    FastCGI 服务器地址）可能会解决问题。
- en: 'This type of message could also simply mean that the upstream server takes
    too long to generate a response. The reason could be due to a number of factors,
    but the solution, as far as NGINX is concerned, is fairly simple: increase the
    timeouts. Depending on which module was responsible for making this connection,
    the `proxy_read_timeout` or `fastcgi_read_timeout` (or other `*_read_timeout`)
    directive would need to be increased from the default value of `60s`.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这类消息也可能仅仅意味着上游服务器生成响应的时间太长。造成这种情况的原因可能有很多，但就 NGINX 而言，解决方案相当简单：增加超时时间。根据哪个模块负责建立连接，可能需要将
    `proxy_read_timeout` 或 `fastcgi_read_timeout`（或其他 `*_read_timeout`）指令的默认值 `60s`
    增加。
- en: 'Look at the following log file entry example:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下日志文件条目示例：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This one is fairly straightforward. NGINX reports that the file could not be
    uploaded because it is too large. To fix this problem, raise the value of `client_body_size`.
    Keep in mind that due to encoding, the uploaded size will be about 30 percent
    greater than the file size itself (for example, if you want to allow your users
    to upload files up to 12 MB, set this directive to `16m`).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子比较直白。NGINX 报告文件无法上传，因为文件太大。要解决这个问题，增加 `client_body_size` 的值。请记住，由于编码原因，上传的文件大小将比实际文件大小大约
    30%。例如，如果你希望允许用户上传最大为 12 MB 的文件，则应将此指令设置为 `16m`。
- en: 'Look at the following log file entry example:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下日志文件条目示例：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this example, we see that NGINX won't start due to a configuration error.
    The error message is very informative as to why NGINX won't start. We see that
    there is a URI in the argument to the `proxy_pass` directive in a place where
    it should not have one. NGINX even tells us on which line (here `16`) of which
    file `(/opt/nginx/conf/nginx.conf`) the error occurred.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们看到 NGINX 无法启动，原因是配置错误。错误信息清楚地说明了为什么 NGINX 无法启动。我们看到在 `proxy_pass` 指令的参数中有一个
    URI，应该没有这个 URI。NGINX 甚至告诉我们错误发生在哪个文件（这里是 `/opt/nginx/conf/nginx.conf`）的第几行（这里是
    `16`）。
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is an example of a case where NGINX won't start because it can't perform
    what was asked of it. The `proxy_temp_path` directive specifies a location for
    NGINX to store temporary files when proxying. If NGINX cannot create this directory,
    it won't start, so ensure that the path leading up to this directory exists.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 NGINX 无法启动的例子，因为它无法执行所要求的操作。`proxy_temp_path` 指令指定了 NGINX 在代理时存储临时文件的位置。如果
    NGINX 无法创建这个目录，它就无法启动，因此请确保该目录的路径存在。
- en: 'Look at the following log file entry example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下日志文件条目示例：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We see in the preceding code what may appear to be a puzzling message. We know
    that `client_body_temp_path` is a valid directive, but NGINX does not accept it
    and gives an `unknown directive` message. When we think about how NGINX processes
    its configuration file, we realize that this does make sense after all. NGINX
    is built in a modular fashion. Each module is responsible for processing its own
    configuration context. We therefore conclude that this directive appeared in a
    part of the configuration file outside the context of the module that parses this
    directive.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们看到了一条可能令人困惑的消息。我们知道 `client_body_temp_path` 是一个有效的指令，但 NGINX 不接受它并给出了
    `unknown directive` 的提示。当我们思考 NGINX 如何处理其配置文件时，我们意识到这实际上是有道理的。NGINX 是以模块化的方式构建的，每个模块负责处理自己的配置上下文。因此，我们得出结论，这个指令出现在了解析该指令的模块上下文之外的部分。
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Sometimes, NGINX will give us a hint as to what is wrong. In the preceding example,
    NGINX has understood the `try_files` directive, but tells us that it is used in
    the wrong place. It very conveniently gives us the location in the configuration
    file where the error occurred, so that we can find it more easily.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，NGINX 会给我们一些提示，帮助我们找出问题所在。在前面的例子中，NGINX 已经理解了 `try_files` 指令，但告诉我们它被用在了错误的位置。它非常方便地给出了配置文件中出错的位置，帮助我们更容易地找到问题。
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This emergency-level message shows us how dependent NGINX is on DNS if hostnames
    are used in the configuration. If NGINX can't resolve the hostnames used in `upstream`,
    `proxy_pass`, `fastcgi_pass`, or other `*_pass` directives, then it won't start.
    This will have implications on the order in which NGINX is started after a fresh
    boot. Ensure that name resolution works at the time when NGINX starts.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这条紧急级别的消息告诉我们，如果配置中使用了主机名，NGINX 对 DNS 的依赖有多大。如果 NGINX 无法解析 `upstream`、`proxy_pass`、`fastcgi_pass`
    或其他 `*_pass` 指令中使用的主机名，那么它将无法启动。这会影响 NGINX 在系统重启后的启动顺序。确保在 NGINX 启动时，名称解析能正常工作。
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This type of message is indicative of a configuration error in which NGINX can't
    close the context. Something leading up to the line given has prevented NGINX
    from forming a complete context with the `{` and `}` characters. This usually
    means that the previous line is missing a semicolon, so NGINX reads the `}` character
    as part of that unfinished line.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的消息通常表示配置错误，NGINX 无法关闭上下文。在给定行之前的某个地方出现了问题，导致 NGINX 无法通过 `{` 和 `}` 字符形成完整的上下文。通常这意味着前一行缺少分号，导致
    NGINX 将 `}` 字符错误地读取为未完成行的一部分。
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Related to the previous error, this one means that NGINX reached the end of
    the configuration file before finding a matching closing brace. This kind of error
    occurs when there are unbalanced `{` and `}` characters. Using a text editor that
    matches sets of braces is helpful in locating exactly where one is missing. Depending
    on where that missing brace is inserted, the configuration can end up meaning
    something completely different from what was intended.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的错误相关，这个错误意味着 NGINX 在找到匹配的闭合括号之前就已经到达了配置文件的末尾。这种错误发生在存在不匹配的 `{` 和 `}` 字符时。使用能匹配括号对的文本编辑器有助于精确定位缺失的括号。根据缺失的括号插入的位置，配置文件可能会导致与原本意图完全不同的效果。
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here we see an example of using a variable without first declaring it. This
    means that `$exclusion` appeared in the configuration before a `set`, `map`, or
    `geo` directive defined what the value was to be. This type of error could also
    be indicative of a typo. We may have defined the `$exclusions` variable, but mistakenly
    later referenced it as `$exclusion`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到一个没有先声明变量就使用它的例子。这意味着 `$exclusion` 在配置文件中出现在 `set`、`map` 或 `geo` 指令定义其值之前。这类错误也可能是打字错误的表现。我们可能已经定义了
    `$exclusions` 变量，但后来错误地将它写作了 `$exclusion`。
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This means that you need to disable SSL session reuse. You can do this by setting
    the `proxy_ssl_session_reuse` directive to `off`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你需要禁用 SSL 会话重用。你可以通过将 `proxy_ssl_session_reuse` 指令设置为 `off` 来实现。
- en: Configuring advanced logging
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置高级日志记录
- en: Under normal circumstances, we want logging to be as minimal as possible. Usually
    what's important is which URIs were called by which clients and when, and if there
    was an error, to show the resulting error message. If we want to see more information,
    that leads into a debug logging configuration.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常情况下，我们希望日志记录尽可能简洁。通常，重要的是哪些 URI 被哪些客户端调用了，以及何时调用，如果出现错误，则显示相应的错误信息。如果我们希望查看更多信息，则需要配置调试日志。
- en: Debug logging
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试日志
- en: 'To activate debug logging, the `nginx` binary needs to have been compiled with
    the `--with-debug` configure flag. As this flag is not recommended for high performance
    production systems, we may want to provide two separate `nginx` binaries for our
    needs: one which we use in production, and one that has all the same configure
    options, with the addition of `--with-debug` so that we may simply swap out the
    binary at runtime in order to be able to debug.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用调试日志记录，`nginx` 二进制文件必须使用 `--with-debug` 配置标志进行编译。由于该标志不推荐用于高性能的生产系统，因此我们可能希望为我们的需求提供两个独立的
    `nginx` 二进制文件：一个用于生产环境，另一个则具备所有相同的配置选项，并额外添加 `--with-debug`，这样我们就可以在运行时简单地交换二进制文件来进行调试。
- en: Switching binaries at runtime
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在运行时切换二进制文件
- en: 'NGINX provides the capability to switch out binaries at runtime. After having
    replaced the `nginx` binary with a different one, either because we''re upgrading
    or we would like to load a new NGINX which has different modules compiled in,
    we can begin the procedure for replacing a running `nginx` binary:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: NGINX 提供了在运行时切换二进制文件的功能。在将 `nginx` 二进制文件替换为不同的版本后，无论是因为升级，还是因为我们想加载一个不同模块的 NGINX，我们可以开始替换正在运行的
    `nginx` 二进制文件的过程：
- en: 'Send the running NGINX master process a USR2 signal, to tell it to start a
    new master process. It will rename its PID file to `.oldbin` (for example, `/var/run/nginx.pid.oldbin`):'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向正在运行的 NGINX 主进程发送 USR2 信号，指示它启动一个新的主进程。它将把其 PID 文件重命名为 `.oldbin`（例如，`/var/run/nginx.pid.oldbin`）：
- en: '[PRE15]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'There will now be two NGINX master processes running, each with its own set
    of workers to handle incoming requests:'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在将有两个 NGINX 主进程在运行，每个进程都有一组工作进程来处理传入的请求：
- en: '[PRE16]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Send the old NGINX master process a WINCH signal to tell it to stop handling
    new requests, and phase out its worker processes once they are done with their
    current requests:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向旧的 NGINX 主进程发送 WINCH 信号，告知它停止处理新的请求，并在其完成当前请求后逐步结束工作进程：
- en: '[PRE17]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You''ll get the following response output:'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您将看到以下响应输出：
- en: '[PRE18]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Send the old NGINX master process a `QUIT` signal, once all its worker processes
    have ended, and we will have only the new `nginx` binary running, responding to
    requests:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向旧的 NGINX 主进程发送 `QUIT` 信号，等到所有的工作进程结束后，我们将只有新的 `nginx` 二进制文件在运行，并且响应请求：
- en: '[PRE19]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If there is any problem with the new binary, we can roll back to the old one
    before sending the `QUIT` signal to the old binary:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果新的二进制文件有任何问题，在向旧的二进制文件发送 `QUIT` 信号之前，我们可以回滚到旧版本：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If the new binary still has a master process running, you can send it a `TERM`
    signal to force it to quit:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果新的二进制文件仍有主进程在运行，您可以向它发送 `TERM` 信号，强制它退出：
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Likewise, any new worker processes that are still running may first be stopped
    with a `KILL` signal.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，任何仍在运行的新的工作进程可以先通过 `KILL` 信号停止。
- en: Note
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that some operating systems will automatically perform the binary upgrade
    procedure for you when the `nginx` package is upgraded.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，某些操作系统在升级 `nginx` 包时，会自动为您执行二进制文件升级过程。
- en: 'Once we have our debug-enabled `nginx` binary running, we can configure debug
    logging:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行了启用调试的 `nginx` 二进制文件，我们可以配置调试日志记录：
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We have placed the `error_log` directive in the main context of the NGINX configuration,
    so that it will be valid for each subcontext, if not overwritten within. We can
    have multiple `error_log` directives, each pointing to a different file and with
    a different logging level. In addition to `debug`, `error_log` can also take on
    the following values:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将 `error_log` 指令放置在 NGINX 配置的主上下文中，这样它将在每个子上下文中有效，除非在其中被覆盖。我们可以有多个 `error_log`
    指令，每个指向不同的文件，并且使用不同的日志级别。除了 `debug`，`error_log` 还可以使用以下值：
- en: '`debug_core`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`debug_core`'
- en: '`debug_alloc`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`debug_alloc`'
- en: '`debug_mutex`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`debug_mutex`'
- en: '`debug_event`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`debug_event`'
- en: '`debug_http`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`debug_http`'
- en: '`debug_imap`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`debug_imap`'
- en: Each level is to debug a specific module within NGINX.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 每个级别都是为了调试 NGINX 内部的特定模块。
- en: 'It also makes sense to configure a separate error log per virtual server. That
    way, the errors related only to that server are found in a specific log. This
    concept can be extended to include the `core` and `http` modules as well:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，为每个虚拟服务器配置单独的错误日志也是有意义的。这样，仅与该服务器相关的错误将被记录在特定的日志中。这个概念也可以扩展到 `core` 和 `http`
    模块：
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Using this pattern, we are able to debug a particular virtual host, if that
    is the area we are interested in:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种模式，我们能够调试特定的虚拟主机，如果这是我们感兴趣的区域：
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'What follows is an example of `debug_http` level output from a single request.
    Some comments as to what is going on at each point are interspersed throughout:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是单个请求的 `debug_http` 级别输出示例。每个点上发生的事情在中间穿插了一些注释：
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `rewrite` module is activated very early on in the request processing phase:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`rewrite` 模块在请求处理阶段非常早期就被激活：'
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Access restrictions are checked:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 检查访问限制：
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `try_files` directive is parsed next. The path to the file is constructed
    from any string (`http script copy`) plus the value of any variable (`http script
    var`) in the parameters to the `try_files` directive:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来解析 `try_files` 指令。文件的路径是通过任何字符串（`http script copy`）加上任何变量（`http script var`）的值来构建的，这些变量在
    `try_files` 指令的参数中：
- en: '[PRE28]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The evaluated parameter is then concatenated with the `alias` or `root` for
    that `location`, and the full path to the file is found:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，评估后的参数与该 `location` 的 `alias` 或 `root` 连接，找到文件的完整路径：
- en: '[PRE29]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Once the file is found, its contents are processed:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦文件被找到，它的内容将被处理：
- en: '[PRE30]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `http filename` is the full path to the file to be sent:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`http filename` 是要发送的文件的完整路径：'
- en: '[PRE31]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `static` module receives the file descriptor for this file:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`static` 模块接收到此文件的文件描述符：'
- en: '[PRE32]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Any temporary content in the body of the response is no longer needed:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 响应体中的任何临时内容不再需要：
- en: '[PRE33]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Once all information about the file is known, NGINX can construct the full
    response headers:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦知道了文件的所有信息，NGINX 就可以构建完整的响应头：
- en: '[PRE34]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The next phase involves any transformations to be performed on the file due
    to output filters that may be active:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的阶段涉及对文件进行任何变换，这可能是由于输出过滤器的作用：
- en: '[PRE35]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Once the output filters have run, the request is finalized:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦输出过滤器运行完毕，请求就完成了：
- en: '[PRE36]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `keepalive` handler is responsible for determining if the connection should
    remain open:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`keepalive` 处理器负责判断连接是否应该保持打开：'
- en: '[PRE37]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'After the request has been processed, it can then be logged:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在请求处理完毕后，它可以被记录：
- en: '[PRE38]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The client has closed the connection, so NGINX will as well:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端已关闭连接，因此 NGINX 也将关闭连接：
- en: '[PRE39]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As you can see, there is quite a bit of information included here. If you have
    trouble figuring out why a particular configuration isn't working, going through
    the output of the debug log can be helpful. You can immediately see in what order
    the various filters run, as well as what handlers are involved in serving the
    request.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这里包含了相当多的信息。如果你在弄清楚为什么某个配置不起作用时遇到困难，查看调试日志的输出可能会有所帮助。你可以立即看到各种过滤器运行的顺序，以及哪些处理器参与了请求的服务。
- en: Using access logs for debugging
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用访问日志进行调试
- en: When I was learning how to program, and couldn't find the source of a problem,
    a friend of mine told me to "put printf's everywhere". That was how he was most
    quickly able to find the source of a problem. What he meant by this was to place
    a statement that would print a message at each code branch point, so that we could
    see which code path was getting executed and where the logic was breaking down.
    By doing this, we could visualize what was going on and could more easily see
    where the problem lies.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在学习编程时，无法找到问题的源头时，我的一个朋友告诉我“到处加上 printf”。这就是他最迅速找到问题源头的方法。他的意思是，在每个代码分支点放一个会打印消息的语句，这样我们可以看到哪个代码路径被执行，逻辑在哪里出错。通过这样做，我们能够可视化发生了什么，并更容易找到问题所在。
- en: 'This same principle can be applied to configuring NGINX. Instead of `printf()`
    we can use the `log_format` and `access_log` directives to visualize request flow
    and analyze what''s going on during request processing. Use the `log_format` directive
    to see the values of variables at different points in the configuration:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的原理也可以应用于配置 NGINX。我们可以用 `log_format` 和 `access_log` 指令来代替 `printf()`，以可视化请求流并分析请求处理过程中的情况。使用
    `log_format` 指令可以查看配置中不同点的变量值：
- en: '[PRE40]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Use multiple `access_logs` to see which locations are getting called at what
    times. By configuring a different `access_log` for each location, we can easily
    see which ones are not being used. Any change to such a location will have no
    effect on request processing; the locations higher-up in the processing hierarchy
    need to be examined first.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多个 `access_logs` 来查看哪些位置在什么时间被调用。通过为每个位置配置不同的 `access_log`，我们可以轻松看到哪些位置未被使用。对这些位置的任何更改都不会影响请求处理；应首先检查处理层次结构中较高的那些位置。
- en: '[PRE41]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the preceding example, there is an `access_log` declaration for each location,
    as well as a different `log_format` for each `access_log` declaration. We can
    determine which requests made it to each location depending on the entries found
    in the corresponding `access_log`. If there are no entries in the `example.com-images_access.log`
    file, for example, then we know that no requests reached the `/images` location.
    We can compare the contents of the various log files to see if the variables are
    being set to the proper values. For example, if the `$image_file` and `$image_type`
    variables are empty, the corresponding placeholders in the `imagelog` format `access_log`
    will be empty.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，每个位置都有一个`access_log`声明，并且每个`access_log`声明都有一个不同的`log_format`。我们可以根据相应`access_log`中的条目确定哪些请求到达了各个位置。例如，如果在`example.com-images_access.log`文件中没有条目，那么我们就知道没有请求到达`/images`位置。我们可以比较不同日志文件的内容，看看变量是否被设置为正确的值。例如，如果`$image_file`和`$image_type`变量为空，`imagelog`格式的`access_log`中相应的占位符也会为空。
- en: Common configuration errors
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见的配置错误
- en: The next step in troubleshooting a problem is to take a look at the configuration,
    to see if it actually achieves the goal you are trying to accomplish. NGINX configurations
    have been floating around the Internet for a number of years. Often, they were
    designed for an older version of NGINX, and to solve a specific problem. Unfortunately,
    these configurations are copied without really understanding the problem they
    were designed to solve. There is sometimes a better way to solve the same problem,
    using a *newer* configuration.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 故障排除的下一步是检查配置，看看它是否确实达到了你想要实现的目标。NGINX配置已经在互联网上流传了多年。通常，这些配置是为较旧版本的NGINX设计的，用于解决特定问题。不幸的是，这些配置常常是被复制而没有真正理解它们最初设计的目的。有时，可以使用*更新*的配置来更好地解决同样的问题。
- en: Using if instead of try_files
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`if`代替`try_files`
- en: 'One such case is a situation in which a user wants to deliver a static file
    if it is found on the filesystem, and if not, to pass the request on to a FastCGI
    server:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个例子是用户希望在文件系统中找到静态文件时提供该文件，如果未找到，则将请求传递给FastCGI服务器：
- en: '[PRE42]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This was the way this problem was commonly solved before NGINX had the `try_files`
    directive, which appeared in Version 0.7.27\. The reason why this is considered
    a configuration error is that it involves using `if` within a `location` directive.
    As detailed in the *Converting an "if"-fy configuration to a more modern interpretation*
    section in [Chapter 4](ch04.html "Chapter 4. NGINX as a Reverse Proxy"), *NGINX
    as a Reverse Proxy*, this can lead to unexpected results or possibly even a crash.
    The way to correctly solve this problem is as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在NGINX没有`try_files`指令（该指令出现在版本0.7.27）之前，通常解决此问题的方式。之所以认为这是一个配置错误，是因为它涉及在`location`指令中使用`if`。正如在[第4章](ch04.html
    "第4章. NGINX作为反向代理")的*将“if”-fy配置转换为更现代的解释*部分中详细说明的那样，*NGINX作为反向代理*，这可能导致意外结果，甚至可能引发崩溃。正确解决此问题的方法如下：
- en: '[PRE43]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `try_files` directive is used to determine if the file exists on the filesystem,
    and if not, passes the request on to the FastCGI server, without using `if`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`try_files`指令用于检查文件是否存在于文件系统中，如果没有找到，则将请求传递给FastCGI服务器，而无需使用`if`。'
- en: Using if as a hostname switch
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将`if`用作主机名切换
- en: 'There are countless examples of configurations where `if` is used to redirect
    requests based on the HTTP `Host` header. These types of configurations work as
    selectors and are evaluated for each request:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多配置示例，使用`if`根据HTTP `Host`头部重定向请求。这些类型的配置充当选择器，并会为每个请求进行评估：
- en: '[PRE44]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Instead of incurring the processing costs associated with evaluating `if` for
    each request, NGINX''s normal request-matching routine can route the request to
    the correct virtual server. The redirect can then be placed where it belongs,
    and even without a rewrite:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 与其为每个请求评估`if`而承担处理开销，NGINX的常规请求匹配机制可以将请求路由到正确的虚拟服务器。然后，可以将重定向放在适当的位置，甚至无需重写：
- en: '[PRE45]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Not using the server context to best effect
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 未充分利用服务器上下文
- en: Another place where copied configuration snippets often lead to incorrect configurations
    is the area of the `server` context. The `server` context describes the whole
    virtual server (everything that should be addressed under a particular `server_name`).
    It is underutilized in these copied configuration snippets.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 复制的配置片段经常导致不正确配置的另一个地方是`server`上下文区域。`server`上下文描述了整个虚拟服务器（应该在特定的`server_name`下处理的所有内容）。在这些复制的配置片段中，它的使用不够充分。
- en: 'Often, we will see `root` and `index` specified per `location`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们会看到`root`和`index`在每个`location`中指定：
- en: '[PRE46]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This can lead to configuration errors when new locations are added, and the
    directives are not copied to those new locations or are copied incorrectly. The
    point of using the `root` and `index` directives is to indicate the document root
    for the virtual server and the files that should be tried when a directory is
    given in the URI, respectively. These values are then inherited for any `location`
    within that `server` context.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当添加新位置时，这可能会导致配置错误，如果没有将指令复制到这些新位置，或者复制不正确。使用`root`和`index`指令的目的是分别指示虚拟服务器的文档根目录和在URI中给定目录时应该尝试的文件。这些值随后会被继承到该`server`上下文中的任何`location`。
- en: '[PRE47]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Here, we have specified that all files will be found under `/var/www/html` and
    that `index.php index.html index.htm` are to be tried, in order, as `index` files
    for any location.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已指定所有文件将位于`/var/www/html`下，并且`index.php index.html index.htm`将按顺序作为任何位置的`index`文件进行尝试。
- en: Operating system limits
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作系统限制
- en: The operating system is often the last place we look to for discovering a problem.
    We assume that whoever set up the system has tuned the operating system for our
    workload and tested it under similar scenarios. This is often not the case. We
    sometimes need to look into the operating system itself to identify a bottleneck.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统通常是我们寻找问题的最后一个地方。我们假设设置系统的人已经根据我们的工作负载调整了操作系统，并在类似场景下进行了测试。但实际上，这并非总是如此。有时我们需要深入操作系统本身，以识别瓶颈。
- en: 'As with NGINX, there are two major areas where we can initially look for performance
    problems: **file descriptor limits** and **network limits**.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 与NGINX一样，我们可以首先从两个主要领域查找性能问题：**文件描述符限制**和**网络限制**。
- en: File descriptor limits
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件描述符限制
- en: NGINX uses file descriptors in several different ways. The major use is to respond
    to client connections, each one using a file descriptor. Each outgoing connection
    (especially prevalent in proxy configurations) requires a unique IP:TCP port pair,
    which NGINX refers to using a file descriptor. If NGINX is serving any static
    file or a response from its cache, a file descriptor is used as well. As you can
    see, the number of file descriptors can climb quickly with the number of concurrent
    users. The total number of file descriptors that NGINX may use is limited by the
    operating system.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: NGINX以多种方式使用文件描述符。主要用途是响应客户端连接，每个连接都使用一个文件描述符。每个外部连接（尤其是在代理配置中）都需要一个唯一的IP:TCP端口对，NGINX通过文件描述符来引用它。若NGINX正在提供任何静态文件或其缓存中的响应，也会使用文件描述符。正如您所看到的，随着并发用户数量的增加，文件描述符的数量会迅速增加。NGINX可以使用的文件描述符总数受到操作系统的限制。
- en: The typical UNIX-like operating system has a different set of limits for the
    superuser (`root`) than for a regular user, so make sure to execute the following
    command as the non-privileged user under which you're running NGINX (specified
    either by the `--user` compile-time option or the `user` configuration directive).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的类UNIX操作系统为超级用户（`root`）与普通用户设定了不同的限制，因此请确保以运行NGINX的非特权用户身份执行以下命令（该用户由`--user`编译时选项或`user`配置指令指定）。
- en: '[PRE48]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This command will show you the number of open file descriptors allowed for
    that user. Usually, this number is set conservatively to 1024 or even lower. Since
    we know that NGINX will be the major user of file descriptors on the machine,
    we can set this number much higher. How to do this depends on the specific operating
    system. This can be done as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将显示该用户允许的打开文件描述符的数量。通常，这个数字保守地设置为1024甚至更低。由于我们知道NGINX将是机器上文件描述符的主要使用者，我们可以将此数字设置得更高。如何设置取决于具体的操作系统。可以按照以下方式进行：
- en: Linux
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux
- en: '[PRE49]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: FreeBSD
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FreeBSD
- en: '[PRE50]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Solaris
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Solaris
- en: '[PRE51]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The preceding two commands will increase the maximum number of file descriptors
    allowed for a new process running as user `www`. This will also persist across
    a reboot.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 上述两个命令将增加以`www`用户身份运行的新进程允许的最大文件描述符数量。此设置在重启后也会保持有效。
- en: 'The following two commands will increase the maximum number of file descriptors
    allowed for a running NGINX process:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个命令将增加运行中的 NGINX 进程允许的最大文件描述符数：
- en: '[PRE52]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Each of these methods will change the operating system limit itself, but will
    have no effect on the running NGINX process. To enable NGINX to use the number
    of file descriptors specified, set the `worker_rlimit_nofile` directive to this
    new limit:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法中的每一种都会改变操作系统的限制，但对正在运行的 NGINX 进程没有影响。为了让 NGINX 使用指定数量的文件描述符，可以将 `worker_rlimit_nofile`
    指令设置为这个新限制：
- en: '[PRE53]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, send the running `nginx` master process the `HUP` signal:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，向正在运行的 `nginx` 主进程发送 `HUP` 信号：
- en: '[PRE54]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: NGINX will then be able to handle just over 65,000 simultaneous clients, connections
    to upstream servers, and any local static or cached files. This many `worker_processes`
    only makes sense if you actually have eight CPU cores or are heavily I/O bound.
    If that is not the case, decrease the number of `worker_processes` to match the
    number of CPU cores and increase `worker_connections` so that the product of the
    two approaches 65,000.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: NGINX 将能够处理超过 65,000 个并发客户端、连接到上游服务器以及任何本地静态或缓存文件。如果您实际拥有 8 个 CPU 核心或面临严重的 I/O
    限制，那么使用如此多的 `worker_processes` 是有意义的。如果不是这种情况，则应减少 `worker_processes` 的数量，以匹配
    CPU 核心数，并增加 `worker_connections`，使得两者的乘积接近 65,000。
- en: You can, of course, increase the number of total file descriptors and `worker_connections`
    up to a limit that makes sense for your hardware and use case. NGINX is capable
    of handling millions of simultaneous connections, provided the operating system
    limits and configuration are set correctly.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您可以将总文件描述符数量和 `worker_connections` 增加到适合硬件和使用场景的合理限制。只要操作系统限制和配置正确设置，NGINX
    完全有能力处理数百万个并发连接。
- en: Network limits
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络限制
- en: 'If you find yourself in a situation in which no network buffers are available,
    you will most likely only be able to log in at the console, if at all. This can
    happen when NGINX receives so many client connections that all available network
    buffers are used up. Increasing the number of network buffers is also specific
    to a particular operating system and may be done as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您发现自己处于没有可用网络缓冲区的情况，您很可能只能通过控制台登录（如果能登录的话）。这种情况可能发生在 NGINX 接收到大量客户端连接，以至于所有可用的网络缓冲区都被用尽。增加网络缓冲区的数量也是特定于操作系统的，通常可以通过以下方式进行：
- en: FreeBSD
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FreeBSD
- en: '[PRE55]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Solaris
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Solaris
- en: '[PRE56]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: When NGINX is acting as either a mail or an HTTP proxy, it will need to open
    many connections to its upstream servers. To enable as many connections as possible,
    the ephemeral TCP port range should be adjusted to its maximum.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当 NGINX 作为邮件或 HTTP 代理时，它需要与上游服务器建立许多连接。为了尽可能多地启用连接，应该将临时 TCP 端口范围调整到最大值。
- en: Linux
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux
- en: '[PRE57]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: FreeBSD
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FreeBSD
- en: '[PRE58]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Solaris
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Solaris
- en: '[PRE59]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Having adjusted these basic values, we will now take a look at more specific
    performance-related parameters in the next section.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 调整了这些基本值后，我们将在下一节中查看更具体的与性能相关的参数。
- en: Performance problems
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能问题
- en: When designing an application and configuring NGINX to deliver it, we expect
    it to perform well. When we experience performance problems, however, we need
    to take a look at what could cause them. It may be in the application itself.
    It may be our NGINX configuration. We will investigate how to discover where the
    problem lies.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计应用程序并配置 NGINX 来提供服务时，我们期望它能良好运行。然而，当我们遇到性能问题时，我们需要检查可能导致问题的原因。问题可能出在应用程序本身，也可能出在我们的
    NGINX 配置上。我们将研究如何发现问题所在。
- en: When proxying, NGINX does most of its work over the network. If there are any
    limitations at the network level, NGINX cannot perform optimally. Network tuning
    is again specific to the operating system and network that you are running NGINX
    on, so these tuning parameters should be examined in your particular situation.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在代理时，NGINX 大部分工作是在网络上进行的。如果在网络层面存在任何限制，NGINX 就无法达到最佳性能。网络调优同样是特定于运行 NGINX 的操作系统和网络环境的，因此在具体情况下应检查这些调优参数。
- en: One of the most important values relating to network performance is the size
    of the `listen` queue for new TCP connections. This number should be increased
    to enable more clients. Exactly how to do this and what value to use depends on
    the operating system and optimization goal.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 与网络性能相关的最重要的值之一是新 TCP 连接的 `listen` 队列大小。此数值应增加，以便支持更多的客户端。如何进行此操作以及使用什么值，取决于操作系统和优化目标。
- en: Linux
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux
- en: '[PRE60]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: FreeBSD
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FreeBSD
- en: '[PRE61]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Solaris
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Solaris
- en: '[PRE62]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The next parameter to change is the size of the send and receive buffers. Note
    that these values are for illustration purposes only— they may lead to excessive
    memory usage, so be sure to test in your specific scenario.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Linux
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: FreeBSD
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Solaris
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'You can also change these buffers in NGINX''s configuration directly, so that
    they are only valid for NGINX and not for any other software you are running on
    the machine. This may be desirable when you have multiple services running, but
    want to ensure that NGINX gets the most out of your network stack:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Depending on your network setup, you will notice a marked change in performance.
    You should examine your particular setup, though, and make one change at a time,
    observing the results after each change. Performance tuning can be done on so
    many different levels that this small treatment here does not do the subject justice.
    If you are interested in learning more about performance tuning, there are a number
    of books and online resources that you should take a look at.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Making network tuning changes in Solaris persistent**'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: In the previous two sections, we changed several TCP-level parameters on the
    command line. For Linux and FreeBSD, these changes would be persisted after a
    reboot due to the changes also being made in system configuration files (for example,
    `/etc/sysctl.conf`). For Solaris, the situation is different. These changes are
    not made in `sysctls`, so they cannot be persisted in this file.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Solaris 10 and above offers the **Service Management Framework** (**SMF**).
    This is a unique way of managing services and ensuring a start order at reboot.
    (Of course, it is much more than this, but this oversimplification serves here.)
    To persist the TCP-level changes mentioned before, we can write an SMF manifest
    and corresponding script to apply the changes.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: These are detailed in [Appendix D](apd.html "Appendix D. Persisting Solaris
    Network Tunings"), *Persisting Solaris Network Tunings*.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Using the Stub Status module
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NGINX provides an introspection module, which outputs certain statistics about
    how it is running. This module is called **Stub Status** and is enabled with the
    `--with-http_stub_status_module` configure flag.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the statistics produced by this module, the `stub_status` directive
    needs to be set to `on`. A separate `location` directive should be created for
    this module, so that an ACL may be applied:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Calling this URI from the localhost (for example, with `curl` `http://localhost/nginx_status`)
    will show output similar to the following lines:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Here we see that there are 2,532 open connections, of which NGINX is currently
    reading the request header of 93, and 13 connections are in a state in which NGINX
    is either reading the request body, processing the request, or writing a response
    to the client. The remaining 2,426 requests are considered `keepalive` connections.
    Since this `nginx` process was started, it has both accepted and handled 1,476,737,983
    connections, meaning that none were closed immediately after having been accepted.
    There were a total of 3,553,635,810 requests handled through these 1,476,737,983
    connections, meaning there were approximately 2.4 requests per connection.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: This kind of data can be collected and graphed using your favorite system metrics
    tool chain. There are plugins for Munin, Nagios, collectd, and others, which use
    the `stub_status` module to collect statistics. Over time, you may notice certain
    trends and be able to correlate them to specific factors, but only if the data
    is collected. Spikes in user traffic as well as changes in the operating system
    should be visible in these graphs.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problems surface on a number of levels when bringing a new piece of software
    into production. Some errors can be tested for and eradicated in a test environment;
    others surface only under real load with real users. To discover the reasons for
    these problems, NGINX provides very detailed logging, at a number of levels. Some
    of the messages may have multiple interpretations, but the overall pattern is
    understandable. By experimenting with the configuration and seeing what kinds
    of error messages are produced, we can gain a feeling for how to interpret the
    entries in the error log. The operating system has an influence on how NGINX runs,
    as it imposes certain limits due to default settings for a multiuser system. Understanding
    what is going on at the TCP level will help when tuning these parameters to meet
    the load under real conditions. Rounding off our tour of troubleshooting, we saw
    what kind of information the `stub_status` module was capable of delivering. This
    data can be useful to get an overall idea for how our NGINX is performing.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: The appendices are up next. The first is a directive reference, listing all
    of NGINX's configuration directives in one place, including default values and
    in which context they may be used.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
