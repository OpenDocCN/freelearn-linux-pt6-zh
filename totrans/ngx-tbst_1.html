<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Searching for Problems in Nginx Configuration"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Searching for Problems in Nginx Configuration</h1></div></div></div><p>Nginx is a <a class="indexterm" id="id0"/>complex piece of software that will help you implement your own part of the World Wide Web—one of the killer applications of the Internet as a whole. Although seeming to be simple, the Web and the underlying HTTP have a lot of intricate details that may require special attention. Nginx gives you the power to pay that attention to those details by means of the extensive configuration language. Following the grand UNIX tradition of human-readable and writable text configuration files, Nginx expects a certain level of understanding and zeal from you so that it can serve in the best way possible. It also means that there is freedom and huge potential for mistakes.</p><p>The main goal of this chapter is to lead you through the way Nginx is configured and show you some of the areas that are prone to errors.</p><p>You will find further:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Configuration syntax with description and examples</li><li class="listitem" style="list-style-type: disc">Description of all files in the default configuration bundled with Nginx</li><li class="listitem" style="list-style-type: disc">Some mistakes you could make with examples from the default configuration and techniques to avoid them</li></ul></div><div class="section" title="Introducing basic configuration syntax, directives, and testing"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Introducing basic configuration syntax, directives, and testing</h1></div></div></div><p>Igor Sysoev, the <a class="indexterm" id="id1"/>principal author of Nginx, said, on several occasions, that he designed the Nginx configuration language in such a way that writing the <a class="indexterm" id="id2"/>configuration should not feel like programming, or actual coding. For a long time, he himself worked as a professional system administrator for several relatively big websites in Russia. He understood perfectly that the goal of a website administrator is not to end up with beautiful, elegant configurations or to have at one's disposal every imaginable function for all possible situations no matter how rare they are. The goal is to be able to declaratively describe the business requirements, to formulate which behavior is needed without delving into how that could be achieved in software. One interesting example of quite the opposite idea in language design is the Lighttpd configuration language, but that's out of the scope of this book. </p><p>This is <a class="indexterm" id="id3"/>what we <a class="indexterm" id="id4"/>have now—a simple declarative language inspired by Apache's one but without all the XML-like tags. Open the default <code class="literal">nginx.conf</code> file to see what Nginx configuration looks like. Some distributions contain their own modifications to the default file. We will use the one from the<a class="indexterm" id="id5"/> original tarball available at <a class="ulink" href="http://nginx.org/download/nginx-1.9.12.tar.gz">http://nginx.org/download/nginx-1.9.12.tar.gz</a>. What follows is a quick syntax introduction using parts of that file as examples. You might find it too obvious but bear with us; even the most experienced reader will do good to refresh his or her memory.</p><p>Let us look at the very beginning of the file. Lines starting with <code class="literal">#</code> are comments, and they are ignored. <span class="emphasis"><em>Commenting out</em></span> is a very common technique to make Nginx ignore a part of configuration. The topmost line in default Nginx configuration file (as of version 1.9.12) is actually commented out:</p><div class="informalexample"><pre class="programlisting">...
#user  nobody;
...</pre></div><p>One easy way to comment out a block of lines in vim is highlighting them visually with <span class="emphasis"><em>Shift-V</em></span> and then issuing the <code class="literal">:s/^/#/ ex</code> command. In Emacs, just select a region and then press <span class="emphasis"><em>M-;</em></span>.</p><p>Nonempty noncommented lines in Nginx configuration are of the two following types.</p><div class="section" title="Simple directives"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec07"/>Simple directives </h2></div></div></div><p>Simple directives <a class="indexterm" id="id6"/>consist of a command word followed by a number of parameters and a semicolon. For example (see at the top of the default <code class="literal">nginx.conf</code> file):</p><div class="informalexample"><pre class="programlisting">...
worker_processes  1;
...</pre></div><p>Nothing to worry about here. People having too much experience with modern scripting languages, such as Python and Ruby, tend to forget the semicolon; we advise you to make sure that you add it.</p><p>The parameters mentioned here can be either constant values (numbers or strings, which does not matter, they are all parsed in the same way at this level) or they may contain variables. Variables in Nginx are the <code class="literal">$dollar_prefixed</code> identifiers that are replaced with some actual value at runtime. For example, there are variables containing data from an HTTP request, and you can modify website behavior depending on their values or just log them.</p><p>A very good example<a class="indexterm" id="id7"/> of variables in the default <code class="literal">nginx.conf</code> file is this:</p><div class="informalexample"><pre class="programlisting">...
#log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
#                  '$status $body_bytes_sent "$http_referer" '
#                  '"$http_user_agent" "$http_x_forwarded_for"';
...</pre></div><p>This directive creates a log format by constructing a template for each line of the log. It uses a number of variables available during the request/response cycle.</p></div><div class="section" title="Multiline directives"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec08"/>Multiline directives</h2></div></div></div><p>Multiline directives <a class="indexterm" id="id8"/>are simple directives with a BUT. Instead of a semicolon in the end, there is a block enclosed in braces <code class="literal">{ ... }</code>. And here <span class="emphasis"><em>instead</em></span> is meant literally. You don't put semicolons after closing braces. Those of you with just enough experience with more traditional C-like syntax programming languages will find this very natural.</p><p>Here is an example of the very first multiline directive in the default Nginx 1.9.12 <code class="literal">nginx.conf</code> file:</p><div class="informalexample"><pre class="programlisting">events {
    worker_connections  1024;
}</pre></div><p>Now, this is an <code class="literal">events</code> directive, which does not have any parameters, and it contains a block instead of a semicolon. Because of these blocks, multiline directives are also named "block directives". Blocks contain various kinds of content, but one of the most important and interesting blocks is the one containing other directives—both simple and multiline.</p><p>In the previous example, the block of the <code class="literal">events</code> directive contains a simple <code class="literal">worker_connections</code> directive.</p><p>Multiline directives that allow other directives inside their blocks are named "contexts". They introduce new context for the enclosed, inner part of the configuration.</p><p>Most of the multiline directives are actually contexts—from the most popular, such as <code class="literal">server</code> or <code class="literal">location</code>, to the most obscure, such as <code class="literal">limit_except</code>. An example of a multiline directive that is not a context is <code class="literal">types</code>, which introduces the relation between file extensions and the so-called <a class="indexterm" id="id9"/>
<span class="strong"><strong>Multipurpose Internet Mail Extensions</strong></span> (<span class="strong"><strong>MIME</strong></span>) types. We will look at <code class="literal">types</code> later in this chapter.</p><p>Contexts are <a class="indexterm" id="id10"/>very important. They are scopes and topics of the directives that are inside. If a command is not included in any multiline directive block, then it is considered part of the special context named "main" with the widest scope. Directives in this context affect the whole Nginx application. Other contexts are all either inside "main" or even deeper below, and the commands that are contained within those contexts have narrower scopes and affect only parts of the whole.</p></div><div class="section" title="Include directive"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec09"/>Include directive</h2></div></div></div><p>We will not<a class="indexterm" id="id11"/> describe actual directives here except for one of them. It is the <code class="literal">include</code> directive, a special dear to the hearts of all sysadmins who scale their work to many websites, servers, or just URLs. It is a very simple block-level "package management tool" if we are allowed to use more programming terminology. This simple directive has one parameter, that is, a filename or a wild card (UNIX glob-style) matching a number of files. During processing, this directive is replaced by the contents of the files it refers to. A quick example (from the default <code class="literal">nginx.conf</code> file):</p><div class="informalexample"><pre class="programlisting">...
include fastcgi_params;
...</pre></div><p>We won't offend you by spending more time on explaining <code class="literal">include</code>. What we need to add is that included files have to be fully correct syntactically. You cannot have half of a command in one file and then include the rest from another.</p><p>So, this is it, the whole syntax is described. Let us show you a fictional piece of configuration that demonstrates everything but does not actually work because it contains nonexistent directives (or maybe those are from some future version of Nginx):</p><div class="informalexample"><pre class="programlisting">...
simple_command 4 "two";
# another_simple_command 0;

special_context {
    some_special_command /new/path;
    multiline_directive param {
        1 2 3 5 8 13;
    }
    include common_parameters;
}
...</pre></div></div></div></div>
<div class="section" title="Testing Nginx configuration"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Testing Nginx configuration</h1></div></div></div><p>There is a <a class="indexterm" id="id12"/>very handy tool in the Nginx kit, a syntax checker for the configuration files. It is built into the main Nginx executable application and invoked by using the <code class="literal">-t</code> command-line switch as follows:</p><div class="informalexample"><pre class="programlisting">...
% nginx -t
nginx: the configuration file /etc/nginx/nginx.conf syntax is ok
nginx: configuration file /etc/nginx/nginx.conf test is successful
...</pre></div><p>The command <code class="literal">nginx -t</code> tries to check your configuration quite thoroughly. For example, it will check all the included files and try to access all the auxiliary files like logs or pids to warn you about their nonexistence or insufficient permissions. You will become a better Nginx administrator if you acquire a habit of frequently running <code class="literal">nginx -t</code>.</p><div class="section" title="The default configuration directory layout"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec10"/>The default configuration directory layout</h2></div></div></div><p>We <a class="indexterm" id="id13"/>will now run through the entire configuration that you get bundled with Nginx by default. Some of it is a good example from which you will start writing your own. Some of it is just a sign of Nginx age. Again, we use the original tarball for the 1.9.12 version that is available on the official Nginx website.</p><p>This is a list of files inside the <code class="literal">conf</code> folder of the Nginx source archive:</p><div class="informalexample"><pre class="programlisting">...
% ls
fastcgi.conf    koi-utf  mime.types  scgi_params   win-utf
fastcgi_params  koi-win  nginx.conf  uwsgi_params
...</pre></div><p>The <code class="literal">nginx.conf </code>is the main file, the one everything starts with. All other files are either included from <code class="literal">nginx.conf</code> or not used at all. Actually, <code class="literal">nginx.conf</code> is the only configuration file that is required by Nginx code (and you can override even that by using <code class="literal">-c</code> command-line switch). We will discuss its content a little bit later.</p><p>A pair of <code class="literal">fastcgi.conf</code> and <code class="literal">fastcgi_params</code> files contains almost the same list of simple commands configuring the Nginx FastCGI client. FastCGI, being an interface to run web applications behind Nginx, is not turned on by default. These two files are provided as examples (one of them is even included with the <code class="literal">include</code> command from a commented section of the <code class="literal">nginx.conf</code> file).</p><p>Three files <a class="indexterm" id="id14"/>with enigmatic names <code class="literal">koi-utf</code>, <code class="literal">koi-win</code>, and <code class="literal">win-utf</code> are character maps to convert between different ways to encode Cyrillic characters in electronic documents. And Cyrillic is, of course, the script used for Russian and several other languages. In the old days of the first Internet hosts in Russia, there was a dispute on which way to encode Russian letters in documents. You can read about different <a class="indexterm" id="id15"/>Cyrillic charsets/encodings at <a class="ulink" href="http://czyborra.com/charsets/cyrillic.html">http://czyborra.com/charsets/cyrillic.html</a>. Several of them got popular, and web servers had to include functionality of converting documents on the fly in the case that a client browser requested a different encoding from what was used by the server. There was also a whole fork of Apache Web Server that had this functionality built in. Nginx had to do the same to stand a chance against Apache. And now, more than 10 years later, we still have these re-encoding files that are deeply obsolete as the global <span class="strong"><strong>World Wide Web</strong></span><a class="indexterm" id="id16"/> continues to move towards UTF-8 as the one universal encoding for all human languages. You won't ever use these <code class="literal">koi-utf</code>, <code class="literal">koi-win</code>, and <code class="literal">win-utf</code> files unless you support a very old website for Russian-speaking visitors.</p><p>The file named <code class="literal">mime.types</code> is used by default. You can see that it is included from the main <code class="literal">nginx.conf</code>, and you better leave it that way. "MIME types" is a registry of different types of information in files. </p><p>They have their origin in some of the email standards (hence, the MIME name) but are used everywhere, including the Web. Let's look inside <code class="literal">mime.types</code>:</p><div class="informalexample"><pre class="programlisting">...
types {
    text/html                             html htm shtml;
    text/css                              css;
    text/xml                              xml;
    image/gif                             gif;
...</pre></div><p>Because it is included from <code class="literal">nginx.conf</code>, it should have a proper Nginx configuration language syntax. That's right, it contains a single multiline directive <code class="literal">types</code>, which is not a context (as described in the previous section). Its block is a list of pairs, each being a mapping from one MIME type to a list of file extensions. This mapping is used to mark static files served by Nginx as having a particular MIME (or content) type. According to the quoted segment, the files <code class="literal">common.css</code> and <code class="literal">new.css</code> will get the type <code class="literal">text/css</code>, whereas <code class="literal">index.shtml</code> will be <code class="literal">text/html</code>, and so on and so forth; it is really easy.</p></div><div class="section" title="A quick example of modifying the MIME types registry"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec11"/>A quick example of modifying the MIME types registry</h2></div></div></div><p>Sometimes, you <a class="indexterm" id="id17"/>will add things to this registry. Let's try to do this now and demonstrate an introduction of a simple mistake and the workflow to find and fix it.</p><p>Your website will host calendars for your colleagues. A calendar is a file in the iCalendar format generated by a third-party application and saved to a file with <code class="literal">.ics</code> extension. There is nothing about <code class="literal">ics</code> in the default <code class="literal">mime.types</code>, and because of this, your Nginx instance will serve these files with the default <code class="literal">application/octet-stream</code> MIME type, which basically means "it is a bunch of octets (bytes) and I don't have the faintest idea of what they mean". Suppose that the new calendar application your colleagues use require proper iCalendar-typed HTTP responses. This means that you have to add this <code class="literal">text/calendar</code> type into your <code class="literal">mime.types</code> file.</p><p>You open <code class="literal">mime.types</code> in your editor and add this line to the very end (not in the middle, not to the start, but the end is important for the sake of this experiment) of the file:</p><div class="informalexample"><pre class="programlisting">...
text/calendar ics
...</pre></div><p>You then run <code class="literal">nginx -t</code> because you are a good Nginx administrator:</p><div class="informalexample"><pre class="programlisting">...
nginx: [emerg] unexpected end of file, expecting ";" or "}" in /etc/nginx/mime.types:91
nginx: configuration file /etc/nginx/nginx.conf test failed
...</pre></div><p>Bam. Nginx is smart enough to tell you what you need to fix; this line does not look like either a simple or a multiline directive. Let's add the semicolon:</p><div class="informalexample"><pre class="programlisting">...
text/calendar ics;
...

...
nginx: [emerg] unknown directive "text/calendar" in /etc/nginx/mime.types:90
nginx: configuration file /etc/nginx/nginx.conf test failed
...</pre></div><p>Now this is more obscure. What you should do here is understand that this line is not a separate standalone directive. It is a part of the big <code class="literal">types</code> multiline (the rare, non-context one) directive; therefore, it should be moved into the block.</p><p>Change the tail of the <code class="literal">mime.types</code> from this:</p><div class="informalexample"><pre class="programlisting">}
text/calendar ics;</pre></div><p>The preceding code should look as follows:</p><div class="informalexample"><pre class="programlisting">text/calendar ics;
}</pre></div><p>It is done by<a class="indexterm" id="id18"/> swapping the last two meaningful lines:</p><div class="informalexample"><pre class="programlisting">nginx: the configuration file /etc/nginx/nginx.conf syntax is ok
nginx: configuration file /etc/nginx/nginx.conf test is successful</pre></div><p>Congratulations, you just enabled a new business process for your company involving mobile workforce.</p><p>Two last default configuration files are <code class="literal">scgi_params</code> and <code class="literal">uwsgi_params</code>. Those two are the counterparts for the <code class="literal">fastcgi_params</code>, setting up two alternative methods of running web application on your web servers (SCGI and UWSGI, respectively, as you guessed). You will use them if and when your application developers will bring you applications written with these interfaces in mind.</p></div><div class="section" title="Default nginx.conf"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec12"/>Default nginx.conf</h2></div></div></div><p>Now, let's dig <a class="indexterm" id="id19"/>deeper into the main configuration file <code class="literal">nginx.conf</code>. In its default form that you see inside the tarball, it is rather empty and useless. At the same time, it is always what you use as a starting point when writing your own configuration, and it can also be used as a demonstration of some common troubles that people inflict on themselves. Going over each directive is not needed, so only those that are good to demonstrate a technique or a common place of errors will be included in this section:</p><div class="informalexample"><pre class="programlisting">...
#user nobody;
...</pre></div><p>This directive specifies the name of the UNIX user that Nginx processes will run as. Commenting out pieces of configuration is a common documentation technique. It shows the default values and removing the comment character is safe. Nginx will complain if you try to run it as a nonexistent user. As a general rule, you should either trust your package vendor and not change the default or use an account with the least permissions possible.</p><div class="informalexample"><pre class="programlisting">...
#error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;

#pid        logs/nginx.pid;
...</pre></div><p>These lines<a class="indexterm" id="id20"/> specify some default filenames. The three <code class="literal">error_log</code> directives are an example of yet another technique: providing several variants as comments so that you can uncomment the one you prefer. These three differ by the level of detail that goes into the error log. There is a whole chapter about logs as those are definitely the first and foremost debugging and troubleshooting tool available for any Nginx administrator.</p><p>The <code class="literal">pid</code> directive allows you to change the filename where pid of the main Nginx process will be stored. You rarely have to change this.</p><p>Note that these directives use relative paths in these examples, but this is not required. They could also use absolute paths (starting with <code class="literal">/</code>). The <code class="literal">error_log</code> directive provides two other ways of logging besides simple files, which you will see later.</p><div class="informalexample"><pre class="programlisting">...
events {
    worker_connections  1024;
}
...</pre></div><p>This is our first context and a confusing one. <code class="literal">events</code> is not used to narrow the scope of directives inside it. Most of those directives cannot be used in any other context except <code class="literal">events</code>. This is used as a logical grouping mechanism for many parameters that configure the way Nginx responds to activity on the network. These are very general words, but they fit the purpose. Think of <code class="literal">events</code> as a fancy historical way of marking a group of parameters that are close to one another.</p><p>The <code class="literal">worker_connections</code> directive specifies the maximum number of all network connections each worker process will have. It may be a source of strange mistakes. You should remember that this limit includes both the client connections between Nginx and your user's browsers and the <code class="literal">server</code> connections that Nginx will have to open for your backend web application code (unless you only serve static files).</p></div><div class="section" title="The http directive"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec13"/>The http directive</h2></div></div></div><div class="informalexample"><pre class="programlisting">...
http {
    include       mime.types;
    default_type  application/octet-stream;
...</pre></div><p>Here we go, <code class="literal">http</code> marks the start of a huge context that usually spans several files (via nested includes) and <a class="indexterm" id="id21"/>groups all the configuration parameters that concern the web part of Nginx. You might feel that this sounds a lot like <code class="literal">events</code>, but it is actually a very valid context requiring a separate directive because Nginx can work not only as an HTTP server but also serve some other protocols, for example, IMAP and POP3. It is an infrequent use case, to put it mildly, and we won't spend our time on it, but it shows a very legitimate reason to have a special scope for all HTTP options.</p><p>You probably know what the first two directives inside <code class="literal">http</code> do. Never change the default MIME type. Many web clients use this particular type as an indication of a file that needs to be saved on the client computer as an opaque blob of data, and it is a good idea for all the unknown files.</p><div class="informalexample"><pre class="programlisting">...
    #log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
    #                  '$status $body_bytes_sent "$http_referer" '
    #                  '"$http_user_agent" "$http_x_forwarded_for"';

    #access_log  logs/access.log  main;
...</pre></div><p>These two directives specify logging of all requests, both successful and unsuccessful, for the reason of tracing and statistics. The first directive creates a log format and the second initiates logging to a specific file according to the mentioned format. It is a very powerful mechanism that gets special attention later in this book. Then we have the following code:</p><div class="informalexample"><pre class="programlisting">...
    sendfile        on;
    #tcp_nopush     on;

    #keepalive_timeout  0;
    keepalive_timeout  65;

    #gzip  on;
...</pre></div><p>The first and the second of these turn on certain networking features of the HTTP support. <code class="literal">sendfile</code> is a syscall that allows copying of bytes from a file to a socket by the OS kernel itself, sometimes using "zero copy" semantics. It is always safe to leave it on unless you have very little memory—there were reports that sometimes <code class="literal">sendfile</code> boxes may work unreliably on servers with little memory. <code class="literal">tcp_nopush</code> is an option that makes sense only in the presence of <code class="literal">sendfile on</code>. It allows you to optimize a number of network packets that a <code class="literal">sendfile-d</code> file gets sent in. <code class="literal">keepalive</code> is a feature of modern HTTP—the browser (on any other client) may choose not to close a connection to a server right away but to keep it open just in case there will be a need to talk to the same server again very soon. For many modern web pages, consisting of hundreds of objects, this could help a lot, especially on HTTPS, where the cost of opening a new connection is higher. <code class="literal">keepalive</code> timeout is a period in seconds that Nginx will not drop open connections to clients. Tweaking the default value of 75 will rarely affect performance. You can try if you know something special about your clients, but usually people either leave the default timeout or turn the <code class="literal">keepalive</code> off altogether by setting the timeout to zero.</p><p>There are a (big) number of <a class="indexterm" id="id22"/>compression algorithms much better than the LZW of the traditional gzip, but gzip is most widely available among servers and clients on the web, providing good enough compression for texts with very little cost. <code class="literal">gzip on</code> will turn on automatic compression of data on the fly between Nginx and its clients, that is, those which announce support for gzipped server responses, of course. There are still browsers in the wild that do not support gzip properly. See the description of the <code class="literal">gzip_disable</code> directive in the Nginx documentation<a class="indexterm" id="id23"/> at <a class="ulink" href="http://nginx.org/en/docs/http/ngx_http_gzip_module.html#gzip_disable">http://nginx.org/en/docs/http/ngx_http_gzip_module.html#gzip_disable</a>. It might be a source of problems, but only if you have some really odd users either with weird special-case client software or from the past.</p><div class="informalexample"><pre class="programlisting">...
    server {
        listen       80;
        server_name  localhost;
...</pre></div><p>Now we have another multiline context directive inside <code class="literal">http</code>. It is a famous <code class="literal">server</code> directive that configures a single web server object with a hostname and a TCP port to listen on. Those two are the top-most directives inside this <code class="literal">server</code>. The first, <code class="literal">listen</code> has a much more complex syntax than just a port number, and we will not describe it here. The second one has a simple syntax, but some complex rules of matching that are also better described in the online documentation. It will be sufficient to say that these two provide a way of choosing the right server to process an incoming HTTP request. The most useful is the <code class="literal">server_name</code> in its simplest form; it just contains a hostname in the form of DNS domain and it will be matched against the name that browser sent in the <code class="literal">Host:</code> header which, in turn, is just the host name part of the URL.</p><div class="informalexample"><pre class="programlisting">...
        #charset koi8-r;
...</pre></div><p>This is a way to indicate the charset (encoding) of the documents you serve to the browsers. It is set by default to the special value <code class="literal">off</code> and not the good old <code class="literal">koi8-r</code> from RFC1489. Nowadays, your best bet is specifying <code class="literal">utf8</code> here or just leaving it off. If you specify a charset that does not correspond to the actual charset of your documents, you will get troubles.</p><div class="informalexample"><pre class="programlisting">...
        #access_log  logs/host.access.log  main;
...</pre></div><p>Here is an <a class="indexterm" id="id24"/>interesting example of using a directive inside a narrowing context. Remember that we already discussed <code class="literal">access_log</code> one level higher, inside the <code class="literal">http</code> directive. This one will turn on logging of requests to this particular server only. It is a good habit to include the name of the server in the name of its access log. So, replace <code class="literal">host</code> with something very similar to your <code class="literal">server_name</code>.</p><div class="informalexample"><pre class="programlisting">...
        location / {
            root   html;
            index  index.html index.htm;
        }
...</pre></div><p>Again, we see a multiline directive introducing a context for a number of URLs on this particular server. <code class="literal">location /</code> will match all the requests unless there is a more specific location on the same level. The rules to choose the correct location block to process an incoming request are quite complex, but simple cases could be described with simple words.</p><p>The <code class="literal">index</code> directive specifies the way to process URLs that correspond to a local folder. In this case, Nginx seeks the first existing file from the list in this directive. Serving either an <code class="literal">index.html</code> or <code class="literal">index.htm</code> for such URLs is a very old convention; you shouldn't break it unless you know what you are doing.</p><p>By the way, <code class="literal">index.htm</code> without the last <code class="literal">l</code> is an artifact of the old Microsoft filesystems that allowed three or less characters in the filename extension. Nginx never worked on Microsoft systems with such limitations, but files ending in <code class="literal">htm</code> instead of <code class="literal">html</code> still linger around.</p><div class="informalexample"><pre class="programlisting">...
        #error_page  404              /404.html;

        # redirect server error pages to the static page /50x.html
        #
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
...</pre></div><p>These directives set up the way errors are reported to the user. You, as the webmaster, will most certainly rely on your logs but just in case something happened, your users should not be left in dark. The <code class="literal">error_page</code> directive installs a handler for an HTTP error based on the famous HTTP status codes. The first example (commented) tells Nginx that in case it encounters a 404 (not found) error, it should not report it to the user as a real 404 error but instead initiate the subrequest to the <code class="literal">/404.html</code> location, render the results, and present them in the response to the original user request.</p><p>By the way, one <a class="indexterm" id="id25"/>of the most embarrassing mistakes you could make with Apache web server is to provide a 404 handler that raises another 404 error. Remember these?</p><div class="mediaobject"><img alt="The http directive" src="graphics/B04329_01_01.jpg"/></div><p>Nginx will not show this type of detail to users, but they will still see some very ugly error messages:</p><div class="mediaobject"><img alt="The http directive" src="graphics/B04329_01_02.jpg"/></div><p>The <code class="literal">location = /50x.html</code> looks suspiciously similar to the one we discussed earlier. The only important difference is the <code class="literal">=</code> character that means "exact match". The whole matching algorithm <a class="indexterm" id="id26"/>is a complete topic in itself, but here you should definitely remember that <code class="literal">=</code> means "process requests for this and only this URL, do not treat it as a prefix that could match longer URLs".</p><div class="informalexample"><pre class="programlisting">...
        # proxy the PHP scripts to Apache listening on 127.0.0.1:80
        #
        #location ~ \.php$ {
        #    proxy_pass   http://127.0.0.1;
        #}

        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
        #
        #location ~ \.php$ {
        #    root           html;
        #    fastcgi_pass   127.0.0.1:9000;
        #    fastcgi_index  index.php;
        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
        #    include        fastcgi_params;
        #}
...</pre></div><p>This is a big commented chunk of options all about the same – processing PHP scripts using two different strategies. Nginx, as you know, does not try to be everything, and it especially tries to never be an application server. The first <code class="literal">location</code> directive sets up proxying to another local PHP server, probably Apache with <code class="literal">mod_php</code>.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note02"/>Note</h3><p>Pay attention to the <code class="literal">~</code> character in <code class="literal">location</code>. It turns on regular expressions engine for the matching of the URLs, hence the escaped <code class="literal">.</code> and the <code class="literal">$</code> in the end. Nginx regular expressions use the common syntax originating from the first grep and ed programs written in the late 1960s. They are implemented with the PCRE library. See the PCRE documentation<a class="indexterm" id="id27"/> for the comprehensive description of the language at <a class="ulink" href="http://www.pcre.org/original/doc/html/pcrepattern.html">http://www.pcre.org/original/doc/html/pcrepattern.html</a>.</p></div></div><p>The second block talks to a FastCGI server running locally on the <code class="literal">9000</code> port instead of HTTP proxying. It is a bit more modern way of running PHP, but it also requires a lot of parameters (see included file) as compared with the very simple and humble HTTP.</p><div class="informalexample"><pre class="programlisting">...
        # deny access to .htaccess files, if Apache's document root
        # concurs with Nginx's one
        #
        #location ~ /\.ht {
        #    deny  all;
        #}
...</pre></div><p>The last part of the<a class="indexterm" id="id28"/> server block under discussion introduces <span class="strong"><strong>Access Control Lists</strong></span> (<span class="strong"><strong>ACLs</strong></span>), in a <code class="literal">location</code> with a regular expression. The note in the comment is a curious one. There is a tradition of "bolting" Nginx onto an existing Apache installation so that Nginx would serve all the static files itself while proxying more complex, dynamic URLs to the downstream Apache. This kind of setup is definitely not recommended, but you have probably seen or even inherited one. Nginx itself does not support the local <code class="literal">.htaccess</code> files but has to protect those files left from Apache because they could contain sensitive information.</p><p>And the final server multiline directive is an example of a secure server serving HTTPS:</p><div class="informalexample"><pre class="programlisting">...
    # HTTPS server
    #
    #server {
    #    listen       443 ssl;
    #    server_name  localhost;

    #    ssl_certificate      cert.pem;
    #    ssl_certificate_key  cert.key;

    #    ssl_session_cache    shared:SSL:1m;
    #    ssl_session_timeout  5m;

    #    ssl_ciphers  HIGH:!aNULL:!MD5;
    #    ssl_prefer_server_ciphers  on;

    #    location / {
    #        root   html;
    #        index  index.html index.htm;
    #    }
    #}
...</pre></div><p>Besides a bunch of simple <code class="literal">ssl_</code> directives in the middle, the important thing to note is <code class="literal">listen 443 ssl</code>, which enables HTTPS (basically, HTTPS is HTTP over SSL on the TCP port <code class="literal">443</code>). We talk about HTTPS in <a class="link" href="ch03.html" title="Chapter 3. Troubleshooting Functionality">Chapter 3</a>, <span class="emphasis"><em>Troubleshooting Functionality</em></span> of this book.</p></div></div>
<div class="section" title="Common mistakes in configuration"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Common mistakes in configuration</h1></div></div></div><p>Reading <a class="indexterm" id="id29"/>default configuration files may turn out <a class="indexterm" id="id30"/>interesting and educating, but more useful thing is, of course, looking at examples of configuration that is actually used in production. We will now look at some common mistakes that happen during the configuration of Nginx.</p><p>If you don't see something that has happened to you and you need help immediately, by all means skip and browse the rest of the book. There are a lot more examples throughout the chapters grouped by the nature of the problem or the effects it has.</p><div class="section" title="Semicolons and newlines"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec14"/>Semicolons and newlines</h2></div></div></div><p>One common <a class="indexterm" id="id31"/>feature of truly great software is forgiving. Nginx will understand and autocorrect some syntax violations when the result is unambiguous. For example, if your hands insist on enclosing values in quotes—you can actually do this.</p><p>This is completely legal and works okay:</p><div class="informalexample"><pre class="programlisting">...
user "nobody" 'www-data';
worker_processes '2';
...</pre></div><p>On the other hand, here is a case when Nginx will not allow you to leave a stray, unneeded semicolon although it does not introduce any ambiguity:</p><div class="informalexample"><pre class="programlisting">...
events {
    worker_connections 768;
    # multi_accept on;
};
...</pre></div><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>% sudo nginx -t</strong></span>
<span class="strong"><strong>nginx: [emerg] unexpected ";" in /etc/nginx/nginx.conf:13</strong></span>
<span class="strong"><strong>nginx: configuration file /etc/nginx/nginx.conf test failed</strong></span>
</pre></div><p>The author once had a configuration file saved in the older Mac format, that is, with &lt;CR&gt; as the newline separator. This is a format used on pre-OS X Apple operating systems. Text editors and pagers work around this rare curiosity, and you will have a hard time noticing anything unusual. Nginx could not split the file into lines at all:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>% sudo nginx -t</strong></span>
<span class="strong"><strong>nginx: [emerg] unexpected end of file, expecting "}" in /etc/nginx/nginx.conf:1</strong></span>
<span class="strong"><strong>nginx: configuration file /etc/nginx/nginx.conf test failed</strong></span>
</pre></div><p>The way to<a class="indexterm" id="id32"/> fix it is to convert newlines from &lt;CR&gt; to &lt;LF&gt; or to &lt;CR&gt;&lt;LF&gt;. The easiest method, using <code class="literal">tr</code> from the Unix/Linux command line, looks like this:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>% tr '\r' '\n' &lt; /etc/nginx/nginx.conf &gt; /tmp/nginx.conf</strong></span>
</pre></div><p>(After this, check it manually and replace the old file with <code class="literal">mv</code>.)</p></div><div class="section" title="File permissions"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec15"/>File permissions</h2></div></div></div><p>Have<a class="indexterm" id="id33"/> you noticed that we run <code class="literal">nginx -t</code> with <code class="literal">sudo</code>? Let us try without <code class="literal">sudo</code> and see what happens:</p><div class="mediaobject"><img alt="File permissions" src="graphics/B04329_01_03.jpg"/></div><p>It is actually quite interesting. Nginx reported that the syntax of the file is okay, but then it decided to dig deeper and check not only the syntax but also the availability of some features mentioned in the configuration. First, it complained about not being able to change the effective user under whose permissions all the worker processes should run. Do you remember the <code class="literal">user</code> directive? It also tried to open both the main server-wide error log and the <code class="literal">pid</code> file that is rewritten on each restart of Nginx. Both of them are not available for writing from the main working account (and they should not be, of course). That is why sudo is needed when running <code class="literal">nginx -t</code>.</p></div><div class="section" title="Variables"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec16"/>Variables</h2></div></div></div><p>Here is <a class="indexterm" id="id34"/>another example of a simple syntax error that might bite you once or twice in your career. Do you remember variables that we discussed several pages before? Nginx uses <code class="literal">$syntax</code> that is very familiar to everyone with the UNIX shell, awk, Perl, or PHP programming experience. Still, it is very easy to miss the dollar character and Nginx will not notice that because a variable will just turn into a simple string constant.</p><p>When you set up your Nginx as a proxy for another web server (such configuration is traditionally named "reverse accelerator", but less and less often so in recent times), you will quickly find that all client connections to your backend server come from the same IP address, the address of your Nginx host. The reason is obvious, but once you have some backend logic depending on getting the actual client address, you will need to work around this limitation of proxying. A common practice is to include an additional HTTP request header on all requests from Nginx to the backend. Here is how you do that:</p><div class="informalexample"><pre class="programlisting">...
proxy_set_header X-Real-IP $remote_addr;
...</pre></div><p>The application will have to check for this header, and only in its absence use the actual client IP address from the socket. Now, imagine losing that dollar sign in the beginning of <code class="literal">$remote_addr</code>. Suddenly, your Nginx will add a very strange header of <code class="literal">X-Real-IP: remote_addr</code> to all requests. <code class="literal">nginx -t</code> won't be able to detect this. Your backend application might blow up in case there is a strict IP address parser or, and this is ironically worse, it might skip the unparsable IP address of <code class="literal">remote_addr</code> and default to the actual address of your Nginx never ever reporting this to any logs. You will end up with a working configuration that silently loses valuable information! Depending on luck, this could be in production for months before someone notices that some fresh "rate-limiting by IP" feature of the application starts to affect all users at once!</p><p>Ah, the horrors!</p></div><div class="section" title="Regular expressions"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec17"/>Regular expressions</h2></div></div></div><p>Let us <a class="indexterm" id="id35"/>get to something less destructive. Many Nginx directives make use of regular expressions. You should be familiar with them. If not, we would recommend stopping your work as soon as possible and leaving for a bookstore. Regular expressions are considered by many IT practitioners to be the single most important technology or skill for everyday use after fast typing.</p><p>Most often, you will see regexps in <code class="literal">location</code> multiline directive. Besides this, they are very useful (and sometimes unavoidable) in URL rewriting and hostname matching. Regular expressions are a mini-language that uses several characters as metacharacters to construct patterns from strings. Those patterns cover sets of strings (very often infinite sets); the process of checking whether a particular string is contained in the set corresponding to a pattern is named matching. This is a simple regexp from the default <code class="literal">nginx.conf</code> file:</p><div class="informalexample"><pre class="programlisting">...
#location ~ \.php$ {
#    proxy_pass   http://127.0.0.1;
#}
...</pre></div><p>The tilde after<a class="indexterm" id="id36"/> the <code class="literal">location</code> command word means that what follows is a regular expression to match against incoming URLs. <code class="literal">\.php$</code> covers an infinite set of all strings in the universe that have these exact four characters in the very end: <code class="literal">.php</code>. The backslash before the dot cancels the metavalue of the dot, which is "any character". The dollar sign is a metacharacter that matches the very end of a string.</p><p>How many ways are there to make a mistake in that expression? A lot. A very big number. Will <code class="literal">nginx -t</code> point out those errors? Most probably, no, unless you happen to make the whole directive somehow invalid and due to the very expressive nature of the mini-language, almost all character combinations are valid. Let's try some:</p><div class="informalexample"><pre class="programlisting">...
        location ~ \.php {
...</pre></div><p>Did you notice? Right, no dollar, again as in the variable example shown previously. This is perfectly valid. It will also pass most tests because this regexp covers an even larger infinite set of all strings that have <code class="literal">.php</code> as a substring, not necessarily in the end. What could possibly go wrong? Well, first, you could get a request for the URL that looks like "
<code class="literal">/mirrors/www.phpworld.example.com/index.html</code>" and blow up. And second, matching by comparing the last 4 characters is logically much simpler than searching the whole buffer for the substring. This could have performance effects, however, small.</p><p>Let's skip the backslash instead:</p><div class="informalexample"><pre class="programlisting">...
        location ~ .php$ {
...</pre></div><p>Evil. This will also pass the tests but again, the set of matching strings grew. Now the dot before the <code class="literal">php</code> is not literal. It is a metadot meaning any character. You have to be lucky to get something like <code class="literal">/download/version-for-php</code>, but once you get this, the location will match. You have a time bomb.</p><p>Now, let's drop the tilde:</p><div class="informalexample"><pre class="programlisting">...
        location \.php$ {
...</pre></div><p>Do you like our game by the way? You should already predict what will happen and how to fix it, that is, if you do like it and are starting to think like an Nginx instance.</p><p>The missing<a class="indexterm" id="id37"/> tilde will turn this location directive into its simplest form—no regular expressions whatsoever. The string <code class="literal">\.php$</code> is interpreted as a prefix to search for in all incoming URLs, together with the backslash and the dollar. Will this location block ever process a single request? We don't know. One important thing here is that <code class="literal">nginx -t</code> still does not have anything to say about this directive. It is still valid syntactically.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Summary</h1></div></div></div><p>In this chapter, you refreshed your knowledge of how exactly Nginx is configured. We showed how the language looks and what some common pitfalls are when writing it. Some of you learned a thing or two about the mysterious files that Nginx authors included in the default <code class="literal">conf</code> folder; some will never ever miss a semicolon again. Run <code class="literal">nginx -t</code> often, but never blindly rely on it saying everything is okay.</p><p>The next chapter is devoted to reading and configuring logging mechanisms inside Nginx.</p></div></body></html>