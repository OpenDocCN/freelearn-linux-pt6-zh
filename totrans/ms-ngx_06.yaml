- en: Chapter 6. The NGINX HTTP Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An HTTP server is primarily a piece of software that will deliver web pages
    to clients when requested. These web pages can be anything from a simple HTML
    file on disk to a multicomponent framework delivering user-specific content, dynamically
    updated through AJAX or WebSocket. NGINX is modular, and is designed to handle
    any kind of HTTP serving necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will investigate the various modules that work together
    to make NGINX such a scalable HTTP server. The following topics are included in
    this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: NGINX's architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The HTTP core module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using limits to prevent abuse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restricting access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Streaming media files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Predefined variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using NGINX with PHP-FPM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wiring NGINX and uWSGI together
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NGINX's architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NGINX consists of a single master process and multiple worker processes. Each
    of these is single-threaded and designed to handle thousands of connections simultaneously.
    The worker process is where most of the action takes place, as this is the component
    that handles client requests. NGINX makes use of the operating system's event
    mechanism to respond quickly to these requests.
  prefs: []
  type: TYPE_NORMAL
- en: The NGINX **master process** is responsible for reading the configuration, handling
    sockets, spawning workers, opening log files, and compiling embedded Perl scripts.
    The master process is the one that responds to administrative requests via signals.
  prefs: []
  type: TYPE_NORMAL
- en: The NGINX **worker process** runs in a tight event loop to handle incoming connections.
    Each NGINX module is built into the worker, so that any request processing, filtering,
    handling of proxy connections, and much more is done within the worker process.
    Due to this worker model, the operating system can handle each process separately
    and schedule the processes to run optimally on each processor core. If there are
    any processes that would block a worker, such as disk I/O, more workers than cores
    can be configured to handle the load.
  prefs: []
  type: TYPE_NORMAL
- en: There are also a small number of helper processes that the NGINX master process
    spawns to handle dedicated tasks. Among these are the **cache loader** and **cache
    manager** processes. The cache loader is responsible for preparing the metadata
    for worker processes to use the cache. The cache manager process is responsible
    for checking cache items and expiring invalid ones.
  prefs: []
  type: TYPE_NORMAL
- en: NGINX is built in a modular fashion. The master process provides the foundation
    upon which each module may perform its function. Each protocol and handler is
    implemented as its own module. The individual modules are chained together into
    a pipeline to handle connections and process requests. After a request is handled,
    it is then passed on to a series of filters, in which the response is processed.
    One of these filters is responsible for processing subrequests, one of NGINX's
    most powerful features.
  prefs: []
  type: TYPE_NORMAL
- en: Subrequests are how NGINX can return the results of a request that differs from
    the URI that the client sent. Depending on the configuration, they may be multiply
    nested and call other subrequests. Filters can collect the responses from multiple
    subrequests and combine them into one response to the client. The response is
    then finalized and sent to the client. Along the way, multiple modules come into
    play. See [http://www.aosabook.org/en/nginx.html](http://www.aosabook.org/en/nginx.html)
    for a detailed explanation of NGINX internals.
  prefs: []
  type: TYPE_NORMAL
- en: We will be exploring the `http` module and a few helper modules in the remainder
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP core module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `http` module is NGINX''s central module, which handles all interactions
    with clients over HTTP. We have already discussed the following aspects of this
    module in [Chapter 2](ch02.html "Chapter 2. A Configuration Guide"), *A Configuration
    Guide*:'
  prefs: []
  type: TYPE_NORMAL
- en: Client directives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File I/O directives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hash directives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Socket directives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `listen` directive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Matching a request to a `server_name` and `location` directive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will have a look at the remaining directives in the rest of this section,
    again divided by type.
  prefs: []
  type: TYPE_NORMAL
- en: The server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `server` directive starts a new context. We have already seen examples of
    its usage throughout the book so far. One aspect that has not yet been examined
    in-depth is the concept of a **default server**.
  prefs: []
  type: TYPE_NORMAL
- en: A default server in NGINX means that it is the first server defined in a particular
    configuration with the same `listen` IP address and port as another server. A
    default server may also be denoted by the `default_server` parameter to the `listen`
    directive.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default server is useful to define a set of common directives that will
    then be reused for subsequent servers listening on the same IP address and port:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `www.example.com` server will have the `server_name_in_redirect`
    directive set to `on` as well as the `default.example.com` server. Note that this
    would also work if both servers had no `listen` directive, since they would still
    both match the same IP address and port number (that of the default value for
    listen, which is `*:80`). Inheritance, though, is not guaranteed. There are only
    a few directives that are inherited, and which ones are changes over time.
  prefs: []
  type: TYPE_NORMAL
- en: A better use for the default server is to handle any request that comes in on
    that IP address and port, and does not have a `Host` header. If you do not want
    the default server to handle requests without a `Host` header, it is possible
    to define an empty `server_name` directive. This server will then match those
    requests.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following table summarizes the directives relating to `server`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table: HTTP server directives'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| Directive | Explanation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `port_in_redirect` | Determines whether or not the port will be specified
    in a redirect issued by NGINX. |'
  prefs: []
  type: TYPE_TB
- en: '| `server` | Creates a new configuration context, defining a virtual host.
    The `listen` directive specifies the IP address(es) and port(s); the `server_name`
    directive lists the `Host` header values that this context matches. |'
  prefs: []
  type: TYPE_TB
- en: '| `server_name` | Configures the names that a virtual host may respond to.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `server_name_in_redirect` | Activates using the first value of the `server_name`
    directive in any redirect issued by NGINX within this context. |'
  prefs: []
  type: TYPE_TB
- en: '| `server_tokens` | Disables sending the NGINX version string in error messages
    and the `Server` response header (default value is `on`). |'
  prefs: []
  type: TYPE_TB
- en: Logging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: NGINX has a very flexible logging model. Each level of configuration may have
    an access log. In addition, more than one access log may be specified per level,
    each with a different `log_format`. The `log_format` directive allows you to specify
    exactly what will be logged, and needs to be defined within the `http` section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The path to the log file itself may contain variables, so that you can build
    a dynamic configuration. The following example describes how this can be put into
    practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following table describes the directives used in the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table: HTTP logging directives'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| Directive | Explanation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `access_log` | Describes where and how access logs are to be written. The
    first parameter is a path to the file where the logs are to be stored. Variables
    may be used in constructing the path. The special value `off` disables the access
    log. An optional second parameter indicates `log_format` that will be used to
    write the logs. If no second parameter is configured, the predefined combined
    format is used. An optional third parameter indicates the size of the buffer if
    write buffering should be used to record the logs. If write buffering is used,
    this size cannot exceed the size of the atomic disk write for that filesystem.
    If this third parameter is `gzip`, then the buffered logs will be compressed on-the-fly,
    provided that the `nginx` binary was built with the `zlib` library. A final `flush`
    parameter indicates the maximum length of time buffered log data may remain in
    memory before being flushed to disk. |'
  prefs: []
  type: TYPE_TB
- en: '| `log_format` | Specifies which fields should appear in the log file and what
    format they should take. See the next table for a description of the log-specific
    variables. |'
  prefs: []
  type: TYPE_TB
- en: '| `log_not_found` | Disables reporting of 404 errors in the error log (default
    value is `on`). |'
  prefs: []
  type: TYPE_TB
- en: '| `log_subrequest` | Enables logging of subrequests in the access log (default
    value is `off`). |'
  prefs: []
  type: TYPE_TB
- en: '| `open_log_file_cache` | Stores a cache of open file descriptors used in `access_logs`
    with a variable in the path. The parameters used are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`max`: The maximum number of file descriptors present in the cache'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`inactive`: NGINX will wait this amount of time for something to be written
    to this log before its file descriptor is closed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`min_uses`: The file descriptor has to be used this amount of times within
    the `inactive` period in order to remain open'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`valid`: NGINX will check this often to see if the file descriptor still matches
    a file with the same name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`off`: Disables the cache'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, log entries will be compressed at a gzip level of
    4\. The buffer size is the default of 64 KB and will be flushed to disk at least
    every minute.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note that when specifying `gzip` the `log_format` parameter is not optional.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default combined `log_format` is constructed like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, line breaks may be used to improve readability. They do not
    affect the `log_format` itself. Any variables may be used in the `log_format`
    directive. The variables in the following table which are marked with an asterisk
    (`*`) are specific to logging and may only be used in the `log_format` directive.
    The others may be used elsewhere in the configuration, as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table: Log format variables'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| Variable Name | Value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `$body_bytes_sent` | The number of bytes sent to the client, excluding the
    response header. |'
  prefs: []
  type: TYPE_TB
- en: '| `$bytes_sent` | The number of bytes sent to the client. |'
  prefs: []
  type: TYPE_TB
- en: '| `$connection` | A serial number, used to identify unique connections. |'
  prefs: []
  type: TYPE_TB
- en: '| `$connection_requests` | The number of requests made through a particular
    connection. |'
  prefs: []
  type: TYPE_TB
- en: '| `$msec` | The time in seconds, with millisecond resolution. |'
  prefs: []
  type: TYPE_TB
- en: '| `$pipe *` | Indicates if the request was pipelined (`p`) or not (`.`). |'
  prefs: []
  type: TYPE_TB
- en: '| `$request_length *` | The length of the request, including the HTTP method,
    URI, HTTP protocol, header, and request body. |'
  prefs: []
  type: TYPE_TB
- en: '| `$request_time` | The request processing time, with millisecond resolution,
    from the first byte received from the client to the last byte sent to the client.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `$status` | The response status. |'
  prefs: []
  type: TYPE_TB
- en: '| `$time_iso8601 *` | Local time in ISO8601 format. |'
  prefs: []
  type: TYPE_TB
- en: '| `$time_local *` | Local time in common log format (`%d/%b/%Y:%H:%M:%S %z`).
    |'
  prefs: []
  type: TYPE_TB
- en: In this section, we have focused solely on `access_log` and how that can be
    configured. You can also configure NGINX to log errors. The `error_log` directive
    is described in [Chapter 8](ch08.html "Chapter 8. Troubleshooting Techniques"),
    *Troubleshooting*.
  prefs: []
  type: TYPE_NORMAL
- en: Finding files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order for NGINX to respond to a request, it passes it to a content handler,
    determined by the configuration of the `location` directive. The unconditional
    content handlers are tried first: `perl`, `proxy_pass`, `flv`, `mp4`, and so on.
    If none of these is a match, the request is passed to one of the following, in
    order: `random index`, `index`, `autoindex`, `gzip_static`, `static`. Requests
    with a trailing slash are handled by one of the index handlers. If gzip is not
    activated, then the static module handles the request. How these modules find
    the appropriate file or directory on the filesystem is determined by a combination
    of certain directives. The `root` directive is best defined in a default `server`
    directive, or at least outside of a specific `location` directive, so that it
    will be valid for the whole server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example any files to be served are found under the root `/home/customer/html`.
    If the client entered just the domain name, NGINX will try to serve `index.html`.
    If that file does not exist, then NGINX will serve `index.htm`. When a user enters
    the `/downloads` URI in their browser, they will be presented with a directory
    listing in HTML format. This makes it easy for users to access sites hosting software
    that they would like to download. NGINX will automatically rewrite the URI of
    a directory so that the trailing slash is present, and then issue an HTTP redirect.
    NGINX appends the URI to the `root` to find the file to deliver to the client.
    If this file does not exist, the client receives a **404 Not Found** error message.
    If you don''t want the error message to be returned to the client, one alternative
    is to try to deliver a file from different filesystem locations, falling back
    to a generic page, if none of those options are available. The `try_files` directive
    can be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As a security precaution, NGINX can check the path to a file it''s about to
    deliver, and if part of the path to the file contains a symbolic link, it returns
    an error message to the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, NGINX will return a "Permission Denied" error if a
    symlink is found after `/home/customer/html`, and that symlink and the file it
    points to do not both belong to the same user ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table summarizes these directives:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table: HTTP file-path directives'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| Directive | Explanation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `disable_symlinks` | Determines if NGINX should perform a symbolic link check
    on the path to a file before delivering it to the client. The following parameters
    are recognized:'
  prefs: []
  type: TYPE_NORMAL
- en: '`off`: Disables checking for symlinks (default)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`on`: If any part of a path is a symlink, access is denied'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`if_not_owner`: If any part of a path contains a symlink in which the link
    and the referent have different owners, access to the file is denied'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`from=part`: When specified, the path up to `part` is not checked for symlinks,
    everything afterward is according to either the `on` or `if_not_owner` parameter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `root` | Sets the path to the document root. Files are found by appending
    the URI to the value of this directive. |'
  prefs: []
  type: TYPE_TB
- en: '| `try_files` | Tests the existence of files given as parameters. If none of
    the previous files are found, the last entry is used as a fallback, so ensure
    that this path or named `location` exists, or is set to return a status code indicated
    by `=<status code>`. |'
  prefs: []
  type: TYPE_TB
- en: Name resolution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If logical names instead of IP addresses are used in an `upstream` or `*_pass`
    directive, NGINX will by default use the operating system's resolver to get the
    IP address, which is what it really needs to connect to that server. This will
    happen only once, the first time `upstream` is requested, and won't work at all
    if a variable is used in the `*_pass` directive. It is possible, though, to configure
    a separate resolver for NGINX to use. By doing this, you can override the TTL
    returned by DNS, as well as use variables in the `*_pass` directives.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Table: Name resolution directives'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| Directive | Explanation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `resolver` | Configures one or more name servers to be used to resolve upstream
    server names into IP addresses. An optional `valid` parameter overrides the TTL
    of the domain name record. |'
  prefs: []
  type: TYPE_TB
- en: 'In order to get NGINX to resolve an IP address anew, place the logical name
    into a variable. When NGINX resolves that variable, it implicitly makes a DNS
    look-up to find the IP address. For this to work, a `resolver` directive must
    be configured:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Of course, by relying on DNS to find an upstream, you are dependent on the resolver
    always being available. When the resolver is not reachable, a gateway error occurs.
    In order to make the client wait time as short as possible, the `resolver_timeout`
    parameter should be set low. The gateway error can then be handled by an `error_page`
    designed for that purpose.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Client interaction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a number of ways in which NGINX can interact with clients. This can
    range from attributes of the connection itself (IP address, timeouts, keepalive,
    and so on) to content negotiation headers. The directives listed in the following
    table describe how to set various headers and response codes to get the clients
    to request the correct page or serve up that page from its own cache:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table: HTTP client interaction directives'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| Directive | Explanation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `default_type` | Sets the default MIME type of a response. This comes into
    play if the MIME type of the file cannot be matched to one of those specified
    by the `types` directive. |'
  prefs: []
  type: TYPE_TB
- en: '| `error_page` | Defines a URI to be served when an error level response code
    is encountered. Adding an `=` parameter allows the response code to be changed.
    If the argument to this parameter is left empty, the response code will be taken
    from the URI, which must in this case be served by an upstream server of some
    sort. |'
  prefs: []
  type: TYPE_TB
- en: '| `etag` | Disables automatically generating the `ETag` response header for
    static resources (default is `on`). |'
  prefs: []
  type: TYPE_TB
- en: '| `if_modified_since` | Controls how the modification time of a response is
    compared to the value of the `If-Modified-Since` request header:'
  prefs: []
  type: TYPE_NORMAL
- en: '`off`: The `If-Modified-Since` header is ignored'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exact`: An exact match is made (default)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`before`: The modification time of the response is less than or equal to the
    value of the `If-Modified-Since` header'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `ignore_invalid_headers` | Disables ignoring headers with invalid names (default
    is `on`). A valid name is composed of ASCII letters, numbers, the hyphen, and
    possibly the underscore (controlled by the `underscores_in_headers` directive).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `merge_slashes` | Disables the removal of multiple slashes. The default value
    of `on` means that NGINX will compress two or more `/` characters into one. |'
  prefs: []
  type: TYPE_TB
- en: '| `recursive_error_pages` | Enables doing more than one redirect using the
    `error_page` directive (default is `off`). |'
  prefs: []
  type: TYPE_TB
- en: '| `types` | Sets up a map of MIME types to file name extensions. NGINX ships
    with a `conf`/`mime.types` file that contains most MIME type mappings. Using `include`
    to load this file should be sufficient for most purposes. |'
  prefs: []
  type: TYPE_TB
- en: '| `underscores_in_headers` | Enables the use of the underscore character in
    client request headers. If left at the default value `off`, evaluation of such
    headers is subject to the value of the `ignore_invalid_headers` directive. |'
  prefs: []
  type: TYPE_TB
- en: The `error_page` directive is one of NGINX's most flexible. Using this directive,
    we may serve any page when an error condition presents. This page could be on
    the local machine, but could also be a dynamic page produced by an application
    server, and could even be a page on a completely different site.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Using limits to prevent abuse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We build and host websites because we want users to visit them. We want our
    websites to always be available for legitimate access. This means that we may
    have to take measures to limit access to abusive users. We may define "abusive"
    to mean anything from one request per second to a number of connections from the
    same IP address. Abuse can also take the form of a **DDOS** (**distributed denial-of-service**)
    attack, where bots running on multiple machines around the world all try to access
    the site as many times as possible at the same time. In this section, we will
    explore methods to counter each type of abuse to ensure that our websites are
    available.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s take a look at the different configuration directives that will
    help us achieve our goal:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table: HTTP limits directives'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| Directive | Explanation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `limit_conn` | Specifies a shared memory zone (configured with `limit_conn_zone`)
    and the maximum number of connections that are allowed per key value. |'
  prefs: []
  type: TYPE_TB
- en: '| `limit_conn_log_level` | When NGINX limits a connection due to the `limit_conn`
    directive, this directive specifies at which log level that limitation is reported.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `limit_conn_zone` | Specifies the key to be limited in `limit_conn` as the
    first parameter. The second parameter, zone, indicates the name of the shared
    memory zone used to store the key and current number of connections per key and
    the size of that zone (`name:size`). |'
  prefs: []
  type: TYPE_TB
- en: '| `limit_rate` | Limits the rate (in bytes per second) at which clients can
    download content. The rate limit works on a connection level, meaning that a single
    client could increase their throughput by opening multiple connections. |'
  prefs: []
  type: TYPE_TB
- en: '| `limit_rate_after` | Starts the `limit_rate` after this number of bytes have
    been transferred. |'
  prefs: []
  type: TYPE_TB
- en: '| `limit_req` | Sets a limit with bursting capability on the number of requests
    for a specific key in a shared memory store (configured with `limit_req_zone`).
    The burst can be specified with the second parameter. If there shouldn''t be a
    delay in between requests up to the burst, a third parameter `nodelay` needs to
    be configured. |'
  prefs: []
  type: TYPE_TB
- en: '| `limit_req_log_level` | When NGINX limits the number of requests due to the
    `limit_req` directive, this directive specifies at which log level that limitation
    is reported. A delay is logged at a level one less than the one indicated here.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `limit_req_zone` | Specifies the key to be limited in `limit_req` as the
    first parameter. The second parameter, zone, indicates the name of the shared
    memory zone used to store the key and current number of requests per key and the
    size of that zone (`name:size`). The third parameter, `rate`, configures the number
    of requests per second (r/s) or per minute (r/m) before the limit is imposed.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `max_ranges` | Sets the maximum number of ranges allowed in a byte-range
    request. Specifying `0` disables byte-range support. |'
  prefs: []
  type: TYPE_TB
- en: 'Here we limit access to 10 connections per unique IP address. This should be
    enough for normal browsing, as modern browsers open two to three connections per
    host. Keep in mind, though, that any users behind a proxy will all appear to come
    from the same address. So observe the logs for error code 503 (Service Unavailable),
    meaning that this limit has come into effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Limiting access based on a rate looks almost the same, but works a bit differently.
    When limiting how many pages per unit of time a user may request, NGINX will insert
    a delay after the first page request, up to a burst. This may or may not be what
    you want, so NGINX offers the possibility to remove this delay with the `nodelay`
    parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Using $binary_remote_addr**'
  prefs: []
  type: TYPE_NORMAL
- en: We use the `$binary_remote_addr` variable in the preceding example to know exactly
    how much space storing an IP address will take. This variable takes 32 bytes on
    32-bit platforms and 64 bytes on 64-bit platforms. So the `10m` zone we configured
    previously is capable of holding up to 320,000 states on 32-bit platforms or 160,000
    states on 64-bit platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also limit the bandwidth per client. This way we can ensure that a few
    clients don''t take up all the available bandwidth. One caveat, though: the `limit_rate`
    directive works on a connection basis. A single client that is allowed to open
    multiple connections will still be able to get around this limit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can allow a kind of bursting to freely download smaller files,
    but make sure that larger ones are limited:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Combining these different rate limitations enables us to create a configuration
    that is very flexible as to how and where clients are limited:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Restricting access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we explored ways to limit abusive access to websites
    running under NGINX. Now we will take a look at ways to restrict access to a whole
    website or certain parts of it. Access restriction can take two forms here: restricting
    to a certain set of IP addresses, or restricting to a certain set of users. These
    two methods can also be combined to satisfy requirements that some users can access
    the website either from a certain set of IP addresses or if they are able to authenticate
    with a valid username and password.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following directives will help us achieve these goals:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table: HTTP access module directives'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| Directive | Explanation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `allow` | Allows access from this IP address, network, or `all`. |'
  prefs: []
  type: TYPE_TB
- en: '| `auth_basic` | Enables authentication using HTTP Basic Authentication. The
    parameter string is used as the realm name. If the special value `off` is used,
    this indicates that the `auth_basic` value of the parent configuration level is
    negated. |'
  prefs: []
  type: TYPE_TB
- en: '| `auth_basic_user_file` | Indicates the location of a file of `username:password:comment`
    tuples used to authenticate users. The `password` field needs to be encrypted
    with the crypt algorithm. The `comment` field is optional. |'
  prefs: []
  type: TYPE_TB
- en: '| `deny` | Denies access from this IP address, network, or `all`. |'
  prefs: []
  type: TYPE_TB
- en: '| `satisfy` | Allows access if `all` or `any` of the preceding directives grant
    access. The default value `all` indicates that a user must come from a specific
    network address and enter the correct password. |'
  prefs: []
  type: TYPE_TB
- en: 'To restrict access to clients coming from a certain set of IP addresses, the
    `allow` and `deny` directives can be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This configuration will allow access to the `/stats` URI from the localhost
    only.
  prefs: []
  type: TYPE_NORMAL
- en: 'To restrict access to authenticated users, the `auth_basic` and `auth_basic_user_`
    `file` directives are used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Any user wanting to access `restricted.example.com` would need to provide credentials
    matching those in the `htpasswd` file located in the `conf` directory of NGINX''s
    root. The entries in the `htpasswd` file can be generated using any available
    tool that uses the standard UNIX `crypt()` function. For example, the following
    Ruby script will generate a file of the appropriate format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Save this file as `http_auth_basic.rb` and give it a filename (`-f`), a user
    (`-u`), and a password (`-p`), and it will generate entries appropriate to use
    in NGINX''s `auth_basic_user_file` directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To handle scenarios where a username and password should only be entered if
    not coming from a certain set of IP addresses, NGINX has the `satisfy` directive.
    The `any` parameter is used here for this either/or scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If, instead, the requirements are for a configuration in which the user must
    come from a certain IP address and provide authentication, the `all` parameter
    is the default. So, we omit the `satisfy` directive itself and include only `allow`,
    `deny`, `auth_basic`, and `auth_basic_user_file`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Streaming media files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NGINX is capable of serving certain video media types. The `flv` and `mp4` modules,
    included in the base distribution, can perform what is called **pseudo-streaming**.
    This means that NGINX will seek to a certain location in the video file, as indicated
    by the `start` request parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use the pseudo-streaming capabilities, the corresponding module
    needs to be included at compile time: `--with-http_flv_module` for Flash Video
    (FLV) files and/or `--with-http_mp4_module` for H.264/AAC files. The following
    directives will then become available for configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table: HTTP streaming directives'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| Directive | Explanation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `flv` | Activates the `flv` module for this location. |'
  prefs: []
  type: TYPE_TB
- en: '| `mp4` | Activates the `mp4` module for this location. |'
  prefs: []
  type: TYPE_TB
- en: '| `mp4_buffer_size` | Sets the initial buffer size for delivering MP4 files.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `mp4_max_buffer_size` | Sets the maximum size of the buffer used to process
    MP4 metadata. |'
  prefs: []
  type: TYPE_TB
- en: 'Activating FLV pseudo-streaming for a location is as simple as just including
    the `flv` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'There are more options for MP4 pseudo-streaming, as the H.264 format includes
    metadata that needs to be parsed. Seeking is available once the "moov atom" has
    been parsed by the player. So to optimize performance, ensure that the metadata
    is at the beginning of the file. If an error message such as the following shows
    up in the logs, the `mp4_max_buffer_size` needs to be increased:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '`mp4_max_buffer_size` can be increased as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Predefined variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'NGINX makes constructing configurations based on the values of variables easy.
    Not only can you instantiate your own variables by using the `set` or `map` directives,
    but there are also predefined variables used within NGINX. They are optimized
    for quick evaluation and the values are cached for the lifetime of a request.
    You can use any of them as a key in an `if` statement, or pass them on to a proxy.
    A number of them may prove useful if you define your own log file format. If you
    try to redefine any of them, though, you will get an error message as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: They are also not made for macro expansion in the configuration—they are mostly
    used at run time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the variables and their values defined in the `http` module:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table: HTTP variables'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| Variable Name | Value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `$arg_name` | The `name` argument present in the request parameters. |'
  prefs: []
  type: TYPE_TB
- en: '| `$args` | All of the request parameters. |'
  prefs: []
  type: TYPE_TB
- en: '| `$binary_remote_addr` | The client''s IP address in binary form (always 4
    bytes long). |'
  prefs: []
  type: TYPE_TB
- en: '| `$content_length` | The value of the `Content-Length` request header. |'
  prefs: []
  type: TYPE_TB
- en: '| `$content_type` | The value of the `Content-Type` request header. |'
  prefs: []
  type: TYPE_TB
- en: '| `$cookie_name` | The cookie labeled `name`. |'
  prefs: []
  type: TYPE_TB
- en: '| `$document_root` | The value of the `root` or `alias` directive for the current
    request. |'
  prefs: []
  type: TYPE_TB
- en: '| `$document_uri` | An alias for `$uri`. |'
  prefs: []
  type: TYPE_TB
- en: '| `$host` | The value of the `Host` request header, if present. If this header
    is not present, the value is equal to the `server_name` matching the request.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `$hostname` | The name of the host where NGINX is running. |'
  prefs: []
  type: TYPE_TB
- en: '| `$http_name` | The value of the `name` request header. If this header has
    dashes, they are converted to underscores; capital letters to lower case. |'
  prefs: []
  type: TYPE_TB
- en: '| `$https` | If the connection was made over SSL, the value of this variable
    is `on`. Otherwise, it''s an empty string. |'
  prefs: []
  type: TYPE_TB
- en: '| `$is_args` | If the request has arguments, the value of this variable is
    `?`. Otherwise, it''s an empty string. |'
  prefs: []
  type: TYPE_TB
- en: '| `$limit_rate` | The value of the `limit_rate` directive. If not set, allows
    rate limitation to be set using this variable. |'
  prefs: []
  type: TYPE_TB
- en: '| `$nginx_version` | The version of the running `nginx` binary. |'
  prefs: []
  type: TYPE_TB
- en: '| `$pid` | The process ID of the worker process. |'
  prefs: []
  type: TYPE_TB
- en: '| `$query_string` | An alias for `$args`. |'
  prefs: []
  type: TYPE_TB
- en: '| `$realpath_root` | The value of the `root` or `alias` directive for the current
    request, with all symbolic links resolved. |'
  prefs: []
  type: TYPE_TB
- en: '| `$remote_addr` | The client''s IP address. |'
  prefs: []
  type: TYPE_TB
- en: '| `$remote_port` | The client''s port. |'
  prefs: []
  type: TYPE_TB
- en: '| `$remote_user` | When using HTTP basic authentication, this variable is set
    to the username. |'
  prefs: []
  type: TYPE_TB
- en: '| `$request` | The complete request, as received from the client, including
    the HTTP method, URI, HTTP protocol, header, and request body. |'
  prefs: []
  type: TYPE_TB
- en: '| `$request_body` | The body of the request, for use in locations processed
    by a `*_pass directive`. |'
  prefs: []
  type: TYPE_TB
- en: '| `$request_body_file` | The path to the temporary file where the request''s
    body is saved. For this file to be saved, the `client_body_in_file_only` directive
    needs to be set to `on`. |'
  prefs: []
  type: TYPE_TB
- en: '| `$request_completion` | If the request has completed, the value of this variable
    is `OK`. Otherwise, it''s an empty string. |'
  prefs: []
  type: TYPE_TB
- en: '| `$request_filename` | The path to the file for the current request, based
    on the value of the `root` or `alias` directive plus the URI. |'
  prefs: []
  type: TYPE_TB
- en: '| `$request_method` | The HTTP method used in the current request. |'
  prefs: []
  type: TYPE_TB
- en: '| `$request_uri` | The complete request URI, as received from the client, including
    arguments. |'
  prefs: []
  type: TYPE_TB
- en: '| `$scheme` | The scheme for the current request, either HTTP or HTTPS. |'
  prefs: []
  type: TYPE_TB
- en: '| `$sent_http_name` | The value of the `name` response header. If this header
    has dashes, they are converted to underscores; capital letters to lower case.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `$server_addr` | The value of the server''s address that accepted the request.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `$server_name` | The `server_name` of the virtual host that accepted the
    request. |'
  prefs: []
  type: TYPE_TB
- en: '| `$server_port` | The value of the server''s port that accepted the request.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `$server_protocol` | The HTTP protocol used in the current request. |'
  prefs: []
  type: TYPE_TB
- en: '| `$status` | The response''s status. |'
  prefs: []
  type: TYPE_TB
- en: '| `$tcpinfo_rtt``$tcpinfo_rttvar``$tcpinfo_snd_cwnd``$tcpinfo_rcv_space` |
    If a system supports the `TCP_INFO` socket option, these variables will be filled
    with the relevant information. |'
  prefs: []
  type: TYPE_TB
- en: '| `$uri` | The normalized URI of the current request. |'
  prefs: []
  type: TYPE_TB
- en: Using NGINX with PHP-FPM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apache has long been considered the only option for serving PHP websites because
    the `mod_php` Apache module makes integrating PHP directly into the web server
    an easy task. With **PHP-FPM** being accepted into PHP's core, there is now an
    alternative bundled with the PHP distribution. PHP-FPM is a way of running PHP
    under a FastCGI server. The PHP-FPM master process takes care of spawning workers,
    adapting to site usage, and restarting sub processes when necessary. It communicates
    with other services using the FastCGI protocol. You can learn more about PHP-FPM
    itself at [http://php.net/manual/en/install.fpm.php](http://php.net/manual/en/install.fpm.php).
  prefs: []
  type: TYPE_NORMAL
- en: NGINX has a `fastcgi` module, which is capable of communicating not only with
    PHP-FPM, but also with any FastCGI-compliant server. It is enabled by default,
    so no special consideration needs to be made to start using NGINX with FastCGI
    servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table: FastCGI directives'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| Directive | Explanation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `fastcgi_buffer_size` | The size of the buffer used for the first part of
    the response from the FastCGI server, in which the response headers are found.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `fastcgi_buffers` | The number and size of buffers used for the response
    from a FastCGI server, for a single connection. |'
  prefs: []
  type: TYPE_TB
- en: '| `fastcgi_busy_buffers_size` | The total size of buffer space allocated to
    sending the response to the client while still being read from the FastCGI server.
    This is typically set to two `fastcgi_buffers`. |'
  prefs: []
  type: TYPE_TB
- en: '| `fastcgi_cache` | Defines a shared memory zone to be used for caching. |'
  prefs: []
  type: TYPE_TB
- en: '| `fastcgi_cache_bypass` | One or more string variables, which when non-empty
    or non-zero, will cause the response to be taken from the FastCGI server instead
    of the cache. |'
  prefs: []
  type: TYPE_TB
- en: '| `fastcgi_cache_key` | A string used as the key for storing and retrieving
    cache values. |'
  prefs: []
  type: TYPE_TB
- en: '| `fastcgi_cache_lock` | Enabling this directive will prevent multiple requests
    from making an entry into the same cache key. |'
  prefs: []
  type: TYPE_TB
- en: '| `fastcgi_cache_lock_timeout` | The length of time a request will wait for
    an entry to appear in the cache or for the `fastcgi_cache_lock` to be released.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `fastcgi_cache_min_uses` | The number of requests for a certain key needed
    before a response is cached. |'
  prefs: []
  type: TYPE_TB
- en: '| `fastcgi_cache_path` | A directory in which to place the cached responses
    and a shared memory zone (`keys_zone = name:size`) to store active keys and response
    metadata. Optional parameters are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`levels`: Colon-separated length of subdirectory name at each level (one or
    two), maximum of three levels deep'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`inactive`: The maximum length of time an inactive response stays in the cache
    before being ejected'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max_size`: The maximum size of the cache; when the size exceeds this value,
    a cache manager process removes the least recently used items'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`loader_files`: The maximum number of cached files whose metadata are loaded
    per iteration of the cache loader process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`loader_sleep`: The number of milliseconds paused between each iteration of
    the cache loader process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`loader_threshold`: The maximum length of time a cache loader iteration may
    take'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `fastcgi_cache_use_stale` | The cases under which it is acceptable to serve
    stale cached data if an error occurs when accessing the FastCGI server. The `updating`
    parameter indicates the case when fresh data are being loaded. |'
  prefs: []
  type: TYPE_TB
- en: '| `fastcgi_cache_valid` | Indicates the length of time for which a cached response
    with response code 200, 301, or 302 is valid. If an optional response code is
    given before the time parameter, that time is only for that response code. The
    special parameter `any` indicates that any response code should be cached for
    that length of time. |'
  prefs: []
  type: TYPE_TB
- en: '| `fastcgi_connect_timeout` | The maximum amount of time NGINX will wait for
    its connection to be accepted when making a request to a FastCGI server. |'
  prefs: []
  type: TYPE_TB
- en: '| `fastcgi_hide_header` | A list of header fields that should not be passed
    on to the client. |'
  prefs: []
  type: TYPE_TB
- en: '| `fastcgi_ignore_client_abort` | If set to `on`, NGINX will not abort the
    connection to a FastCGI server if the client aborts the connection. |'
  prefs: []
  type: TYPE_TB
- en: '| `fastcgi_ignore_headers` | Sets which headers may be disregarded when processing
    the response from the FastCGI server. |'
  prefs: []
  type: TYPE_TB
- en: '| `fastcgi_index` | Sets the name of a file to be appended to `$fastcgi_script_name`
    that ends with a slash. |'
  prefs: []
  type: TYPE_TB
- en: '| `fastcgi_intercept_errors` | If enabled, NGINX will display a configured
    `error_page` instead of the response directly from the FastCGI server. |'
  prefs: []
  type: TYPE_TB
- en: '| `fastcgi_keep_conn` | Enables `keepalive` connections to FastCGI servers
    by instructing the server not to immediately close the connection. |'
  prefs: []
  type: TYPE_TB
- en: '| `fastcgi_max_temp_file_size` | The maximum size of the overflow file, written
    when the response doesn''t fit into memory buffers. |'
  prefs: []
  type: TYPE_TB
- en: '| `fastcgi_next_upstream` | Indicates the conditions under which the next FastCGI
    server will be selected for the response. This won''t be used if the client has
    already been sent something. The conditions are specified using the following
    parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`error`: An error occurred while communicating with the FastCGI server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`timeout`: A timeout occurred while communicating with the FastCGI server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`invalid_header`: The FastCGI server returned an empty or otherwise invalid
    response'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http_500`: The FastCGI server responded with a 500 error code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http_503`: The FastCGI server responded with a 503 error code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http_404`: The FastCGI server responded with a 404 error code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`off`: Disables passing the request to the next FastCGI server when an error
    occurs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `fastcgi_no_cache` | One or more string variables, which when non-empty or
    non-zero, will instruct NGINX to not save the response from the FastCGI server
    in the cache. |'
  prefs: []
  type: TYPE_TB
- en: '| `fastcgi_param` | Sets a parameter and its value to be passed to the FastCGI
    server. If the parameter should only be passed when the value is non-empty, the
    `if_not_empty` additional parameter should be set. |'
  prefs: []
  type: TYPE_TB
- en: '| `fastcgi_pass` | Specifies the FastCGI server to which the request is passed,
    either as an `address:port` combination or as `unix:path` for a UNIX-domain socket.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `fastcgi_pass_header` | Overrides the disabled headers set in `fastcgi_hide_header`,
    allowing them to be sent to the client. |'
  prefs: []
  type: TYPE_TB
- en: '| `fastcgi_read_timeout` | Specifies the length of time that needs to elapse
    between two successive read operations from a FastCGI server before the connection
    is closed. |'
  prefs: []
  type: TYPE_TB
- en: '| `fastcgi_send_timeout` | The length of time that needs to elapse between
    two successive write operations to a FastCGI server before the connection is closed.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `fastcgi_split_path_info` | Defines a regular expression with two captures.
    The first capture will be the value of the `$fastcgi_script_name` variable. The
    second capture becomes the value of the `$fastcgi_path_info` variable. Only necessary
    for applications that rely upon `PATH_INFO`. |'
  prefs: []
  type: TYPE_TB
- en: '| `fastcgi_store` | Enables storing responses retrieved from a FastCGI server
    as files on disk. The `on` parameter will use the `alias` or `root` directive
    as the base path under which to store the file. A string may instead be given,
    to indicate an alternative location to store the files. |'
  prefs: []
  type: TYPE_TB
- en: '| `fastcgi_store_access` | Sets file access permissions for newly-created `fastcgi_store`
    files. |'
  prefs: []
  type: TYPE_TB
- en: '| `fastcgi_temp_file_write_size` | Limits the amount of data buffered to a
    temporary file at one time, so that NGINX will not block too long on a single
    request. |'
  prefs: []
  type: TYPE_TB
- en: '| `fastcgi_temp_path` | A directory where temporary files may be buffered as
    they are proxied from the FastCGI server, optionally multilevel deep. |'
  prefs: []
  type: TYPE_TB
- en: An example Drupal configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Drupal ([http://drupal.org](http://drupal.org)) is a popular open source content
    management platform. There is a large installed user base, and many popular websites
    are run on Drupal. As with most PHP web frameworks, Drupal is typically run under
    Apache using `mod_php`. We are going to explore how to configure NGINX to run
    Drupal.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a very comprehensive Drupal configuration guide for NGINX found at
    [https://github.com/perusio/drupal-with-nginx](https://github.com/perusio/drupal-with-nginx).
    It goes more in-depth than we are able to do here, but we will point out some
    features mentioned, and go through some of the differences between Drupal 6 and
    Drupal 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The Advanced Aggregation module configuration coming up next differs only in
    the `location` used. The Advanced Aggregation module configuration for CSS is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'And for JavaScript is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The common lines to both sections are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Serving audio files exemplifies the use of AIO. The MP3 `location` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'And Ogg/Vorbis `location` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'These have the following lines in common:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The next two pseudo-streaming sections are also similar. The pseudo-streaming
    for H264 file is specified in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'And pseudo-streaming for AAC files is specified in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'These have the following common between them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The following `locations` all have `return 404` in order to deny access:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `include` files mentioned above are not reproduced here, for brevity's sake.
    They can be found in perusio's GitHub repository mentioned at the beginning of
    this section.
  prefs: []
  type: TYPE_NORMAL
- en: Wiring NGINX and uWSGI together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Python **WSGI** (**Web Server Gateway Interface**) is an interface specification
    formalized as PEP-3333 ([http://www.python.org/dev/peps/pep-3333/](http://www.python.org/dev/peps/pep-3333/)).
    Its purpose is to provide a "standard interface between web servers and Python
    web applications or frameworks to promote web application portability across a
    variety of web servers". Due to its popularity in the Python community, a number
    of other languages have implementations that conform to the WSGI specification.
    The uWSGI server, although not written exclusively for Python, provides a way
    of running applications that conform to this specification. The native protocol
    used to communicate with the uWSGI server is called uwsgi. More details about
    the uWSGI server, including installation instructions, example configurations,
    and other supported languages can be found at [http://projects.unbit.it/uwsgi/](http://projects.unbit.it/uwsgi/)
    and [https://github.com/unbit/uwsgi-docs](https://github.com/unbit/uwsgi-docs).
  prefs: []
  type: TYPE_NORMAL
- en: NGINX's `uwsgi` module can be configured to talk to this server using directives
    similar to the `fastcgi_*` directives discussed in the previous section. Most
    directives have the same meaning as their FastCGI counterparts, with the obvious
    difference being that they begin with `uwsgi_` instead of `fastcgi_`. There are
    a few exceptions however—`uwsgi_modifier1` and `uwsgi_modifier2`, as well as `uwsgi_string`.
    The first two directives set either the first or second modifier, respectively,
    of the uwsgi packet header. `uwsgi_string` enables NGINX to pass an arbitrary
    string to uWSGI, or any other uwsgi server that supports the eval modifier. These
    modifiers are specific to the uwsgi protocol. A table of valid values and their
    meanings can be found at [http://uwsgi-docs.readthedocs.org/en/latest/Protocol.html](http://uwsgi-docs.readthedocs.org/en/latest/Protocol.html).
  prefs: []
  type: TYPE_NORMAL
- en: An example Django configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Django ([https://www.djangoproject.com/](https://www.djangoproject.com/)) is
    a Python web framework in which developers can quickly create high-performing
    web applications. It has become a popular framework in which many different kinds
    of web applications are written.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following configuration is an example of how to connect NGINX to multiple
    Django applications running under an Emperor mode uWSGI server with FastRouter
    activated. See the URLs embedded in the comments in the following code for more
    information about running uWSGI like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This enables multiple sites to be dynamically hosted without changing the NGINX
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have explored a number of directives used to make NGINX
    serve files over HTTP. Not only does the `http` module provide this functionality,
    but there are also a number of helper modules that are essential to the normal
    operation of NGINX. These helper modules are enabled by default. Combining the
    directives of these various modules enables us to build a configuration that meets
    our needs. We explored how NGINX finds files based on the URI requested. We examined
    how different directives control how the HTTP server interacts with the client,
    and how the `error_page` directive can be used to serve a number of needs. Limiting
    access based on bandwidth usage, request rate, and number of connections is all
    possible.
  prefs: []
  type: TYPE_NORMAL
- en: We saw, too, how we can restrict access based on either IP address or through
    requiring authentication. We explored how to use NGINX's logging capabilities
    to capture just the information we want. Pseudo-streaming was examined briefly,
    as well. NGINX provides us with a number of variables that we can use to construct
    our configurations. We also explored the possibility of using the `fastcgi` module
    to connect to the PHP-FPM applications and the `uwsgi` module to communicate with
    a uWSGI server. The example configurations combined the directives discussed in
    this chapter, as well as some discussed in other chapters.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will introduce some modules that will help you as a developer
    integrate NGINX into your application.
  prefs: []
  type: TYPE_NORMAL
