- en: 'Chapter 5. Let''s be Secure: Security Modules'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up HTTP auth for access control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating a secure link for files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up HTTPS for a simple site
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using non standard error codes for debugging SSL setup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using wildcard certificates with multiple servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Nginx SSL variables for rewrite rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Internet security has become one of the hottest topics of research and progress
    in recent time. Most countries have government mandates to run cyber-security
    teams in conjunction with normal security forces. Nginx, due to its rather small
    footprint and clear modular design, has a distinct advantage in maintaining a
    secure codebase in comparison to lots of much larger open source web servers.
  prefs: []
  type: TYPE_NORMAL
- en: It is fair to say that there is no web server with zero exploits; the only way
    to prevent security issues is to have the right policy in place. A policy is inclusive
    of the activities that others in the system can perform and the various security
    logging mechanisms in place. However, all policies are only as good as the implementation
    through correct configuration. A simple example is that we can use simple HTTP
    authentication to prevent random people from accessing a staging site. Here, the
    policy is to prevent unknown individuals from accessing your private beta site.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we will look at how we can use the security modules built-in
    Nginx to secure your site and user's data.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up HTTP auth for access control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In recent APIs, some of the larger web properties have utilized HTTP auth as
    a way of access control for their APIs. This however, has been gradually phased
    out for OAuth based authentication in most applications. The advantage of this
    scheme is that it's fairly fast to implement and ship out as an API provider as
    it is based on HTTP headers. In this particular recipe we will set up HTTP auth
    on a particular end-point and test it out.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will first need to create the `htpasswd` file using Apache utils. This
    file basically contains the username and password hash pairs, which are used to
    authenticate the users:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding command will create a user dipankar and ask for a password from
    the command line.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now we basically add this configuration to the location portion of the configuration,
    where we want to protect the URL end-point using HTTP authentication:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now you can go to `http://www.example1.com` and test the HTTP authentication.
    If you enter `dipankar` and the password that you used earlier, you will be successfully
    able to enter, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![How to do it...](img/4965_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you are unable to enter the correct combination of username and password
    you will get the "Authorization Required" page as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/4965_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The above configuration needs an authentication file which contains the list
    of users and passwords in the traditional Apache `htpasswd` format, and you can
    use it to password-protect any part of the site that you want to.
  prefs: []
  type: TYPE_NORMAL
- en: It is just as easy to have a different set of username passwords for password
    protecting other URLs on the site; you just need to create a separate set of `htpasswd`
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a secure link for files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes the only form of security that one needs for sharing files is a special
    URL. This is useful when the data is online temporarily, or maybe has value for
    a limited period of time. Nginx provides a module for exactly that purpose as
    well. In this recipe we will look at how to quickly implement secure links for
    files on your web server.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step is to ensure that Nginx is compiled with this module, so you
    will need to make sure that you download Nginx and use the following flag during
    compilation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is to choose a secret key (for example, `superhash)` and then
    use the following configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we can test this on a file (`top_secret.html`) that we have, so the generated
    URL is of the form `http://www.example1.com/t/<md5 hash>/top_secret.html` where
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: generates the `<md5-hash>`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the above generated hash is correct, then you will be able to download the
    file. Otherwise, you will go to an Error page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![How to do it...](img/4965_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you by mistake you enter the wrong hash, you will receive a "Forbidden"
    page as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/4965_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The idea is to create a simple mechanism to have a unique and difficult URL
    to generate for a given file. In this case, the combination of the filename and
    the secret salt is used to generate the MD5 hash to form a part of the URL.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up HTTPS for a simple site
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cryptography has evolved over the ages and in today's world public key cryptography
    is pretty much the cutting edge (this is what PGP is based upon). All browsers
    implement certificate based security, allowing for safe and encrypted transactions
    on the Internet. It has proven to be one of the key factors contributing to the
    growth of e-commerce over the last decade.
  prefs: []
  type: TYPE_NORMAL
- en: Just as most browsers implement SSL based client mechanisms, all web servers
    also need to handle the server end of things. Nginx has a very clean and easy-to-configure
    implementation of SSL-based security. In this recipe we will have a look at how
    easy it is to get a pair of certificates and quickly set up a secure site.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Initially, you will need to buy a certificate from one of the known Certificate
    Authority (CAs) or obtain it from a free, public CA such as CAcert. Alternatively
    you can generate a certificate yourself. You can read more about this by picking
    up a Packt publications book on server security. These certificates basically
    come with 2 files, one of which is the certificate and the other a key. Let's
    say they are called `cert.pem` and `cert.key`. They are always specific to the
    domain that you are using it for.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To implement SSL on a certain end-point you will need to make sure that your
    firewall has the right ports open (80,443).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The following piece of configuration has to be placed in the configuration file
    for the particular domain (in this case [www.example1.com)](http://www.example1.com)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now you can just try out [https://www.example1.com](http://https://www.example1.com),
    and it should open without any errors. If there are errors, it implies that the
    certificates are not being validated correctly by the browser. In the following
    example we can see how Paypal ([https://www.paypal.com](https://www.paypal.com))
    has a valid certificate from Verisign Inc:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![How to do it...](img/4965_05_05b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In a lot of cases, the certificate of the site may not be correctly configured,
    or may have expired. In those cases, most modern browsers will ask the user if
    they want to navigate to such a site, as shown in the following screenshot. It
    is advised, in most cases, to remove badly configured certificates as they may
    act as a barrier for the end user.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/4965_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following image best describes the actual process of SSL authentication.
    In the configuration, we basically define the certificate and the key for the
    web server, and the rest is pretty much handled internally:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/4965OS_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s say that you do not yet want to buy certificates for your site, and
    want instead to try out SSL based security for you site. You can generate your
    certificates by following the steps below:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, change directory to where you want to create the certificate and private
    key, for example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now create the server private key. You''ll be asked for a passphrase:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the Certificate Signing Request (CSR):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Remove the necessity of entering a passphrase for starting up Nginx with SSL
    using the above private key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, sign the certificate using the above private key and CSR:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Using non standard error codes for debugging SSL setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most setups are difficult to get the first time around, and to that end Nginx
    has provided some really easy-to-use non-standard error codes for debugging your
    SSL setup.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe we will take a look at the non-standard error codes that are
    present and how to tackle SSL setup issues.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These error codes are enabled by default and are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| HTTP error codes | Error |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 495 | Error checking client certificate |'
  prefs: []
  type: TYPE_TB
- en: '| 496 | Client did not grant the required certificate |'
  prefs: []
  type: TYPE_TB
- en: '| 497 | Normal request was sent to HTTPS |'
  prefs: []
  type: TYPE_TB
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The idea is fairly simple. Nginx allows you to log these special errors that
    you can use to identify and correct SSL issues.
  prefs: []
  type: TYPE_NORMAL
- en: A simple example is that you can create a simple page that looks at all the
    Nginx variables on a particular error code for debugging purposes only. If you
    get a 495 error page it implies that the client certificate was not successfully
    checked from the CA it was issued from. This may be for reasons such as firewall
    permissions or the fact that you may have resolution issues on the web server.
    In some situations, when you get 496 it may indicate that someone is attempting
    to create some issues with your site! Most SSL attacks involve a man-in-the middle
    scenario or replay attacks where there is a small proxy server that sits in the
    middle and records all the above steps necessary to create a SSL connection, only
    to target and cause havoc at a later time.
  prefs: []
  type: TYPE_NORMAL
- en: Using wildcard certificates with multiple servers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In lots of situations, we would want to provide a lot of secured subdomains
    among unsecured ones and share resources, both across the HTTP and HTTPS subdomains.
    In this recipe we will have a look at how to configure a HTTP domain, a secured
    subdomain and a directory shared on both HTTP and HTTPS subdomains.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To achieve the above, all we need to do is to add the following to the configuration.
    It assumes that all the certificate files have been concatenated into one file
    (common.crt) and similarly all the keys have been concatenated as well (common.key):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if you visit the three different parts of the site, you will realize that
    you can access `http://www.example1.com` and `http://static.example1.com/null.gif`
    but not be able to access `https://www.example1.com` or `http://payment.example1.com/`.
    The following screenshot demonstrates `https://www.example1.com` not opening:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/4965_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The following screenshot displays the `null.gif` file being served correctly
    by Nginx, while [https://www.example1.com](http://https://www.example1.com) does
    not open as shown in the preceding screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/4965_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This particular configuration shows the versatility of Nginx. In this recipe,
    you simply turned SSL on and off depending on the domain. You had one case where
    you did not want SSL (`http://www.example1.com`), another in which you wanted
    only SSL (`https://payment.example1.com`), and a third case where both the SSL
    and non-SSL URLs were enabled for the files in a particular directory (/var/www/www.example1.com/static).
  prefs: []
  type: TYPE_NORMAL
- en: Using Nginx SSL variables for rewrite rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Nginx has a very smart and well-designed rewrite system. It even allows you
    to access SSL variables for your rewrite rules. In this recipe, we will explore
    a simple example to see what we can do with these variables. You can explore more
    about rewrite rules in [Chapter 2](ch02.html "Chapter 2. All About Rewrites: The
    Rewrite Module") which focuses on rewrites.'
  prefs: []
  type: TYPE_NORMAL
- en: We will basically check if the SSL verification ($ssl_client_verify) was a success
    and show a different set of pages if it was not.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Inserting this configuration in your file will basically result in showing
    the user a different site if the SSL client certificate is successfully verified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This simple example has a look at how we caused the client certificate validation
    to redirect the client to a different part of the site (in this case `http://www.example1.com/test/)`.
  prefs: []
  type: TYPE_NORMAL
- en: You can use other variables that the SSL module populates for a given session
    to do other things, like protocol based logging and more.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can access the following variables that can be utilized in creating interesting
    rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '| SSL variable | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `$ssl_cipher` | This returns the cipher suite being used for the currently
    established SSL/TLS connection. |'
  prefs: []
  type: TYPE_TB
- en: '| `$ssl_client_serial` | This returns the serial number of the client certificate
    for the currently established SSL/TLS connection, if applicable. That is, if client
    authentication is activated in the connection. |'
  prefs: []
  type: TYPE_TB
- en: '| `$ssl_client_s_dn` | This returns the subject Distinguished Name (DN) of
    the client certificate for the currently established SSL/TLS connection, if applicable.
    That is, if client authentication is activated in the connection. |'
  prefs: []
  type: TYPE_TB
- en: '| `$ssl_client_i_dn` | This returns the issuer DN of the client certificate
    for the currently established SSL/TLS connection, if applicable. That is, if client
    authentication is activated in the connection. |'
  prefs: []
  type: TYPE_TB
- en: '| `$ssl_protocol` | This returns the protocol of the currently established
    SSL/TLS connection, depending on the configuration and client available options,
    it''s one of SSLv2, SSLv3, or TLSv1. |'
  prefs: []
  type: TYPE_TB
- en: '| `$ssl_session_id` | The Session ID of the established secure connection—requires
    Nginx version greater or equal to 0.8.20. |'
  prefs: []
  type: TYPE_TB
- en: '| `$ssl_client_cert` | Returns the client certificate installed for the particular
    domain. |'
  prefs: []
  type: TYPE_TB
- en: '| `$ssl_client_raw_cert` | Returns the raw client certificate. |'
  prefs: []
  type: TYPE_TB
- en: '| `$ssl_client_verify` | Takes the value "SUCCESS" when the client certificate
    is successfully verified. |'
  prefs: []
  type: TYPE_TB
