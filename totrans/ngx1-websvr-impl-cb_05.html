<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Let's be Secure: Security Modules"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Let's be Secure: Security Modules</h1></div></div></div><p>In this chapter, we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Setting up HTTP auth for access control</li><li class="listitem" style="list-style-type: disc">Generating a secure link for files</li><li class="listitem" style="list-style-type: disc">Setting up HTTPS for a simple site</li><li class="listitem" style="list-style-type: disc">Using non standard error codes for debugging SSL setup</li><li class="listitem" style="list-style-type: disc">Using wildcard certificates with multiple servers</li><li class="listitem" style="list-style-type: disc">Using Nginx SSL variables for rewrite rules</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec01"/>Introduction</h1></div></div></div><p>Internet security has become one of the hottest topics of research and progress in recent time. Most countries have government mandates to run cyber-security teams in conjunction with normal security forces. Nginx, due to its rather small footprint and clear modular design, has a distinct advantage in maintaining a secure codebase in comparison to lots of much larger open source web servers.<a class="indexterm" id="id118"/>
</p><p>It is fair to say that there is no web server with zero exploits; the only way to prevent security issues is to have the right policy in place. A policy is inclusive of the activities that others in the system can perform and the various security logging mechanisms in place. However, all policies are only as good as the implementation through correct configuration. A simple example is that we can use simple HTTP authentication to prevent random people from accessing a staging site. Here, the policy is to prevent unknown individuals from accessing your private beta site.<a class="indexterm" id="id119"/>
<a class="indexterm" id="id120"/>
</p><p>In this chapter we will look at how we can use the security modules built-in Nginx to secure your site and user's data.</p></div></div>
<div class="section" title="Setting up HTTP auth for access control"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec02"/>Setting up HTTP auth for access control</h1></div></div></div><p>In recent APIs, some of the larger web properties have utilized HTTP auth as a way of access control for their APIs. This however, has been gradually phased out for OAuth based authentication in most applications. The advantage of this scheme is that it's fairly fast to implement and ship out as an API provider as it is based on HTTP headers. In this particular recipe we will set up HTTP auth on a particular end-point and test it out.<a class="indexterm" id="id121"/>
</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec01"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"> You will first need to create the<code class="literal"> htpasswd</code> file using Apache utils. This file basically contains the username and password hash pairs, which are used to authenticate the users:<div class="informalexample"><pre class="programlisting">htpasswd c /etc/nginx/user_auth dipankar
</pre></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: none">The preceding command will create a user dipankar and ask for a password from the command line.</li></ul></div></li><li class="listitem"> Now we basically add this configuration to the location portion of the configuration, where we want to protect the URL end-point using HTTP authentication:<div class="informalexample"><pre class="programlisting">server {
server_name www.example1.com;
. . .
location / {
auth_basic "Restricted";
auth_basic_user_file /etc/nginx/user_auth;
. . .
}
}
</pre></div></li><li class="listitem"> Now you can go to<code class="literal"> http://www.example1.com</code> and test the HTTP authentication. If you enter<code class="literal"> dipankar</code> and the password that you used earlier, you will be successfully able to enter, as shown in the following screenshot:</li></ol></div><div class="mediaobject"><img alt="How to do it..." height="191" src="graphics/4965_05_01.jpg"/></div><p>If you are unable to enter the correct combination of username and password you will get the "Authorization Required" page as in the following screenshot:<a class="indexterm" id="id122"/>
</p><div class="mediaobject"><img alt="How to do it..." height="108" src="graphics/4965_05_02.jpg"/></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec02"/>How it works...</h2></div></div></div><p>The above configuration needs an authentication file which contains the list of users and passwords in the traditional Apache<code class="literal"> htpasswd</code> format, and you can use it to password-protect any part of the site that you want to.<a class="indexterm" id="id123"/>
</p><p>It is just as easy to have a different set of username passwords for password protecting other URLs on the site; you just need to create a separate set of<code class="literal"> htpasswd</code> files.</p></div></div>
<div class="section" title="Generating a secure link for files"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec03"/>Generating a secure link for files</h1></div></div></div><p>Sometimes the only form of security that one needs for sharing files is a special URL. This is useful when the data is online temporarily, or maybe has value for a limited period of time. Nginx provides a module for exactly that purpose as well. In this recipe we will look at how to quickly implement secure links for files on your web server.<a class="indexterm" id="id124"/>
</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec03"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"> The first step is to ensure that Nginx is compiled with this module, so you will need to make sure that you download Nginx and use the following flag during compilation:<div class="informalexample"><pre class="programlisting">./configure . . . --with-http_secure_link_module
</pre></div></li><li class="listitem"> The next step is to choose a secret key (for example,<code class="literal"> superhash)</code> and then use the following configuration:<div class="informalexample"><pre class="programlisting">location /t/ {
secure_link_secret superhash;
# If the hash is incorrect then $secure_link has the value of the null string.
if ($secure_link = "") {
return 403;
}
# This needs to be here otherwise you'll get a 404.
rewrite ^ /t/$secure_link break;
}
</pre></div></li><li class="listitem"> Now we can test this on a file (<code class="literal">top_secret.html</code>) that we have, so the generated URL is of the form<code class="literal"> http://www.example1.com/t/&lt;md5 hash&gt;/top_secret.html</code> where<div class="informalexample"><pre class="programlisting">echo -n 'top_secret.htmlsuperhash' | openssl dgst -md5
</pre></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: none">generates the <code class="literal">&lt;md5-hash&gt;
</code></li></ul></div></li><li class="listitem"> If the above generated hash is correct, then you will be able to download the file. Otherwise, you will go to an Error page:<a class="indexterm" id="id125"/></li></ol></div><div class="mediaobject"><img alt="How to do it..." height="203" src="graphics/4965_05_03.jpg"/></div><p>If you by mistake you enter the wrong hash, you will receive a "Forbidden" page as shown in the following screenshot:</p><div class="mediaobject"><img alt="How to do it..." height="227" src="graphics/4965_05_04.jpg"/></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec04"/>How it works...</h2></div></div></div><p>The idea is to create a simple mechanism to have a unique and difficult URL to generate for a given file. In this case, the combination of the filename and the secret salt is used to generate the MD5 hash to form a part of the URL.<a class="indexterm" id="id126"/>
</p></div></div>
<div class="section" title="Setting up HTTPS for a simple site"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec04"/>Setting up HTTPS for a simple site</h1></div></div></div><p>Cryptography has evolved over the ages and in today's world public key cryptography is pretty much the cutting edge (this is what PGP is based upon). All browsers implement certificate based security, allowing for safe and encrypted transactions on the Internet. It has proven to be one of the key factors contributing to the growth of e-commerce over the last decade.<a class="indexterm" id="id127"/>
</p><p>Just as most browsers implement SSL based client mechanisms, all web servers also need to handle the server end of things. Nginx has a very clean and easy-to-configure implementation of SSL-based security. In this recipe we will have a look at how easy it is to get a pair of certificates and quickly set up a secure site.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec05"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"> Initially, you will need to buy a certificate from one of the known Certificate Authority (CAs) or obtain it from a free, public CA such as CAcert. Alternatively you can generate a certificate yourself. You can read more about this by picking up a Packt publications book on server security. These certificates basically come with 2 files, one of which is the certificate and the other a key. Let's say they are called<code class="literal"> cert.pem</code> and<code class="literal"> cert.key</code>. They are always specific to the domain that you are using it for.<a class="indexterm" id="id128"/></li><li class="listitem"> To implement SSL on a certain end-point you will need to make sure that your firewall has the right ports open (80,443).</li><li class="listitem"> The following piece of configuration has to be placed in the configuration file for the particular domain (in this case<a class="ulink" href="http://www.example1.com)"> www.example1.com)</a>.<div class="informalexample"><pre class="programlisting">server {
server_name www.example1.com;
listen 443 default ssl;
ssl_certificate /usr/local/nginx/conf/cert.pem;
ssl_certificate_key /usr/local/nginx/conf/cert.key;
. . .
}
</pre></div></li><li class="listitem"> Now you can just try out<a class="ulink" href="http://https://www.example1.com"> https://www.example1.com</a>, and it should open without any errors. If there are errors, it implies that the certificates are not being validated correctly by the browser. In the following example we can see how Paypal (<a class="ulink" href="https://www.paypal.com">https://www.paypal.com</a>) has a valid certificate from Verisign Inc:<a class="indexterm" id="id129"/></li></ol></div><div class="mediaobject"><img alt="How to do it..." src="graphics/4965_05_05b.jpg" width="217"/></div><p>In a lot of cases, the certificate of the site may not be correctly configured, or may have expired. In those cases, most modern browsers will ask the user if they want to navigate to such a site, as shown in the following screenshot. It is advised, in most cases, to remove badly configured certificates as they may act as a barrier for the end user.<a class="indexterm" id="id130"/>
</p><div class="mediaobject"><img alt="How to do it..." height="185" src="graphics/4965_05_06.jpg"/></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec06"/>How it works...</h2></div></div></div><p>The following image best describes the actual process of SSL authentication. In the configuration, we basically define the certificate and the key for the web server, and the rest is pretty much handled internally:<a class="indexterm" id="id131"/>
</p><div class="mediaobject"><img alt="How it works..." src="graphics/4965OS_05_07.jpg" width="302"/></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec07"/>There's more...</h2></div></div></div><p>Let's say that you do not yet want to buy certificates for your site, and want instead to try out SSL based security for you site. You can generate your certificates by following the steps below:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"> First, change directory to where you want to create the certificate and private key, for example:<a class="indexterm" id="id132"/><div class="informalexample"><pre class="programlisting">cd /usr/local/nginx/conf
</pre></div></li><li class="listitem"> Now create the server private key. You'll be asked for a passphrase:<a class="indexterm" id="id133"/><div class="informalexample"><pre class="programlisting">openssl genrsa -des3 -out server.key 1024
</pre></div></li><li class="listitem"> Create the Certificate Signing Request (CSR):<div class="informalexample"><pre class="programlisting">openssl req -new -key server.key -out server.csr
</pre></div></li><li class="listitem"> Remove the necessity of entering a passphrase for starting up Nginx with SSL using the above private key:<div class="informalexample"><pre class="programlisting">cp server.key server.key.org
openssl rsa -in server.key.org -out server.key
</pre></div></li><li class="listitem"> Finally, sign the certificate using the above private key and CSR:</li></ol></div><div class="informalexample"><pre class="programlisting">openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt
</pre></div></div></div>
<div class="section" title="Using non standard error codes for debugging SSL setup"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec06"/>Using non standard error codes for debugging SSL setup</h1></div></div></div><p>Most setups are difficult to get the first time around, and to that end Nginx has provided some really easy-to-use non-standard error codes for debugging your SSL setup.<a class="indexterm" id="id134"/>
</p><p>In this recipe we will take a look at the non-standard error codes that are present and how to tackle SSL setup issues.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec08"/>How to do it...</h2></div></div></div><p>These error codes are enabled by default and are as follows:<a class="indexterm" id="id135"/>
</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left" width="1.215"/><col style="text-align: left" width="2.69902777777778"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>HTTP error codes</p>
</th><th style="text-align: left" valign="bottom">
<p>Error</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>495</p>
</td><td style="text-align: left" valign="top">
<p>Error checking client certificate</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>496</p>
</td><td style="text-align: left" valign="top">
<p>Client did not grant the required certificate</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>497</p>
</td><td style="text-align: left" valign="top">
<p>Normal request was sent to HTTPS</p>
</td></tr></tbody></table></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec09"/>How it works...</h2></div></div></div><p>The idea is fairly simple. Nginx allows you to log these special errors that you can use to identify and correct SSL issues.<a class="indexterm" id="id136"/>
</p><p>A simple example is that you can create a simple page that looks at all the Nginx variables on a particular error code for debugging purposes only. If you get a 495 error page it implies that the client certificate was not successfully checked from the CA it was issued from. This may be for reasons such as firewall permissions or the fact that you may have resolution issues on the web server. In some situations, when you get 496 it may indicate that someone is attempting to create some issues with your site! Most SSL attacks involve a man-in-the middle scenario or replay attacks where there is a small proxy server that sits in the middle and records all the above steps necessary to create a SSL connection, only to target and cause havoc at a later time.</p></div></div>
<div class="section" title="Using wildcard certificates with multiple servers"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec08"/>Using wildcard certificates with multiple servers</h1></div></div></div><p>In lots of situations, we would want to provide a lot of secured subdomains among unsecured ones and share resources, both across the HTTP and HTTPS subdomains. In this recipe we will have a look at how to configure a HTTP domain, a secured subdomain and a directory shared on both HTTP and HTTPS subdomains.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec10"/>How to do it...</h2></div></div></div><p>To achieve the above, all we need to do is to add the following to the configuration. It assumes that all the certificate files have been concatenated into one file (common.crt) and similarly all the keys have been concatenated as well (common.key):<a class="indexterm" id="id137"/>
</p><div class="informalexample"><pre class="programlisting">http{
...
ssl_certificate common.crt;
ssl_certificate_key common.key;
server {
listen 80;
server_name www.example1.com;
location / {
...
}
}
server {
listen 443 default ssl;
server_name payment.example1.com;
location / {
...
}
}
server {
listen 80;
listen 443;
server_name static.example1.com;
location / {
root /var/www/www.example1.com/static;
}
}
</pre></div><p>Now if you visit the three different parts of the site, you will realize that you can access<code class="literal"> http://www.example1.com</code> and<code class="literal"> http://static.example1.com/null.gif</code> but not be able to access<code class="literal"> https://www.example1.com</code> or<code class="literal"> http://payment.example1.com/</code>. The following screenshot demonstrates<code class="literal"> https://www.example1.com</code> not opening:<a class="indexterm" id="id138"/>
</p><div class="mediaobject"><img alt="How to do it..." height="273" src="graphics/4965_05_08.jpg"/></div><p>The following screenshot displays the<code class="literal"> null.gif</code> file being served correctly by Nginx, while<a class="ulink" href="http://https://www.example1.com"> https://www.example1.com</a> does not open as shown in the preceding screenshot.<a class="indexterm" id="id139"/>
</p><div class="mediaobject"><img alt="How to do it..." height="297" src="graphics/4965_05_09.jpg"/></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec11"/>How it works...</h2></div></div></div><p>This particular configuration shows the versatility of Nginx. In this recipe, you simply turned SSL on and off depending on the domain. You had one case where you did not want SSL (<code class="literal">http://www.example1.com</code>), another in which you wanted only SSL (<code class="literal">https://payment.example1.com</code>), and a third case where both the SSL and non-SSL URLs were enabled for the files in a particular directory (/var/www/www.example1.com/static).<a class="indexterm" id="id140"/>
</p></div></div>
<div class="section" title="Using Nginx SSL variables for rewrite rules"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec09"/>Using Nginx SSL variables for rewrite rules</h1></div></div></div><p>Nginx has a very smart and well-designed rewrite system. It even allows you to access SSL variables for your rewrite rules. In this recipe, we will explore a simple example to see what we can do with these variables. You can explore more about rewrite rules in<a class="link" href="ch02.html" title="Chapter 2. All About Rewrites: The Rewrite Module"> Chapter 2</a> which focuses on rewrites.</p><p>We will basically check if the SSL verification ($ssl_client_verify) was a success and show a different set of pages if it was not.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec12"/>How to do it...</h2></div></div></div><p>Inserting this configuration in your file will basically result in showing the user a different site if the SSL client certificate is successfully verified:<a class="indexterm" id="id141"/>
</p><div class="informalexample"><pre class="programlisting">server {
listen ssl;
server_name www.example1.com;
if($ssl_client_verify ~* SUCCESS) {
rewrite ^ http://www.example1.com/test/;
}
location / {
...
}
location /test/ {
}
}
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec13"/>How it works...</h2></div></div></div><p>This simple example has a look at how we caused the client certificate validation to redirect the client to a different part of the site (in this case<code class="literal"> http://www.example1.com/test/)</code>.</p><p>You can use other variables that the SSL module populates for a given session to do other things, like protocol based logging and more.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec14"/>There's more...</h2></div></div></div><p>You can access the following variables that can be utilized in creating interesting rules:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left" width="1.635"/><col style="text-align: left" width="3.77555555555556"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>SSL variable</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">$ssl_cipher</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This returns the cipher suite being used for the currently established SSL/TLS connection.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">$ssl_client_serial</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This returns the serial number of the client certificate for the currently established SSL/TLS connection, if applicable. That is, if client authentication is activated in the connection.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">$ssl_client_s_dn</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This returns the subject Distinguished Name (DN) of the client certificate for the currently established SSL/TLS connection, if applicable. That is, if client authentication is activated in the connection.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">$ssl_client_i_dn</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This returns the issuer DN of the client certificate for the currently established SSL/TLS connection, if applicable. That is, if client authentication is activated in the connection.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">$ssl_protocol</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This returns the protocol of the currently established SSL/TLS connection, depending on the configuration and client available options, it's one of SSLv2, SSLv3, or TLSv1.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">$ssl_session_id</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The Session ID of the established secure connection—requires Nginx version greater or equal to 0.8.20.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">$ssl_client_cert</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Returns the client certificate installed for the particular domain.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">$ssl_client_raw_cert</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Returns the raw client certificate.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">$ssl_client_verify</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Takes the value "SUCCESS" when the client certificate is successfully verified.</p>
</td></tr></tbody></table></div></div></div></body></html>