<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Creating Your Own Module"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Creating Your Own Module</h1></div></div></div><p>Nginx allows you to extend functionality by writing new modules in plain C. This chapter gives a brief introduction to creating your own modules. It is a quick reference to the module system in Nginx, and<a id="id529" class="indexterm"/> the internal architecture of Nginx, which makes extension possible. It introduces different categories of modules and add-ons you can create at a high level. This chapter will also contain a quick introduction of NDK, a special module in Nginx used as a basis of other modules.</p><p>The topics covered are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Concept of module chaining and delegation in Nginx</li><li class="listitem" style="list-style-type: disc">Handler modules</li><li class="listitem" style="list-style-type: disc">Filter modules</li><li class="listitem" style="list-style-type: disc">Load balancer modules</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Nginx Development Toolkit</strong></span> (<span class="strong"><strong>NDK</strong></span>): The NDK is an Nginx module that is designed to extend the core <a id="id530" class="indexterm"/>functionality of the excellent Nginx web server, in a way that can be used as a basis of other Nginx modules</li><li class="listitem" style="list-style-type: disc">Sample source code of a custom Nginx module</li></ul></div><p>At the end of this chapter, the advanced users will have an idea about internal Nginx architecture, and what is the basis of creating your own third-party module. Readers should be able to know how to use NDK; the source code will help them see a very simple self-written module in action.</p><div class="section" title="Nginx module delegation"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec18"/>Nginx module delegation</h1></div></div></div><p>Nginx has a very<a id="id531" class="indexterm"/> modular architecture. All major operations that Nginx performs are carried<a id="id532" class="indexterm"/> out by modules. All Nginx modules are built in at compile time and are not loaded dynamically.</p><p>Module delegation can also be called <a id="id533" class="indexterm"/>
<span class="strong"><strong>module chaining</strong></span>. The core pretty much does the basic stuff related to setting up the connection and taking care of things related to the protocol. It then sets up a <a id="id534" class="indexterm"/>chain of modules to execute, each taking care of a certain phase or stage of request processing.</p><p>The module-based noncentralized architecture makes it possible for advanced users to develop a module that does something they want.</p><p>The following are the different types of Nginx modules.</p><div class="section" title="Handlers"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec39"/>Handlers</h2></div></div></div><p>There is a handler for each defined location in the configuration file. When the server starts up, handlers are<a id="id535" class="indexterm"/> attached or bound to a location. Ideally there should only be one handler to a location; if there are more than one defined in the configuration file, only one of them will be valid (typically the last one). Handlers end in the following three ways: <a id="id536" class="indexterm"/>successfully when all is good, fail when there is an error, or they will not process the request and will let the default handler process it.</p></div><div class="section" title="Load balancers"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec40"/>Load balancers</h2></div></div></div><p>The load balancer or <a id="id537" class="indexterm"/>upstream module forwards your requests to one of the many configured backends or upstreams. Nginx, by default, has two load-balancing modules built in: <a id="id538" class="indexterm"/>
<span class="strong"><strong>Round Robin</strong></span> and the<a id="id539" class="indexterm"/> <span class="strong"><strong>IP Hash</strong></span> method (look at <code class="literal">ngx_http_upstream_module</code>). There <a id="id540" class="indexterm"/>are other third-party modules available that allow you to do load balancing based on various hashing mechanisms, for example, Consistent Hashing.</p></div><div class="section" title="Filters"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec41"/>Filters</h2></div></div></div><p>After a handler produces a response, the filters are <a id="id541" class="indexterm"/>executed.<a id="id542" class="indexterm"/> Filters do the postprocessing on the handler's response. One example can be that you need to compress the response, or add certain headers to it. Multiple filters can associate with each location.</p><div class="section" title="Order of execution"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec56"/>Order of execution</h3></div></div></div><p>The order of execution of Nginx filters is determined when they are compiled. You can see the order of the execution<a id="id543" class="indexterm"/> after compiling the code in <code class="literal">ngx_modules.c</code>. This file is generated on the fly by the <code class="literal">modules</code> script, which is found at <code class="literal">nginx/auto/</code>. This script makes sure that it maintains the correct order of the module and filter execution.</p><p>The built-in modules do need a specific order, for example, a gzip filter should run after the header and body filters have been executed. The new custom modules are generally executed in the end.</p><p>Filters do not execute in a fully blocked manner, rather the output of the filters is streamed through the chain of filters. By default, one filter processes some data and passes it on to the <a id="id544" class="indexterm"/>next module and so on. The amount of data processed at a time is usually a multiple of the page size. Different modules, for example, gzip, allow you to adjust this value.</p></div></div></div></div>
<div class="section" title="The extended &quot;Hello world&quot; module"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec19"/>The extended "Hello world" module</h1></div></div></div><p>Now we will proceed towards creating a simple Nginx module. This module will print a configurable text in your browser whenever you enter a specific location. This is a very simple module and the idea<a id="id545" class="indexterm"/> is to just introduce the core concepts of how to create an Nginx module. This is based on and is an enhanced version of the simple Hello world module found at <a class="ulink" href="http://blog.zhuzhaoyuan.com/2009/08/creating-a-hello-world-nginx-module/">http://blog.zhuzhaoyuan.com/2009/08/creating-a-hello-world-nginx-module/</a>. This module is an example of a handler module.</p><div class="section" title="Writing and compiling a module"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec42"/>Writing and compiling a module</h2></div></div></div><p>The first thing you <a id="id546" class="indexterm"/>have to do is to obviously create a folder for your new module. Create it anywhere other than the Nginx source tree. You <a id="id547" class="indexterm"/>should create the following two files to start with:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">config</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ngx_http_hello_module.c</code></li></ul></div><p>The contents of the <code class="literal">config</code> file will depend on what kind of module you are writing.</p><p>For this simple module, it will look like the following code:</p><div class="informalexample"><pre class="programlisting">ngx_addon_name=ngx_http_hello_module
HTTP_MODULES="$HTTP_MODULES ngx_http_hello_module"
NGX_ADDON_SRCS="$NGX_ADDON_SRCS $ngx_addon_dir/ngx_http_hello_module.c"</pre></div><p>The file is quite self-explanatory. In the second line we are adding the module to a list of HTTP modules. Depending on which module type you are writing, you will need to add it to a different list. You can see the full list in the <code class="literal">modules</code> script found at <code class="literal">nginx/auto/</code>.</p><p>Before compiling,<a id="id548" class="indexterm"/> the module needs to be explicitly specified using the <code class="literal">configure</code> script as in the following code. The <code class="literal">add-module</code> list should contain a list<a id="id549" class="indexterm"/> of all third-party modules you want to include in the compilation.</p><div class="informalexample"><pre class="programlisting">./configure --add-module=path/to/your/new/module/directory</pre></div><p>This has to be followed by <code class="literal">make</code> and <code class="literal">make install</code> as usual.</p><div class="section" title="The &quot;Hello world&quot; source code"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec57"/>The "Hello world" source code</h3></div></div></div><p>The following <a id="id550" class="indexterm"/>code is from <code class="literal">ngx_http_hello_module.c:</code>
</p><div class="informalexample"><pre class="programlisting">#include &lt;ngx_config.h&gt;
#include &lt;ngx_core.h&gt;
#include &lt;ngx_http.h&gt;


static char *ngx_http_hello(ngx_conf_t *cf, void *post, void*data);

static ngx_conf_post_handler_pt ngx_http_hello_p = ngx_http_hello;

/*
 * The structure will hold the value of the
 * module directive hello
 */
typedef struct {
  ngx_str_t   name;
} ngx_http_hello_loc_conf_t;

/* The function which initializes memory for the module configuration structure       
 */
static void *
ngx_http_hello_create_loc_conf(ngx_conf_t *cf)
{
  ngx_http_hello_loc_conf_t  *conf;

  conf = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_http_hello_loc_conf_t));
  if (conf == NULL) {
    return NULL;
  }
  
  return conf;
}
/*
 * The command array or array, which holds one subarray for each module
 * directive along with a function which validates the value of the
 * directive and also initializes the main handler of this module
 */
static ngx_command_t ngx_http_hello_commands[] = {
  { ngx_string("hello"),NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,ngx_conf_set_str_slot,NGX_HTTP_LOC_CONF_OFFSET,offsetof(ngx_http_hello_loc_conf_t, name),&amp;ngx_http_hello_p },

  ngx_null_command
};


static ngx_str_t hello_string;
 
/*
 * The module context has hooks , here we have a hook for creating
 * location configuration
 */
static ngx_http_module_t ngx_http_hello_module_ctx = {
  NULL,                          /* preconfiguration */
  NULL,                          /* postconfiguration */

  NULL,                          /* create main configuration */
  NULL,                          /* init main configuration */

  NULL,                          /* create server configuration */
  NULL,                          /* merge server configuration */

  ngx_http_hello_create_loc_conf, /* create location configuration */
  NULL                           /* merge location configuration */
};


/*
 * The module which binds the context and commands
 *
 */
ngx_module_t ngx_http_hello_module = {NGX_MODULE_V1,
  &amp;ngx_http_hello_module_ctx,    /* module context */ngx_http_hello_commands,       /* module directives */NGX_HTTP_MODULE,               /* module type */NULL,                          /* init master */NULL,                          /* init module */NULL,                          /* init process */NULL,                          /* init thread */NULL,                          /* exit thread */NULL,                          /* exit process */NULL,                          /* exit master */NGX_MODULE_V1_PADDING
};

/*
 * Main handler function of the module.
 */
static ngx_int_t
ngx_http_hello_handler(ngx_http_request_t *r)
{
  ngx_int_t    rc;
  ngx_buf_t   *b;
  ngx_chain_t  out;

  /* we response to 'GET' and 'HEAD' requests only */
  if (!(r-&gt;method &amp; (NGX_HTTP_GET|NGX_HTTP_HEAD))) {
    return NGX_HTTP_NOT_ALLOWED;
  }

  /* discard request body, since we don't need it here */
  rc = ngx_http_discard_request_body(r);

  if (rc != NGX_OK) {
    return rc;
  }

  /* set the 'Content-type' header */
  r-&gt;headers_out.content_type_len = sizeof("text/html") - 1;
  r-&gt;headers_out.content_type.len = sizeof("text/html") - 1;
  r-&gt;headers_out.content_type.data = (u_char *) "text/html";

  /* send the header only, if the request type is http 'HEAD' */
  if (r-&gt;method == NGX_HTTP_HEAD) {
    r-&gt;headers_out.status = NGX_HTTP_OK;
    r-&gt;headers_out.content_length_n = hello_string.len;
    return ngx_http_send_header(r);
  }

  /* allocate a buffer for your response body */
  b = ngx_pcalloc(r-&gt;pool, sizeof(ngx_buf_t));
  if (b == NULL) {
    return NGX_HTTP_INTERNAL_SERVER_ERROR;
  }

  /* attach this buffer to the buffer chain */
  out.buf = b;
  out.next = NULL;

  /* adjust the pointers of the buffer */
  b-&gt;pos = hello_string.data;
  b-&gt;last = hello_string.data + hello_string.len;
  b-&gt;memory = 1;    /* this buffer is in memory */
  b-&gt;last_buf = 1;  /* this is the last buffer in the buffer chain*/

  /* set the status line */
  r-&gt;headers_out.status = NGX_HTTP_OK;
  r-&gt;headers_out.content_length_n = hello_string.len;

  /* send the headers of your response */
  rc = ngx_http_send_header(r);

  if (rc == NGX_ERROR || rc &gt; NGX_OK || r-&gt;header_only) {
    return rc;
  }

  /* send the buffer chain of your response */
  return ngx_http_output_filter(r, &amp;out);
}

/*
 * Function for the directive hello , it validates its value
 * and copies it to a static variable to be printed later
 */
static char *
ngx_http_hello(ngx_conf_t *cf, void *post, void *data)
{
  ngx_http_core_loc_conf_t *clcf;
  clcf = ngx_http_conf_get_module_loc_conf(cf,ngx_http_core_module);
  clcf-&gt;handler = ngx_http_hello_handler;

  ngx_str_t  *name = data; // i.e., first field ofngx_http_hello_loc_conf_t

  if (ngx_strcmp(name-&gt;data, "") == 0) {
    return NGX_CONF_ERROR;
  }
  hello_string.data = name-&gt;data;
  hello_string.len = ngx_strlen(hello_string.data);

  return NGX_CONF_OK;
}</pre></div><p>A sample<a id="id551" class="indexterm"/> configuration for this extended <code class="literal">hello world</code> module could look as follows:</p><div class="informalexample"><pre class="programlisting">server {
listen 8080;
server_name localhost;

location / {
hello 'Hello World';
  }
}</pre></div></div></div><div class="section" title="Components of the Nginx module"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec43"/>Components of the Nginx module</h2></div></div></div><p>There are many <a id="id552" class="indexterm"/>components on an Nginx module depending on the type of the module. We will now discuss those parts that are common to almost all the modules. The intention is to present to you a reference in an easy to understand way so that you can be ready to write your own module.</p><div class="section" title="Module configuration structures"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec58"/>Module configuration structures</h3></div></div></div><p>Modules can define one configuration for each of the configuration file's configuration contexts—there is an individual<a id="id553" class="indexterm"/> structure for the main, server, and location contexts. It is OK for most modules to simply have a location structure. These structures should be named as <code class="literal">convention  ngx_http_&lt;module name&gt;_(main|srv|loc)_conf_t</code>. The following is the code snippet from the sample module:</p><div class="informalexample"><pre class="programlisting">typedef struct {
  ngx_str_t   name;
} ngx_http_hello_loc_conf_t;</pre></div><p>The members of this structure should use Nginx's special data types (<code class="literal">ngx_uint_t</code>, <code class="literal">ngx_flag_t</code>, and <code class="literal">ngx_str_t</code>), which are simply aliases for basic/primitive types. You can look into <code class="literal">core/nginx_config.h</code> in the source tree for the data type definitions.</p><p>There should be as many members of this structure as the module directives. In the preceding example our module only has one directive, so we can already tell that this module will support a single directive/option at the location level, which will populate the member <code class="literal">name</code> of this structure.</p><p>As it must be obvious by now, that the elements in the configuration structure are filled by module directives defined in the configuration file.</p></div><div class="section" title="Module directives"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec59"/>Module directives</h3></div></div></div><p>After you have defined the place where the value of the module directives will be stored, it is time to define the name of the module directives and what kind and type of arguments they will accept. <a id="id554" class="indexterm"/>A module's directives are defined in a static array of the <code class="literal">ngx_command_t type</code> structure. Looking at the example code we previously wrote, the following is what the directives structure looks like:</p><div class="informalexample"><pre class="programlisting">static ngx_command_t ngx_http_hello_commands[] = {{ ngx_string("hello"),NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,ngx_conf_set_str_slot,NGX_HTTP_LOC_CONF_OFFSET,offsetof(ngx_http_hello_loc_conf_t, name),&amp;ngx_http_hello_p },

  ngx_null_command
};</pre></div><p>The preceding structure may look a little bit complicated. However, we will now look at each one of those to understand them a little better.</p><p>The first argument defines the name of the directive. This is of type <code class="literal">ngx_str</code> and is instantiated with the directive name, for example, <code class="literal">ngx_str("hello")</code>. An <code class="literal">ngx_str_t</code> data type is a struct type with data and length elements. Nginx uses this data structure for all the strings.</p><p>The second argument <a id="id555" class="indexterm"/>defines the type of the directive, and what kind of arguments it accepts. The acceptable values for these parameters should be bitwise ordered with each other. The possibilities are as follows:</p><div class="informalexample"><pre class="programlisting">NGX_HTTP_MAIN_CONF: directive should be used in main section
NGX_HTTP_SRV_CONF : directive should be used in the server section
NGX_HTTP_LOC_CONF : directive should be used in the locationsection
NGX_HTTP_UPS_CONF : directive should be used in the upstreamsection
NGX_CONF_NOARGS   : directive will take no arguments
NGX_CONF_TAKE1    : directive will take 1 argument
NGX_CONF_TAKE2    : directive will take 2 arguments
…
NGX_CONF_TAKE7    : directive will take 7 arguments
NGX_CONF_TAKE12   : directive will take 1 or 2 arguments
NGX_CONF_TAKE13   : directive will take 1 or 3 arguments   
NGX_CONF_TAKE23   : directive will take 2 or 3 arguments
NGX_CONF_TAKE123  : directive will take 1, 2 or 3 arguments
NGX_CONF_TAKE1234 : directive will take 1, 2 , 3 or 4 arguments

NGX_CONF_FLAG     : directive accepts a boolean value from "on" or"off"
NGX_CONF_1MORE    : directive requires at least one argument
NGX_CONF_2MORE    : directive requires at least at least twoarguments</pre></div><p>Please see the full details in <code class="literal">ngx_conf_file.h</code> found in the <code class="literal">core</code> folder.</p><p>The maximum number of arguments that a directive can take is eight (0-7) as defined in <code class="literal">core/ngx_conf_file.h</code>, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">#define NGX_CONF_MAX_ARGS   8</pre></div><p>In the preceding example, we only use a single element in the array, as we are providing values for a single <code class="literal">ngx_command_t</code> structure.</p><p>The third argument is a function pointer. This is a setup function that takes the value provided for the directive in the configuration file and stores it in the appropriate element of the structure. This function can take the following three arguments:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Pointer to <code class="literal">ngx_conf_t</code> (<code class="literal">main</code>, <code class="literal">srv</code>, or <code class="literal">loc</code>) structure, which contains the values of the directive in the configuration file</li><li class="listitem" style="list-style-type: disc">Pointer to the target <code class="literal">ngx_command_t</code> structure where the value will be stored</li><li class="listitem" style="list-style-type: disc">Pointer to the module's custom configuration structure (can be <code class="literal">NULL</code>)</li></ul></div><p>Nginx provides a <a id="id556" class="indexterm"/>number of functions that can be used to set the values for the built-in data types. These functions include:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ngx_conf_set_flag_slot</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ngx_conf_set_str_slot</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ngx_conf_set_str_array_slot</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ngx_conf_set_keyval_slot</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ngx_conf_set_num_slot</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ngx_conf_set_size_slot</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ngx_conf_set_off_slot</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ngx_conf_set_msec_slot</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ngx_conf_set_sec_slot</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ngx_conf_set_bufs_slot</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ngx_conf_set_enum_slot</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ngx_conf_set_bitmask_slot</code></li></ul></div><p>Some of these are described as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ngx_conf_set_flag_slot</code>: This translates <a id="id557" class="indexterm"/>on or off to 1 or 0</li><li class="listitem" style="list-style-type: disc"><code class="literal">ngx_conf_set_str_slot</code>: This <a id="id558" class="indexterm"/>saves a string as <code class="literal">ngx_str_t</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ngx_conf_set_num_slot</code>: This parses <a id="id559" class="indexterm"/>a number and saves it to an integer</li><li class="listitem" style="list-style-type: disc"><code class="literal">ngx_conf_set_size_slot</code>: This parses a <a id="id560" class="indexterm"/>data size (5k, 2m, and so on) and saves it to <code class="literal">size_t</code></li></ul></div><p>Module authors can also pass the pointer to their own function here, if the built-in functions are not sufficient for their purpose, for example, if the string needs to be interpreted in a certain way instead of just being stored as it is.</p><p>In order to specify where these built-in (or custom) functions will store the directive values, you have to specify <code class="literal">conf</code> and <code class="literal">offset</code> as the next two arguments. <code class="literal">conf</code> specifies the type of the structure where the value will be stored (<code class="literal">main</code>, <code class="literal">srv</code>, <code class="literal">loc</code>) and <code class="literal">offset</code> specifies which part of this configuration structure to store it in. The following is the <code class="literal">offset</code> of the element in the structure, that is, <code class="literal">offsetof(ngx_http_hello_loc_conf_t, name)</code>.</p><p>The last element is often <code class="literal">NULL</code>, and at the moment we can choose to ignore it.</p><p>The last element of the command array is <code class="literal">ngx_null_command</code>, which indicates the termination.</p></div><div class="section" title="The module context"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec60"/>The module context</h3></div></div></div><p>The third structure in an Nginx<a id="id561" class="indexterm"/> module that needs to be defined is a static <code class="literal">ngx_http_module_t</code> structure, which just has the function pointers for creating the <code class="literal">main</code>, <code class="literal">srv</code>, and <code class="literal">loc</code> configurations, and merging them together. Its name is <code class="literal">ngx_http_&lt;module name&gt;_module_ctx</code>. The function references that <a id="id562" class="indexterm"/>you can provide are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Pre configuration</li><li class="listitem" style="list-style-type: disc">Post configuration</li><li class="listitem" style="list-style-type: disc">Creating the main <code class="literal">conf</code></li><li class="listitem" style="list-style-type: disc">Initializing the main <code class="literal">conf</code></li><li class="listitem" style="list-style-type: disc">Creating the server <code class="literal">conf</code></li><li class="listitem" style="list-style-type: disc">Merging it with the main <code class="literal">conf</code></li><li class="listitem" style="list-style-type: disc">Creating the location <code class="literal">conf</code></li><li class="listitem" style="list-style-type: disc">Merging it with the server <code class="literal">conf</code></li></ul></div><p>These take different arguments <a id="id563" class="indexterm"/>depending on what they're doing. The following is the structure definition, taken from <code class="literal">http/ngx_http_config.h</code>, so you can see the different function signatures of the callbacks:</p><div class="informalexample"><pre class="programlisting">typedef struct {
  ngx_int_t   (*preconfiguration)(ngx_conf_t *cf);
  ngx_int_t   (*postconfiguration)(ngx_conf_t *cf);

  void       *(*create_main_conf)(ngx_conf_t *cf);
  char       *(*init_main_conf)(ngx_conf_t *cf, void *conf);

  void       *(*create_srv_conf)(ngx_conf_t *cf);
  char       *(*merge_srv_conf)(ngx_conf_t *cf, void *prev, void*conf);

  void       *(*create_loc_conf)(ngx_conf_t *cf);
  char       *(*merge_loc_conf)(ngx_conf_t *cf, void *prev, void*conf);
} ngx_http_module_t;</pre></div><p>You can set functions you don't need to <code class="literal">NULL</code>, and Nginx will accept it, and do the right thing.</p><p>The create functions such as create main <code class="literal">conf</code>, create server <code class="literal">conf</code>, and create location <code class="literal">conf</code> normally just allocate memory for the structures (such as <code class="literal">malloc()</code>) and initialize the elements as default values. The functions such as initialize main <code class="literal">conf</code>, and merge with main <code class="literal">conf</code> provide the opportunity to override the default values.</p><p>During merging, the module authors can look for duplicate definitions of elements and throw errors if there is a problem with directives provided by configuration authors in the configuration file.</p><p>Most module<a id="id564" class="indexterm"/> authors just use the last two elements as such: a function to allocate memory for <code class="literal">ngx_loc_conf</code> (<code class="literal">main</code> , <code class="literal">srv</code>, or <code class="literal">loc</code>) configuration, and a function to set defaults and merge this configuration into a merged location configuration (called <code class="literal">ngx_http_&lt;module name &gt;_merge_loc_conf</code>).</p><p>The following is an <a id="id565" class="indexterm"/>example module context structure:</p><div class="informalexample"><pre class="programlisting">/*
 * The module context has hooks , here we have a hook for creating
 * location configuration
 */
static ngx_http_module_t ngx_http_hello_module_ctx = {NULL,                          /* preconfiguration */NULL,                          /* postconfiguration */NULL,                          /* create main configuration */NULL,                          /* init main configuration */NULL,                          /* create server configuration */NULL,                          /* merge server configuration */ngx_http_hello_create_loc_conf, /* create location configuration*/NULL                           /* merge location configuration*/
};</pre></div><p>We can have a closer look now at these functions, which set up the location based on configuration.</p><div class="section" title="create_loc_conf"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl4sec106"/>create_loc_conf</h4></div></div></div><p>The <a id="id566" class="indexterm"/>following is what a basic <code class="literal">create_loc_conf</code> function looks like. It takes a directive structure (<code class="literal">ngx_conf_t</code>) and returns a module configuration<a id="id567" class="indexterm"/> structure that is newly allocated.</p><div class="informalexample"><pre class="programlisting">/* The function which initializes memory for the module configuration structure       
 */
static void *
ngx_http_hello_create_loc_conf(ngx_conf_t *cf)
{
  ngx_http_hello_loc_conf_t  *conf;

  conf = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_http_hello_loc_conf_t));
  if (conf == NULL) {
    return NULL;
  }

  return conf;
}</pre></div><p>The Nginx memory<a id="id568" class="indexterm"/> allocation takes care of freeing the memory if you use the built-ins <code class="literal">ngx_palloc</code> (a malloc wrapper) or <code class="literal">ngx_pcalloc</code> <a id="id569" class="indexterm"/> (a calloc wrapper).</p></div><div class="section" title="merge_loc_conf"><div class="titlepage"><div><div><h4 class="title"><a id="ch05lvl4sec107"/>merge_loc_conf</h4></div></div></div><p>The sample module we created does not contain a merge location <code class="literal">conf</code> function. However, we can<a id="id570" class="indexterm"/> look at the following sample code just to explain some basic concepts. You generally need a <a id="id571" class="indexterm"/>merge function if a directive can be defined multiple times. It is your job to define a merge function that can set the appropriate value in case it is defined multiple times or in multiple locations.</p><div class="informalexample"><pre class="programlisting">static char *ngx_http_example_merge_loc_conf(ngx_conf_t *cf, void *parent,void *child)
{
  ngx_http_example_loc_conf_t *prev = parent;
  ngx_http_example_loc_conf_t *conf = child;

  ngx_conf_merge_uint_value(conf-&gt;val1, prev-&gt;val1, 10);
  ngx_conf_merge_uint_value(conf-&gt;val2, prev-&gt;val2, 20);

  if (conf-&gt;val1 &lt; 1) {
    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,"value 1 must be equal or more than 1");
    return NGX_CONF_ERROR;
  }
  if (conf-&gt;val2 &lt; conf-&gt;val1) {
    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,"val2 must be equal or more than val1");
    return NGX_CONF_ERROR;
  }

  return NGX_CONF_OK;
}</pre></div><p>Nginx provides very useful merging built-in functions for various data types (<code class="literal">ngx_conf_merge_&lt;data type&gt;_value</code>). These functions take the arguments as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The location's value (can refer to an element in a structure)</li><li class="listitem" style="list-style-type: disc">The value to use<a id="id572" class="indexterm"/> if the first value is not set</li><li class="listitem" style="list-style-type: disc">The default value if both first and second values are not set</li></ul></div><p>The first argument <a id="id573" class="indexterm"/>stores the result. See <code class="literal">core/ngx_conf_file.h</code> for a full list of available merge functions. The following is an extract from the file:</p><div class="informalexample"><pre class="programlisting">#define ngx_conf_merge_value(conf, prev, default) \
  if (conf == NGX_CONF_UNSET) { \
  conf = (prev == NGX_CONF_UNSET) ? default : prev; \
  }

#define ngx_conf_merge_ptr_value(conf, prev, default) \
  if (conf == NGX_CONF_UNSET_PTR) { \
    conf = (prev == NGX_CONF_UNSET_PTR) ? default : prev; \
  }

#define ngx_conf_merge_uint_value(conf, prev, default) \
  if (conf == NGX_CONF_UNSET_UINT) { \
    conf = (prev == NGX_CONF_UNSET_UINT) ? default : prev; \
  }

#define ngx_conf_merge_msec_value(conf, prev, default) \
  if (conf == NGX_CONF_UNSET_MSEC) { \
    conf = (prev == NGX_CONF_UNSET_MSEC) ? default : prev; \
  }

#define ngx_conf_merge_sec_value(conf, prev, default) \
  if (conf == NGX_CONF_UNSET) { \
    conf = (prev == NGX_CONF_UNSET) ? default : prev; \
  }

#define ngx_conf_merge_size_value(conf, prev, default) \
  if (conf == NGX_CONF_UNSET_SIZE) { \
    conf = (prev == NGX_CONF_UNSET_SIZE) ? default : prev; \
  }

#define ngx_conf_merge_off_value(conf, prev, default) \
  if (conf == NGX_CONF_UNSET) { \
    conf = (prev == NGX_CONF_UNSET) ? default : prev; \
  }

#define ngx_conf_merge_str_value(conf, prev, default) \
  if (conf.data == NULL) { \
  if (prev.data) { \
    conf.len = prev.len; \
     conf.data = prev.data; \
    } else { \
    conf.len = sizeof(default) - 1; \
    conf.data = (u_char *) default; \
    } \
  }

#define ngx_conf_merge_bufs_value(conf, prev, default_num,default_size)     \
  if (conf.num == 0) { \
    if (prev.num) { \
      conf.num = prev.num; \
      conf.size = prev.size; \
      } else { \
      conf.num = default_num; \
      conf.size = default_size; \
      } \
  }</pre></div><p>As you can see these functions are defined as macros, and they are expanded and placed inline in the code <a id="id574" class="indexterm"/>during compilation.</p><p>Another thing to learn is how<a id="id575" class="indexterm"/> to log errors. The function outputs to the log file using the <code class="literal">ngx_conf_log_error</code> function<a id="id576" class="indexterm"/>—where you specify a log level—and returns <code class="literal">NGX_CONF_ERROR</code>, which stops server startup.</p><p>There are several log levels defined in Nginx. These are defined in <code class="literal">ngx_log.h</code>. The following is an extract from the code:</p><div class="informalexample"><pre class="programlisting">#define NGX_LOG_STDERR            0
#define NGX_LOG_EMERG             1
#define NGX_LOG_ALERT             2
#define NGX_LOG_CRIT              3
#define NGX_LOG_ERR               4
#define NGX_LOG_WARN              5
#define NGX_LOG_NOTICE            6
#define NGX_LOG_INFO              7
#define NGX_LOG_DEBUG             8</pre></div></div></div><div class="section" title="The module definition"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec61"/>The module definition</h3></div></div></div><p>The next structure <a id="id577" class="indexterm"/>a new module should define is the module definition structure or the <code class="literal">ngx_module_t</code> structure. The variable is called <code class="literal">ngx_http_&lt;module name&gt;_module</code>. This structure binds together the structures we have been defining until now. You have to provide the pointers to the context and directives <a id="id578" class="indexterm"/>structures, as well as the remaining callbacks (exit thread, exit process, and so on). The module definition can act like a key to look up data associated with a particular module. The module definition of our custom module looks as follows:</p><div class="informalexample"><pre class="programlisting">#define NGX_MODULE_V1          0, 0, 0, 0, 0, 0, 1
#define NGX_MODULE_V1_PADDING  0, 0, 0, 0, 0, 0, 0, 0

struct ngx_module_s {
  ngx_uint_t            ctx_index;
  ngx_uint_t            index;

  ngx_uint_t            spare0;
  ngx_uint_t            spare1;
  ngx_uint_t            spare2;
  ngx_uint_t            spare3;
  ngx_uint_t            version;

  void                 *ctx;
  ngx_command_t        *commands;
  ngx_uint_t            type;

  ngx_int_t           (*init_master)(ngx_log_t *log);

  ngx_int_t           (*init_module)(ngx_cycle_t *cycle);

  ngx_int_t           (*init_process)(ngx_cycle_t *cycle);
  ngx_int_t           (*init_thread)(ngx_cycle_t *cycle);
  void                (*exit_thread)(ngx_cycle_t *cycle);
  void                (*exit_process)(ngx_cycle_t *cycle);

  void                (*exit_master)(ngx_cycle_t *cycle);

  uintptr_t             spare_hook0;
  uintptr_t             spare_hook1;
  uintptr_t             spare_hook2;
  uintptr_t             spare_hook3;
  uintptr_t             spare_hook4;
  uintptr_t             spare_hook5;
  uintptr_t             spare_hook6;
  uintptr_t             spare_hook7;
};</pre></div><p>You can see that the macros <code class="literal">NGX_MODULE_V1</code> and <code class="literal">NGX_MODULE_V1_PADDING</code> provide the values for the<a id="id579" class="indexterm"/> structure elements before and after<a id="id580" class="indexterm"/> the highlighted section in the preceding code. This is a detail we don't need to get into at the moment. For now, look at the following example on how to use them:</p><div class="informalexample"><pre class="programlisting">/*
 * The module which binds the context and commands
 *
 */
ngx_module_t ngx_http_hello_module = {NGX_MODULE_V1,&amp;ngx_http_hello_module_ctx,    /* module context */ngx_http_hello_commands,       /* module directives */NGX_HTTP_MODULE,               /* module type */NULL,                          /* init master */NULL,                          /* init module */NULL,                          /* init process */NULL,                          /* init thread */NULL,                          /* exit thread */
  NULL,                          /* exit process */NULL,                          /* exit master */NGX_MODULE_V1_PADDING
};</pre></div><p>You can see from the comments in the preceding code what each argument means. The first and last elements are the masks that hide the additional structure elements mainly because we don't need<a id="id581" class="indexterm"/> them, and they are place holders for the future. We also provide a module type, which in this case is HTTP. Most of the user-defined custom modules will be of this type.<a id="id582" class="indexterm"/> You can define other types such as CORE, MAIL, EVENT and so on; however, they are mostly not used as add-on module types.</p></div><div class="section" title="The handler function"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec62"/>The handler function</h3></div></div></div><p>The final piece of the puzzle after all the preparation work and configuration structures is the actual handler<a id="id583" class="indexterm"/> function which does all the work. The handler function<a id="id584" class="indexterm"/> for our sample module is as follows:</p><div class="informalexample"><pre class="programlisting">/*
 * Main handler function of the module.
 */
static ngx_int_tngx_http_hello_handler(ngx_http_request_t *r)
{
  ngx_int_t    rc;
  ngx_buf_t   *b;
  ngx_chain_t  out;

  /* we response to 'GET' and 'HEAD' requests only */
  if (!(r-&gt;method &amp; (NGX_HTTP_GET|NGX_HTTP_HEAD))) {
    return NGX_HTTP_NOT_ALLOWED;
  }

  /* discard request body, since we don't need it here */
  rc = ngx_http_discard_request_body(r);

  if (rc != NGX_OK) {
    return rc;
  }

  /* set the 'Content-type' header */
  r-&gt;headers_out.content_type_len = sizeof("text/html") - 1;
  r-&gt;headers_out.content_type.data = (u_char *) "text/html";
  /* send the header only, if the request type is http 'HEAD' */
  if (r-&gt;method == NGX_HTTP_HEAD) {
    r-&gt;headers_out.status = NGX_HTTP_OK;
    r-&gt;headers_out.content_length_n = hello_string.len;

  return ngx_http_send_header(r);
  }

  /* allocate a buffer for your response body */
  b = ngx_pcalloc(r-&gt;pool, sizeof(ngx_buf_t));
  if (b == NULL) {
    return NGX_HTTP_INTERNAL_SERVER_ERROR;
  }

  /* attach this buffer to the buffer chain */
  out.buf = b;
  out.next = NULL;

  /* adjust the pointers of the buffer */
  b-&gt;pos = hello_string.data;
  b-&gt;last = hello_string.data + hello_string.len;
  b-&gt;memory = 1;    /* this buffer is in memory */
  b-&gt;last_buf = 1;  /* this is the last buffer in the buffer chain*/

  /* set the status line */
  r-&gt;headers_out.status = NGX_HTTP_OK;
  r-&gt;headers_out.content_length_n = hello_string.len;

  /* send the headers of your response */
  rc = ngx_http_send_header(r);

  if (rc == NGX_ERROR || rc &gt; NGX_OK || r-&gt;header_only) {
    return rc;
  }

  /* send the buffer chain of your response */
  return ngx_http_output_filter(r, &amp;out);
}</pre></div><p>There are a few things to<a id="id585" class="indexterm"/> learn in the code. As explained earlier, this module basically prints whatever you had provided in the configuration. For example, according to the following <a id="id586" class="indexterm"/>configuration, this module will make sure that it prints <span class="strong"><strong>Hello World</strong></span> whenever you open <code class="literal">http://localhost:8080</code>:</p><div class="informalexample"><pre class="programlisting">server {
listen 8080;
server_name localhost;

location / {
hello 'Hello World';
  }
}</pre></div><p>This method receives the HTTP request as an argument. If your module only responds to a certain type of HTTP requests, you can check by looking at the HTTP request structure. For example, our module only responds to HTTP <code class="literal">GET</code> and <code class="literal">HEAD</code> requests as checked by this chunk of code; otherwise it returns "error code 405 (not allowed)".</p><p>All the HTTP error codes are defined in <code class="literal">ngx_http_request.h</code> as follows:</p><div class="informalexample"><pre class="programlisting">  /* we response to 'GET' and 'HEAD' requests only */
  if (!(r-&gt;method &amp; (NGX_HTTP_GET|NGX_HTTP_HEAD))) {
    return NGX_HTTP_NOT_ALLOWED;
  }</pre></div><p>Next, we discard the request body as in this module we don't need it. In several modules, one will write a body that will be important, however, right now we don't care about it. By discarding the request<a id="id587" class="indexterm"/> body, Nginx will not read the request body fully for processing and will not allocate memory for it internally.</p><p>Next we set some HTTP headers in our response. All headers you can set in the response can be accessed through the <code class="literal">headers_out</code> member of the HTTP request structure. The <code class="literal">headers_out</code> structure allows you to set a number of outgoing headers. The extract from <code class="literal">ngx_http_request.h</code> is as follows:</p><div class="informalexample"><pre class="programlisting">typedef struct {
  ngx_list_t                        headers;

  ngx_uint_t                        status;
  ngx_str_t                         status_line;

  ngx_table_elt_t                  *server;
  ngx_table_elt_t                  *date;
  ngx_table_elt_t                  *content_length;
  ngx_table_elt_t                  *content_encoding;
  ngx_table_elt_t                  *location;
  ngx_table_elt_t                  *refresh;
  ngx_table_elt_t                  *last_modified;
  ngx_table_elt_t                  *content_range;   ngx_table_elt_t                  *accept_ranges;
  ngx_table_elt_t                  *www_authenticate;
  ngx_table_elt_t                  *expires;
  ngx_table_elt_t                  *etag;

  ngx_str_t                        *override_charset;

  size_t                            content_type_len;
  ngx_str_t                         content_type;
  ngx_str_t                         charset;
  u_char                           *content_type_lowcase;
  ngx_uint_t                        content_type_hash;

  ngx_array_t                       cache_control;

  off_t                             content_length_n;
  time_t                            date_time;
  time_t                            last_modified_time;
} ngx_http_headers_out_t;</pre></div><p>The next important step in our module is allocating memory for the response buffer. This memory should be allocated using Nginx's own APIs as mentioned in earlier chapters (since it also <a id="id588" class="indexterm"/>automatically takes care of freeing it). This can be done because the memory is allocated from a local memory pool, so that all memory allocations are tracked.</p><p>The response<a id="id589" class="indexterm"/> is created in a linked list or <span class="emphasis"><em>chain</em></span> of buffers, each of which is of the size of <code class="literal">ngx_buf_s</code>. This allows Nginx to process the response in a parallel way. If there are other handlers or filters that need to postprocess the response, they can start their work as soon as the first buffer in the chain is ready, while you are filling up the second buffer. This allows Nginx to keep operating in a parallel fashion without waiting for any module to completely finish processing first.</p><p>When you are finished with creating the response in the last buffer, you should set <code class="literal">b-&gt;last_buf = 1</code>. This, as it is obvious from the name, will tell Nginx that this is the last response buffer from <a id="id590" class="indexterm"/>your module.</p><p>If the response processing was successful, you would want to set the status of the response header to <code class="literal">HTTP_OK</code>. This is done by <code class="literal">r-&gt;headers_out.status = NGX_HTTP_OK</code>.</p><p>You will then need to initiate the chain of header filters by calling <code class="literal">ngx_http_send_header</code>. This will indicate to Nginx that processing of the output headers has finished, and now Nginx can pass them to a chain of filters, which might want to do further postprocessing to the headers.</p><p>The final <a id="id591" class="indexterm"/>step is returning from the function by calling <code class="literal">ngx_http_output_filter</code>. This will initiate the process of the HTTP body filter chain. That is, Nginx or custom filter modules that might have been installed to do postprocessing on the HTTP response body you have just created in the buffer.</p><p>The summary of creating the <a id="id592" class="indexterm"/>Nginx custom module can be as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a module configuration that is structured either for location , main, or server; each with a specific naming convention (see <code class="literal">ngx_http_hello_loc_conf_t</code>).<p>The allowed directives of the module are in a static array of <code class="literal">typengx_command_t</code> (see <code class="literal">ngx_http_hello_commands</code>). This will also have the function's pointers that will have the code to validate the value of each directive as well as initialize the handler.</p></li><li class="listitem">Create a module context struct such as <code class="literal">ngx_http_&lt;module name&gt;_module_ctx</code> of type <code class="literal">ngx_http_module_t</code> which has a bunch of hooks for setting up configuration. Here you can have the post configuration hook, for example, to set up the main handler of your module (see <code class="literal">ngx_http_hello_module_ctx</code>).</li><li class="listitem">Then we do the module definition, which is also a struct of type <code class="literal">ngx_module_t</code> and contains references to the module context and module commands that you created in the previous steps (see <code class="literal">ngx_http_hello_module</code>).</li><li class="listitem">Create the main module handler function that processes the HTTP request. This function also outputs the response headers and body in a series of fixed size buffers.</li></ol></div></div></div></div>
<div class="section" title="Nginx Development Toolkit (NDK)"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec20"/>Nginx Development Toolkit (NDK)</h1></div></div></div><p>NDK is an Nginx module that makes it easier for the module developers to develop Nginx modules. As you have seen in this chapter so far, there are certain generic tasks that are repetitive as you are developing modules. NDK provides you with some built-in macros and functions that will reduce the amount of code you will have to write to develop a module.</p><p>In order to use<a id="id593" class="indexterm"/> NDK, you will have to add it as a module just like any other module. If you wish to use the macros and functions provided by this module, you will have to include the <code class="literal">ndk.h</code> file in your module source as well.</p><p>NDK provides useful utilities such as <code class="literal">conf</code> set functions for complex types such as paths and regular expressions, utility methods for NULL checking, returning values, and setting data to zero.</p><p>NDK also includes an <a id="id594" class="indexterm"/>
<span class="strong"><strong>Auto Lib Core</strong></span> that<a id="id595" class="indexterm"/> allows the developers and users to include external libraries in Nginx in a consistent, cross-platform manner.</p><p>You can see more details and documentation at <a class="ulink" href="https://github.com/simpl/ngx_devel_kit">https://github.com/simpl/ngx_devel_kit</a>.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec21"/>Summary</h1></div></div></div><p>In this chapter we have learned the process of creating a simple Nginx handler module. We also looked at which basic structures a new module should define, and how to link them to each other. Finally, we looked at a small handler function that does a basic task, but provides you the basis of writing a much more complicated module.</p><p>If you are an Nginx module developer, you must extensively browse other modules and Nginx source code, which will help you learn how to do different things within your code and which API to use in general.</p><p>You will also find Nginx Development Kit at <a class="ulink" href="https://github.com/simpl/ngx_devel_kit">https://github.com/simpl/ngx_devel_kit</a>. This will provide you additional <code class="literal">conf_set</code> functions for regexes, complex/script values, paths, and macros to simplify tasks such as checking for NULL values when doing <code class="literal">ngx_array_push</code> and much more, which will simplify your life while writing custom Nginx modules.</p></div></body></html>