<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Monitoring Nginx"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Monitoring Nginx</h1></div></div></div><p>After reading this chapter you will be able to set up proper monitoring for your Nginx installation using the features freely available as part of base Nginx distribution and several of the more popular monitoring and alerting systems available on the market.</p><p>You will also get acquainted with an advanced monitoring solution that is included in the Nginx Plus subscription package, which the makers of Nginx sell as a commercial service.</p><p>Knowing what is happening to your web server is the first step towards fixing and preventing any problems. Setting up monitoring and alerting is one of the essential steps in any production deployment, and Nginx web servers are not the exception here. Experienced web administrators will never feel calm enough until they have real-time insight into the performance and load indicators.</p><p>There are several sources of data for your monitoring system provided by Nginx. First, there are logs, which you may configure up to your preferences. There is also a number of statistics interfaces available for Nginx that you may enable and connect to various industrial monitoring systems, both free and commercial. The logging subsystem was described in the <a class="link" href="ch02.html" title="Chapter 2. Searching for Problems in Log Files">Chapter 2</a>, <span class="emphasis"><em>Searching for Problems in Log Files</em></span>, which can be referred to for additional information. One particular tool that uses logs to enable online monitoring and debugging should be mentioned.</p><div class="section" title="Using ngxtop"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec31"/>Using ngxtop</h1></div></div></div><p>When <a class="indexterm" id="id235"/>the first version of the famous Unix utility top(1) was conceived in 1984, imitating an old VMS command that did a similar thing, the author was unlikely to imagine that he actually created a whole class of online system administration tools suited for both routine and emergency situations. Since then, top has become an essential program, and many other utilities have been born with the same principle in mind—produce a dynamic interactive <span class="emphasis"><em>top N</em></span> list of items sorted by a particular criteria. There are <code class="literal">htop</code>, <code class="literal">iotop</code>, <code class="literal">mytop</code>, <code class="literal">pg_top</code>, <code class="literal">ntop</code>, <code class="literal">iftop</code>, and many others. The Nginx ecosystem has <a class="indexterm" id="id236"/>its own top, which is named <code class="literal">ngxtop</code> and is hosted on <a class="ulink" href="https://github.com/lebinh/ngxtop">https://github.com/lebinh/ngxtop</a>.</p><p>The <a class="indexterm" id="id237"/>recommended way to install ngxtop is using the <code class="literal">pip</code> package manager for Python packages. Your distribution may or may not have <code class="literal">pip</code> installed by default, so you might also need to install <code class="literal">pip</code> first. On Debian-based Linux distributions, you will usually be all set up with:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ sudo apt-get install python-pip</strong></span>
</pre></div><p>On a FreeBSD box, you need to install the port <code class="literal">devel/py-pip</code> with these:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ cd /usr/ports/devel/py-pip</strong></span>
<span class="strong"><strong>$ sudo make install</strong></span>
</pre></div><p>When <code class="literal">pip</code> is available, you can install the actual <code class="literal">ngxtop</code> with it:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ sudo pip install ngxtop</strong></span>
</pre></div><p>You can run <code class="literal">ngxtop</code> right away, and due to some heuristics, it will correctly locate your main Nginx log all by itself.</p><p>This is how the <code class="literal">ngxtop</code> default output looks like on a simple and rather idle website access log:</p><div class="mediaobject"><img alt="Using ngxtop" src="graphics/B04329_06_01.jpg"/></div><p>There are two tables in the output. The first one shows the summary line. The columns are pretty obvious. The ones that must catch your attention immediately are the rightmost two (titled 4xx and 5xx), which contain the counters for the HTTP requests that led to errors.</p><p>The second table is more interesting because it has all the incoming requests classified by the request path. You may immediately see which paths generate errors, for example. In the earlier example, you will note that the website lacks the <code class="literal">robots.txt</code> file and also the special high resolution icons, which were first used by the iOS. The counts in the lower table do not add up exactly to the respective counts in the top table because the least happening request paths are not included here.</p><p>ngxtop has several powerful command-line options, which make it one of the best tools to analyze a log from a misbehaving website. For example, in <a class="link" href="ch02.html" title="Chapter 2. Searching for Problems in Log Files">Chapter 2</a>, <span class="emphasis"><em>Searching for Problems in Log Files</em></span>, we described how to create custom log formats extending the information <a class="indexterm" id="id238"/>beyond what a common access logs offer. ngxtop is able to accept a log format definition and even parse it from the <code class="literal">nginx.conf</code> file itself.</p><p>The command-line switch for the custom log format is <code class="literal">-f</code>. The whole command will look just like this:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ ngxtop -f  '$remote_addr - $remote_user [$time_local] "$request" '</strong></span>
</pre></div></div></div>
<div class="section" title="Getting statistics from http_stub_status"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec32"/>Getting statistics from http_stub_status</h1></div></div></div><p>Nginx base <a class="indexterm" id="id239"/>distribution contains a simple module<a class="indexterm" id="id240"/> that provides access to several rather basic but useful counters inside Nginx that are very important to monitor on a regular basis. The module is named <code class="literal">ngx_http_stub_status</code>, and we will describe how to use it in monitoring.</p><p>This module is not compiled by default. To check if your Nginx distribution is compiled with the <code class="literal">stub_status</code> module, you can use this command:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ nginx -V 2&gt;&amp;1 | fgrep -c http_stub_status_module</strong></span>
<span class="strong"><strong>1</strong></span>
<span class="strong"><strong>$</strong></span>
</pre></div><p>If you see <code class="literal">1</code>, then this module is compiled and linked to your Nginx binary. Otherwise, you need to compile it using <code class="literal">--with-http_stub_status_module</code> parameter to <code class="literal">configure</code> script that is invoked during Nginx compilation.</p><p>Once you have this module available, you can use its directives (actually, there is only one) in <code class="literal">nginx.conf</code>. This is an example of <code class="literal">stub-status</code> sharing:</p><div class="informalexample"><pre class="programlisting">location /stub-status {
    stub_status;
}</pre></div><p>This module belongs to the family of the so-called content-generating modules, which are able to directly process incoming HTTP requests and generate responses. The other main family of modules that can provide HTTP responses to clients are the upstream modules, which are more complex content generators consulting external resources for the actual data. While we spent a significant amount of time explaining upstreams in previous chapters, content generators were not given so much attention due to their relative simplicity. Some other interesting content-generating modules that are included in Nginx distribution are <code class="literal">ngx_http_empty_gif</code> and <code class="literal">ngx_http_autoindex</code>.</p><p>The earlier configuration will create a primitive web page as a response to the GET request with the URI of <code class="literal">/stub-status</code>. You can use any other URI as well. The page will contain several counters. Let's see an example and learn what those numbers mean. A fresh <a class="indexterm" id="id241"/>web server after a restart will generate <a class="indexterm" id="id242"/>this page:</p><div class="mediaobject"><img alt="Getting statistics from http_stub_status" src="graphics/B04329_06_02.jpg"/></div><p>This is not even a web page per se, but just a plain text HTTP response clearly intended to be processed by scripts and not by people:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ curl -si http://localhost/stub-status | fgrep Content-Type</strong></span>
<span class="strong"><strong>Content-Type: text/plain</strong></span>
<span class="strong"><strong>$</strong></span>
</pre></div><p>Let's dive <a class="indexterm" id="id243"/>deeper into the values that you see in this output:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Parameter name</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Active connections</p>
</td><td style="text-align: left" valign="top">
<p>This is the number of all client connections that are being processed right now. This counter is bumped on each successful <code class="literal">accept()</code> and decreased after each <code class="literal">close()</code>. The number will also be a sum of reading + writing + waiting.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Server accepts</p>
</td><td style="text-align: left" valign="top">
<p>The global ever-increasing counter of all connections that were <code class="literal">accept()-ed</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Handled</p>
</td><td style="text-align: left" valign="top">
<p>The counter of all handled connections. Most of the time, this number is the same as the previous one, but some of the connections are closed right after being accepted and they are not counted as handled.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Requests</p>
</td><td style="text-align: left" valign="top">
<p>This<a class="indexterm" id="id244"/> is the global counter of all HTTP requests received by this Nginx instance. It may be smaller than the handled counter due to "keep-alive" connections that may receive many requests before closing.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Reading:</p>
</td><td style="text-align: left" valign="top">
<p>This is a snapshot number of all connections that are currently in the process of reading HTTP request headers.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Writing:</p>
</td><td style="text-align: left" valign="top">
<p>This is the number of connections that are in one of the states after the reading of the headers of the request. It may be a little confusing, but connections that are reading the body of the request or communicating with one of the upstreams are counted against this number.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Waiting:</p>
</td><td style="text-align: left" valign="top">
<p>This is the counter of all "keep-alive" connections that are waiting for the next request from the same connected client.</p>
</td></tr></tbody></table></div><p>Most <a class="indexterm" id="id245"/>of these counters are also available as <a class="indexterm" id="id246"/>Nginx variables and can be used in the <code class="literal">log_format</code> configuration. The module exports these variables:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">$connections_active</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">$connections_reading</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">$connections_writing</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">$connections_waiting</code></li></ul></div><p>The global counts of connections and requests can be restored from the logs without any additional variables.</p><p>The only directive from this module is <code class="literal">stub_status</code>, and its usage pattern is obvious from the earlier example. You can specify it in one of the scopes; most probably, you will choose a location. Older versions of Nginx may require you to specify a parameter like <code class="literal">ok</code> or <code class="literal">1</code> for this directive.</p><p>While the simplest status content generator may only contain one line with this directive, it is highly recommended to make some additions.</p><p>This is the working practical example of <code class="literal">stub_status</code> configuration:</p><div class="informalexample"><pre class="programlisting">location /stub-status {
stub_status;  
    access_log   off;
    allow   $monitoring_ip;
    deny    all;
}</pre></div><p>The <code class="literal">access_log off</code> directive will switch off logging for this location. You may want to comment out it while you debug but in the end only your monitoring system will make requests<a class="indexterm" id="id247"/> to this path from predefined IP<a class="indexterm" id="id248"/> addresses and at predefined intervals. The logging of this regular GET request-response pair will not be very useful while littering the logs with very redundant information.</p><p>The third and the fourth lines are about access control. While <code class="literal">stub_status</code> does not share any particularly confidential information, it may still be valuable to either competitors or malicious actors who plan to attack your infrastructure. A golden rule of not sharing anything by default works here.</p><p>To fully understand how we could use the data, let's write a simple manual alerting script using cron. As an example, we will specify the task as follows: once a minute check the requests rate and alert the administrator if the rate per minute exceeds a certain predefined threshold.</p><p>The code for the check is given later. It is a simple Perl script that should be called from a crontab with a time specification of <code class="literal">*/1 * * * *</code>, which means running once every minute. It uses the <code class="literal">PushBullet</code> service to send alerts. <code class="literal">PushBullet</code> allows mobile apps and browser extensions to receive those notifications and has a simple HTTP API:</p><div class="informalexample"><pre class="programlisting">#! /usr/bin/perl
use strict;
use warnings;

use autodie;
use LWP::Simple;
use WWW::PushBullet;

my $stub_status_url = 'http://localhost/stub-status';
my $threshold = 2000; # requests per minute

my $data_file = '/var/run/req-rate';
my $pb = WWW::PushBullet-&gt;new( {
    apikey =&gt; '...PushBullet API key...',
});

BEGIN {
    # For LWP inside PushBullet
    $ENV{PERL_NET_HTTPS_SSL_SOCKET_CLASS} = 'Net::SSL';
}

open my $fh, '+&lt;', $data_file;
my ($prev, $prev_ts) = split ' ', scalar &lt;$fh&gt;;

my $reqs;
if (get($stub_status_url) =~ /(\d+)\s+Reading: /s) {
    $reqs = $1;
}

my $now = time();

if ($prev &amp;&amp; $reqs) {
    my $rate = ($reqs - $prev) / ($now - $prev_ts) * 60;
    if ($rate &gt; $threshold) {
        $pb-&gt;push_note({ title =&gt; 'req rate alert', body =&gt; "Requests per minute: $rate" });
    }
}

seek $fh, 0, 0;
truncate $fh, 0;

say $fh "$reqs $now";</pre></div><p>The <a class="indexterm" id="id249"/>script parses the output of the <code class="literal">ngx_http_stub_status</code> module with a simple regular expression and compares the global <a class="indexterm" id="id250"/>requests counter with the previous value, which it saves in a file. If the increase in the counter divided by the time passed exceeds a constant, it sends an alert. This is the model employed by all monitoring and alerting systems out there.</p><p>The next step for us is using the data from this module as a sensor in several monitoring systems that are available on the market. Most of the systems allow comprehensive graphs of all available counters and also custom alerts on events like a value exceeding a threshold of some kind.</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Monitoring system</p>
</th><th style="text-align: left" valign="bottom">
<p>Nginx support plugin</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Nagios</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="https://exchange.nagios.org/directory/Plugins/Web-Servers/nginx">https://exchange.nagios.org/directory/Plugins/Web-Servers/nginx</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Zabbix</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="https://github.com/zbal/zabbix/blob/master/scripts/zabbix_nginx_check.sh">https://github.com/zbal/zabbix/blob/master/scripts/zabbix_nginx_check.sh</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>ZTC</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="https://bitbucket.org/rvs/ztc/wiki/Home">https://bitbucket.org/rvs/ztc/wiki/Home</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Munin</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="https://github.com/munin-monitoring/contrib/tree/master/plugins/nginx">https://github.com/munin-monitoring/contrib/tree/master/plugins/nginx</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Cacti</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="http://forums.cacti.net/download/file.php?id=12676">http://forums.cacti.net/download/file.php?id=12676</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Collectd</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="https://collectd.org/wiki/index.php/Plugin:nginx">https://collectd.org/wiki/index.php/Plugin:nginx</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>OpenNMS</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="http://www.opennms.org/wiki/Monitoring_Nginx_with_the_HTTP_collector">http://www.opennms.org/wiki/Monitoring_Nginx_with_the_HTTP_collector</a>
</p>
</td></tr></tbody></table></div><p>Many<a class="indexterm" id="id251"/> hosted monitoring solutions, such <a class="indexterm" id="id252"/>as DataDog, Scout, New Relic or<a class="indexterm" id="id253"/> ServerDensity, support <a class="indexterm" id="id254"/>collecting data from<a class="indexterm" id="id255"/> the <a class="indexterm" id="id256"/>Nginx <code class="literal">http_stub_status</code> module as well.</p><p>Here is <a class="indexterm" id="id257"/>how<a class="indexterm" id="id258"/> ServerDensity displays data received from Nginx:</p><div class="mediaobject"><img alt="Getting statistics from http_stub_status" src="graphics/B04329_06_03.jpg"/></div><p>The <a class="indexterm" id="id259"/>earlier-mentioned graph will only contain<a class="indexterm" id="id260"/> two entities: current client connections and requests per second. You notice that those two come very close to each other, which means that there were no or little keep-alive connections that managed to pass over more than one request.</p></div>
<div class="section" title="Monitoring Nginx with Munin"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec33"/>Monitoring Nginx with Munin</h1></div></div></div><p>
<span class="strong"><strong>Munin</strong></span> is a<a class="indexterm" id="id261"/> free software networking and infrastructure <a class="indexterm" id="id262"/>monitoring system. We chose it because <a class="indexterm" id="id263"/>the configuration is simple and allows us to demonstrate the principles. You will certainly prefer to use the same monitoring solution that you use for your other needs. If you do not currently use anything that is not very probable, Munin is as good an option as any other to start with.</p><p>Munin was developed with easy extensibility via plugins in mind. It uses the famous RRDTool time series database that was first developed as part of MRTG but then found its way to many other free and open source software as the time series database and time-based graphs engine.</p><p>Installing Munin is not as easy as we wish it were but the process is thoroughly described in the online<a class="indexterm" id="id264"/> Munin guide <a class="ulink" href="http://guide.munin-monitoring.org/en/latest/installation/index.html">http://guide.munin-monitoring.org/en/latest/installation/index.html</a>. There is also a book about Munin published by <span class="emphasis"><em>Packt Publishing</em></span>, <span class="emphasis"><em>Instant Munin Plugin Starter</em></span>. It may be a little old but still contains enough relevant information.</p><p>Munin is <a class="indexterm" id="id265"/>also one of the monitoring systems that has plugins <a class="indexterm" id="id266"/>to parse the output from the Nginx <code class="literal">http_stub_status</code> module in its distribution. The plugins are available right after Munin installation and are supported as part of the release cycle of Munin.</p><p>The architecture of many network monitoring systems is very similar to a classic star topology system with a master that is responsible for drawing graphs, watching for events, and issuing alerts based on data provided by agents, each of which represent a host or a service. Munin agents are named nodes and installing Munin usually installs an instance of the Munin node on the same host as well. That sounds absolutely okay as the master host of a monitoring system should definitely be monitored itself. It is the node component that has integration with different software to get metrics that should be monitored. Munin plugins for Nginx are executable scripts that are run as part of the Munin node operation. The node process reports the data from those (and all the other) plugins to the Munin master, which has the interface for the administrators.</p><p>After successful installation of Munin, you will find all standard plugins in <code class="literal">/usr/share/munin/plugins</code> or some other directory depending on your distribution. There are two standard Nginx plugins in Munin 2.0.25—<code class="literal">nginx_requests</code> and <code class="literal">nginx_status</code>. Both of those plugins parse the output of the <code class="literal">http_stub_status</code> Nginx module and thus require the <code class="literal">url</code> environment variable to point to the <code class="literal">stub_status</code> output URL <a class="indexterm" id="id267"/>with a sane default of <code class="literal">http://localhost/nginx_status</code>. To switch the plugins on, you need to link them into <code class="literal">/etc/munin</code> with a command such as:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ sudo ln -s /usr/share/munin/plugins/nginx_* /etc/munin/plugins/</strong></span>
</pre></div><p>You may<a class="indexterm" id="id268"/> also examine the <code class="literal">contrib</code> Nginx plugins available at <a class="ulink" href="https://github.com/munin-monitoring/contrib/tree/master/plugins/nginx">https://github.com/munin-monitoring/contrib/tree/master/plugins/nginx</a>. These are not installed by default, but are still part of the Munin source tree.</p><p>After restarting the Munin node running on the host, the metrics reported by Nginx are immediately available for this particular host. To check whether the plugins can successfully access Nginx and parse its <code class="literal">stub_status</code>, you can use these convenient commands:</p><div class="informalexample"><pre class="programlisting">$ sudo munin-run nginx_request
request.value 15
$ sudo munin-run nginx_status
total.value 2
reading.value 0
writing.value 1
waiting.value 1
$</pre></div><p>Given that<a class="indexterm" id="id269"/> your Munin master and nodes are running, you<a class="indexterm" id="id270"/> will start to get updated graphs for Nginx metrics at once. A clean Munin without any past data will show something like this:</p><div class="mediaobject"><img alt="Monitoring Nginx with Munin" src="graphics/B04329_06_04.jpg"/></div><p>Adding more hosts to the Munin master is completely transparent, provided that those hosts run the node with Nginx plugins. All of the reported metrics will show up instantly and will get drawn and checked against limits, which also brings us to the next topic.</p></div>
<div class="section" title="Configuring alerts"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec34"/>Configuring alerts</h1></div></div></div><p>Although <a class="indexterm" id="id271"/>monitoring itself is a very broad term and as a job may include a lot of activities, there are basically two sides to what a web service monitoring constitutes. Graphing values from sensors is important as a tool to make strategic decisions based on visually apparent trends and also a post factum investigation and sometimes even as a forensics tool. The other side is alerting, which allows administrators to react to incidents as quickly as possible, preventing business consequences. All major monitoring solutions include alerting subsystems and even the toy monitoring script that we built earlier in this chapter is basically a simple alerter.</p><p>The <code class="literal">http_stub_status</code> module provides scarce information, but it can still be used to quickly react to incidents. These are some good values that can be used to detect unusual conditions requiring immediate attention:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The incoming request rate is a global indicator of the load to your website. Sudden spikes indicate a surge in popularity, which might be dangerous or a <span class="strong"><strong>Denial of Service</strong></span> (<span class="strong"><strong>DoS</strong></span>) attack, which is always dangerous. A sudden dip may <a class="indexterm" id="id272"/>mean a failure, even a total meltdown.</li><li class="listitem" style="list-style-type: disc">A high number of dropped connections may indicate that the configuration is not up to the load. Nginx does not drop connections unless it has to due to either resource shortage or, which happens more often, meeting resource limits.</li><li class="listitem" style="list-style-type: disc">The number of active (including waiting) connections may sometimes mean an attempt to drain your connection limits by a malicious actor. This is exactly what Nginx usually manages to defend itself against without any external help, but it is still important to monitor and investigate these events.</li></ul></div><p>You can use any number of complex alert conditions using these three and also invent more metrics relevant to your particular business. The method to create such alerts is specific to the monitoring system you decided to choose. These are the example alerts we use inside ServerDensity:</p><div class="mediaobject"><img alt="Configuring alerts" src="graphics/B04329_06_05.jpg"/></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Munin<a class="indexterm" id="id273"/> uses a simple system of two-level thresholds attached to plugins as a way to generate alerts. There are "warning" and "critical" thresholds, and once the actual value reaches one of the thresholds, Munin will generate an alert and send a notification. The system allows default thresholds for all hosts, which may be practical.</li><li class="listitem" style="list-style-type: disc">The more popular way is to set up thresholds for all hosts individually. It is done right in the Munin master configuration file, which is called <code class="literal">munin.conf</code>. This file contains a list of all hosts that are under monitoring by this very master. Adding a threshold for a metric available on a host is as simple as this:<div class="informalexample"><pre class="programlisting">[www1.example.com]
    nginx_status.total.warning 0:10
    nginx_status.total.critical 0:20</pre></div><p>The values are specified as ranges; that is, in the earlier case, the warning would be generated only when the <code class="literal">nginx.status.total</code> metrics (which is the total number of current connections) will leave the range from 0 to 10.</p><p>Munin is able to send notifications about the alerts via e-mail, via syslog, via piping to external programs, or via Nagios, which is another popular monitoring system with a more sophisticated alerting subsystem. Configuration of the notification settings is easy enough. See the online Munin guide at <a class="ulink" href="http://guide.munin-monitoring.org/en/latest/tutorial/alert.html">http://guide.munin-monitoring.org/en/latest/tutorial/alert.html</a>.</p></li><li class="listitem" style="list-style-type: disc">All of the interesting metrics may be measured right on the front between Nginx and its clients and also on each external link that Nginx has due to upstream configuration. Unfortunately, the open source Nginx does not<a class="indexterm" id="id274"/> contain any means to expose those metrics from the upstream links to monitor and set up alerts on.</li></ul></div></div>
<div class="section" title="Getting more status data from Nginx"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec35"/>Getting more status data from Nginx</h1></div></div></div><p>In this <a class="indexterm" id="id275"/>section, we will explore the ways to get more information about an Nginx instance so that the monitoring can be more extensive and cover more details.</p><p>In 2014, Nginx creators launched a commercial umbrella company for the open source Nginx software, which started to explore the business models around the server. One of the most anticipated features was comprehensive monitoring and the developers delivered on that front.</p><p>The commercial product of Nginx company is named Nginx Plus. It is a subscription service marketed to medium and large businesses already dependent on Nginx for their infrastructure. Nginx Plus pricing is based on yearly licenses per single instance and is rather aggressive, which also means that once you need these features, you already have several instances and need several licenses. For complete and up-to-date information, refer to<a class="indexterm" id="id276"/> the Nginx Plus web page at <a class="ulink" href="https://www.nginx.com/products/">https://www.nginx.com/products/</a>.</p><p>One of the most important part of the subscription is the availability of the new status module, which is named <code class="literal">ngx_http_status</code>, and is a kind of elder brother for the open source <code class="literal">ngx_http_stub_status</code> that most of the monitoring solutions we described depend on.</p><p>Along with programmatic access to the status data in machine-readable form, Nginx Plus provides a beautiful and expressive dashboard that you can use without any integration into your enterprise<a class="indexterm" id="id277"/> monitoring. The <a class="ulink" href="https://www.nginx.com">https://www.nginx.com</a> team <a class="indexterm" id="id278"/>kindly provides a demonstration of what the dashboard can do at <a class="ulink" href="http://demo.nginx.com/status.html">http://demo.nginx.com/status.html</a>.</p><div class="mediaobject"><img alt="Getting more status data from Nginx" src="graphics/B04329_06_06.jpg"/></div><p>The<a class="indexterm" id="id279"/> configuration for the <code class="literal">ngx_http_status</code> module looks like this:</p><div class="informalexample"><pre class="programlisting">location /status {
    status;
}</pre></div><p>As you can see, it is an almost exact copy of what we did earlier for <code class="literal">stub_status</code>, but the main directive is now more aptly named <code class="literal">status</code>. This location will accept a number of different requests. It provides a hierarchy of information about different objects, such as upstreams and cache zones.</p><p>The built-in dashboard is actually a one-page HTML application that retrieves all the information it needs from <code class="literal">/status</code>. The static HTML will be installed with the Nginx Plus distribution. On Debian-based systems, you can find it at <code class="literal">/usr/share/nginx/html/status.html</code>. To add the dashboard to your Nginx Plus instance, see this configuration example:</p><div class="informalexample"><pre class="programlisting">location = /status.html {
    root /usr/share/nginx/html;
}</pre></div><p>Having your own Nginx dashboard is never enough because if you invested into Nginx Plus subscription you probably have some business-critical operations and you need automatic monitoring. At the same time, the dashboard is the perfect way to explore the information that is exported by Nginx Plus. The <code class="literal">ngx_http_status</code> module provides wealth of information in machine-readable format (JSON or JSONP) to integrate with all the systems we mentioned earlier. And using the new metrics available, you will be able to monitor<a class="indexterm" id="id280"/> more. Let's dig deeper into what <code class="literal">ngx_http_status</code> returns by default:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>$ curl http://localhost/status</strong></span>
<span class="strong"><strong>{"version":6,"nginx_version":"1.9.4","address":"127.0.0.1","generation":4,"load_timestamp":1448573854895,"timestamp":1448573864361,"pid":3691,"processes":{"respawned":0},"connections":{"accepted":208,"dropped":0,"active":1,"idle":1},"ssl":{"handshakes":0,"handshakes_failed":0,"session_reuses":0},"requests":{"total":8309,"current":1},"server_zones":{"localhost_http":{"processing":1,"requests":12,"responses":{"1xx":0,"2xx":11,"3xx":0,"4xx":0,"5xx":0,"total":11},"discarded":0,"received":3305,"sent":7756}},"upstreams":{},"caches":{}}</strong></span>
<span class="strong"><strong>$</strong></span>
</pre></div><p>As you can see, the default output format for this module is JSON, which allows much more complex data structures. The same data re-indented for readability looks like this:</p><div class="informalexample"><pre class="programlisting">{
   "version":6,
   "nginx_version":"1.9.4",
   "address":"127.0.0.1",
   "generation":4,
   "load_timestamp":1448573854895,
   "timestamp":1448573864361,
   "pid":3691,
   "processes":{
      "respawned":0
   },
   "connections":{
      "accepted":208,
      "dropped":0,
      "active":1,
      "idle":1
   },
   "ssl":{
      "handshakes":0,
      "handshakes_failed":0,
      "session_reuses":0
   },
   "requests":{
      "total":8309,
      "current":1
   },
   "server_zones":{
      "localhost_http":{
         "processing":1,
         "requests":12,
         "responses":{
            "1xx":0,
            "2xx":11,
            "3xx":0,
            "4xx":0,
            "5xx":0,
            "total":11
         },
         "discarded":0,
         "received":3305,
         "sent":7756
      }
   },
   "upstreams":{ },
   "caches":{ }
}</pre></div><p>On the <a class="indexterm" id="id281"/>upper level of the return JSON object, we see these items:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">version</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is the version of the format of these data. It is important for parsers because some of the items only appeared starting from a specific version, and you may require Nginx upgrade to get enough information for your parser. As of December 2015, the last version of this is 6.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">nginx_version</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is the version of Nginx software.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">address</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is the IP address of the server generating the status report.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">generation</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This gets incremented by one each time you reload Nginx configuration. So in a sense, this is the number of the current configuration generation. One may wonder why the generation number is important. One of the reasons is that it may not be practical to compare some indicators, for example, performance if the generation and therefore the configuration has changed.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">load_timestamp</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The Unix epoch timestamp of the last configuration reload.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">timestamp</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Current UNIX timestamp.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">pid</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The process identifier of the worker that processed this specific status request.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">processes</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is an object with a single field (it may be extended in future versions of the response structure), which is named <code class="literal">respawned</code>, and contains the number of all child processes that we restarted after a failure.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">connections</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is an important object containing the information that we otherwise can obtain via the open source <code class="literal">ngx_http_stub_status</code> module.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">connections.accepted</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This value inside the <code class="literal">connections</code> object is the total number of all accepted client connections.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">connections.dropped</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This<a class="indexterm" id="id282"/> is the total number of dropped connections. Note that with <code class="literal">http_stub_status</code> module, we have to calculate this value ourselves.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">connections.active</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The number of currently active connections.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">connections.idle</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The number of connections that are idling.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">ssl</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is also an object with several values inside. Those are SSL (actually, TLS) counters. SSL is an older version of the protocol for encrypted connections. The proper name for the current protocol is TLS, but the old name is still used by some conservative specialists.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">ssl.handshakes</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The total number of TLS handshakes.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">ssl.handshakes_failed</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The total number of unsuccessful TLS handshakes. This is a very interesting and important value that is not available via <code class="literal">http_stub_status</code> while being rather critical to monitor.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">ssl.session_reuses</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Each TLS handshake is an expensive operation, and there is an optimization that reuses one of the previously established TLS sessions to avoid the handshake altogether. A low number here means an opportunity to increase performance with little investment.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">requests</code>
</p>
</td><td style="text-align: left" valign="top">
<p>An object with two values.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">requests.total</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is the same number that is printed last on the third line of the <code class="literal">http_stub_status</code> output. The global counter for all client requests received via all connections.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">requests.current</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The number of currently processed requests.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">upstreams</code>
</p>
</td><td style="text-align: left" valign="top">
<p>If there is one important feature of Nginx Plus that you want to name to justify the purchase, it should probably be the upstreams object in the <code class="literal">http_status</code> output. It allows the metrics of the individual upstreams and hosts inside upstreams to be monitored.</p>
<p>The example host mentioned earlier does not have any upstreams configured, and this is why the object is empty.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">caches</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This object contains the status of all configured caches. Most of the cache configuration is done with the upstream directives.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">server_zones</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This object is a custom storage that you can fill with data using the <code class="literal">status_zone</code> directive inside one of your server blocks. Status zones are a new concept in Nginx Plus. They provide an additional level of flexibility in collecting status data. You can find comprehensive documentation<a class="indexterm" id="id283"/> on this directive at <a class="ulink" href="http://nginx.org/en/docs/http/ngx_http_status_module.html#status_zone">http://nginx.org/en/docs/http/ngx_http_status_module.html#status_zone</a>.</p>
</td></tr></tbody></table></div><p>Each <a class="indexterm" id="id284"/>of the server zones contains a separate multilevel object with the status information collected from all servers connected to the same status zone. That object looks like this:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">processing</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The snapshot number of currently processed requests.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">requests</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The total counter of all requests.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">responses.total</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The number of responses sent to clients. Should be close to the number of requests.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">1xx</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The number of responses with HTTP 1xx status codes.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">2xx</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The number of responses with HTTP 2xx status codes.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">3xx</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The number of responses with HTTP 3xx (usually redirects) status codes.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">4xx</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The number of responses with HTTP 4xx (usually indicating bad requests that should be fixed on the client side) status codes.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">5xx</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The number of responses with HTTP 5xx (meaning internal server errors) status codes.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">discarded</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The number of requests that did not generate responses.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">received</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Total bytes received from clients.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">sent</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Total bytes sent to clients.</p>
</td></tr></tbody></table></div></div>
<div class="section" title="Using Nginx Plus alternatives"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec36"/>Using Nginx Plus alternatives</h1></div></div></div><p>The<a class="indexterm" id="id285"/> Nginx Plus commercial subscription gives you more than just the <code class="literal">ngx_http_status</code> module. If you do not need the other perks of the Plus version but crave more metrics, you could explore some of the freely available alternatives.</p><div class="section" title="nginx-module-vts"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec43"/>nginx-module-vts</h2></div></div></div><p>One <a class="indexterm" id="id286"/>way to get more information from inside <a class="indexterm" id="id287"/>Nginx is this open source module published on GitHub at <a class="ulink" href="https://github.com/vozlt/nginx-module-vts">https://github.com/vozlt/nginx-module-vts</a>.</p><p>The author was clearly inspired by the official <code class="literal">ngx_http_status</code> features and even used the same structures and dashboard client-side code (although the older version). This may be actually a good thing because you can start integrating <code class="literal">nginx-module-vts</code> and then transfer all the scripts with minimal modifications to Nginx Plus once you are ready for the subscription. The documentation is wonderful, and there are many examples. Some of the keys in the JSON objects that are returned by this module differ from the official <code class="literal">ngx_http_status</code> keys, and because of this, we would recommend abstracting the actual key names in your monitoring configuration files.</p></div><div class="section" title="Luameter"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec44"/>Luameter</h2></div></div></div><p>Another <a class="indexterm" id="id288"/>alternative to the great official <code class="literal">ngx_http_status</code> is the Luameter package, which is a collection of scripts in the Lua programming<a class="indexterm" id="id289"/> language that integrates with Nginx using the <code class="literal">ngx_http_lua</code> module. The format of the data collected and exported by Lua is also clearly inspired by the official and pricey alternative, so you will be able to switch with little effort.</p><p>The idea of the very useful <code class="literal">ngx_http_lua</code> module is to let Nginx administrators hook snippets of custom Lua code into different phases of request processing.</p><p>Luameter is distributed on a pay-as-you-go model, so it is not free. The lowest price is just 10 US dollars, so it is very cheap in comparison with what the commercial arm of Nginx sells. Refer <a class="indexterm" id="id290"/>to <a class="ulink" href="https://luameter.com/">https://luameter.com/</a> for all the information about Luameter.</p></div><div class="section" title="nginx-lua-stats"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec45"/>nginx-lua-stats</h2></div></div></div><p>This is<a class="indexterm" id="id291"/> another collection of scripts in Lua. It may be used by itself to collect and export online statistics about the number of generated HTTP responses with various HTTP status codes, but it is even more valuable as an example <a class="indexterm" id="id292"/>of using Lua hooks to collect additional data and report it.</p><p>The code is<a class="indexterm" id="id293"/> published on GitHub at <a class="ulink" href="https://github.com/yandex-sysmon/nginx-lua-stats">https://github.com/yandex-sysmon/nginx-lua-stats</a>.</p><p>
<code class="literal">nginx-lua-stats</code> works its magic by setting up a hook on the logging phase, which collects the data, and then setting up another hook on the content generation phase for a particular location which is able to actually generate a full HTTP response with the collected statistics.</p><p>Here is the relevant part of the <code class="literal">nginx.conf</code> file:</p><div class="informalexample"><pre class="programlisting"> location /stat {
       content_by_lua_file 'show_stat.lua';
    }

    location /html {
      log_by_lua_file 'collect_stats.lua';
    }</pre></div><p>The requests to the /stat location will return the collected data. The second location block installs an additional log handler which is actually a counting hook. The effect is that all requests for the documents under /html hierarchy will invoke the collect_stats.lua script as part of the logging phase.</p></div><div class="section" title="The upsteam_check module in tengine"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec46"/>The upsteam_check module in tengine</h2></div></div></div><p>One <a class="indexterm" id="id294"/>of the many advantages of open<a class="indexterm" id="id295"/> source development models is the possibility of forks, which are separate versions of the main software with changes that are not accepted by the original author. Sometimes, forks become very successful in their own right and even supersede the original versions. One of the biggest Chinese websites Taobao has its own Nginx fork, which is named tengine. There are a number of big websites beside Taobao that prefer tengine to the original Nginx. Tengine has some rather advanced features for upstream management and monitoring.</p><p>The <code class="literal">upstream_check</code> module allows us to specify some custom health checks for all the hosts in an upstream group. That is an interesting functionality by itself, but it is the secondary feature that got the module in this chapter. The directive <code class="literal">check_status</code> inside a location is a content generator such as the <code class="literal">status</code> and <code class="literal">stub_status</code> of the official modules that we discussed at length in this chapter.</p><p>This directive provides a report on the health of different hosts in an upstream group in either human-readable HTML or machine-readable <a class="indexterm" id="id296"/>JSON or even CSV format.</p><p>See the examples<a class="indexterm" id="id297"/> of configuration and output at <a class="ulink" href="http://tengine.taobao.org/document_cn/http_upstream_check_cn.html">http://tengine.taobao.org/document_cn/http_upstream_check_cn.html</a>.</p></div><div class="section" title="The requests/sec patch by Catap"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec47"/>The requests/sec patch by Catap</h2></div></div></div><p>There<a class="indexterm" id="id298"/> is a patch for a very old Nginx version that adds one very interesting metric to the <code class="literal">ngx_http_stub_status</code> output. The metric is the requests rate that otherwise may be only approximately calculated using saved past state from the main total requests counter.</p><p>The <a class="indexterm" id="id299"/>patch is available at <a class="ulink" href="http://catap.ru/patches/nginx/request_per_seconds.dpatch">http://catap.ru/patches/nginx/request_per_seconds.dpatch</a>.</p><p>Unfortunately, it does not apply cleanly to modern Nginx source, so you will have to do some manual conflict resolution.</p></div><div class="section" title="The Ustats module"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec48"/>The Ustats module</h2></div></div></div><p>There is<a class="indexterm" id="id300"/> also another piece of rather old code that may or may not be brought up to date with modern Nginx. It is called Ustats, and it is officially put into the "abandonware" category. Such projects may provide a starting<a class="indexterm" id="id301"/> point for some in-house development efforts. See <a class="ulink" href="https://github.com/0xc0dec/ustats">https://github.com/0xc0dec/ustats</a> for the code and <a class="ulink" href="https://code.google.com/p/ustats/">https://code.google.com/p/ustats/</a> for some documentation.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec37"/>Summary</h1></div></div></div><p>In this chapter, we delved deep into the details of different ways to monitor a working Nginx instance. There is a very useful command-line log parsing utility ngxtop as well as two real-time statistics interfaces, which are available in open source and commercial versions of Nginx, respectively. We went over all the data items that these interfaces expose and discussed the integration options with many monitoring systems available on the market.</p><p>The next chapter will conclude the whole book by giving future directions for the reader. It may even seem to contain some career advice. There is also an appendix providing a reference into all the different errors and warnings that you may encounter in your work with Nginx.</p></div></body></html>