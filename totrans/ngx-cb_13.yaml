- en: NGINX Plus â€“ The Commercial Offering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing NGINX Plus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Real-time server activity monitoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic config reloading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Session persistence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the open source version of NGINX is the one most people are familiar with,
    Nginx Inc also produces a paid, commercial variant with a number of additional
    features aimed at enterprise and large tier deployments. With features such as
    detailed live monitoring, application health checking for load balancers, and
    dynamic configuration reloading, there are compelling reasons to consider the
    Plus version.
  prefs: []
  type: TYPE_NORMAL
- en: While some may find the US $2,500 starting point a steep jump over the open
    source version, these additional features pit it against commercial systems at
    over ten times the price. Suffice to say, once you get to the point where these
    features become paramount to your business, the price is well worth it. You'll
    also be supporting the continual development of NGINX, which most organizations
    with the Plus version still run.
  prefs: []
  type: TYPE_NORMAL
- en: Installing NGINX Plus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like its open source counterpart, NGINX Plus can be easily installed using the
    official repositories provided by NGINX.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have NGINX installed already, you'll need to uninstall it first to prevent
    conflict. As NGINX Plus is a paid product, you'll also require a license key to
    complete the installation as well. This can be purchased from the NGINX store
    or you can request a trial license so that you can evaluate the features before
    buying.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Official repositories exist for most major Linux installations, but we'll focus
    on just CentOS 7 and Ubuntu 16.04 LTS to cover the two most common scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: CentOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Firstly, we need to create a directory to store the repository certificates
    in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you will need to download both the private and public certificates from
    the NGINX customer portal ([https://cs.nginx.com](https://cs.nginx.com)), which
    should be named:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy these files into the directory created. We can then ensure that the root
    CA certificate bundle has been installed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now install the NGINX Plus repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'With the repository keys ready and the repository installed, we can now install
    NGINX Plus:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have the correct keys, this will install NGINX Plus. You can confirm
    the installation is correct by inspecting the version:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This should give you an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we can start and ensure that NGINX Plus automatically starts after
    boot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The installation of NGINX Plus is now complete.
  prefs: []
  type: TYPE_NORMAL
- en: Ubuntu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Firstly, we need to create a directory to store the repository certificates
    in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you will need to download both the private and public certificates from
    the NGINX customer portal ([https://cs.nginx.com](https://cs.nginx.com)), which
    should be named:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy these files into the directory created and then add the NGINX package
    signing key in using `apt-key`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To ensure we have the required prerequisites, we can install these packages
    with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then add the NGINX Plus repository via the `add-apt-repository` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we can install the NGINX Plus packages, we first need to link the secured
    repositories to the key we previously downloaded. NGINX provides a preconfigured
    file to do this and we can download it to the correct location:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'With the repository set up and prepared, we can now update the package information
    and then install NGINX Plus:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have the correct keys, this will install NGINX Plus. You can confirm
    the installation is correct by inspecting the version:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This should give you an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we can start and ensure NGINX Plus automatically starts after boot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The installation of NGINX Plus is now complete.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The NGINX Plus product page: [https://www.nginx.com/products/](https://www.nginx.com/products/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The NGINX Plus installation guide: [https://www.nginx.com/resources/admin-guide/installing-nginx-plus/](https://www.nginx.com/resources/admin-guide/installing-nginx-plus/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Real-time server activity monitoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We covered some of the basics of monitoring your server all the way back in
    [Chapter 1](69685f00-24c3-428c-b607-01a4e9a2784d.xhtml), *Let's Get Started*,
    which used the `ngxtop` utility to provide basic command line driven monitoring
    and statistics. Included in NGINX Plus is a powerful and comprehensive metrics
    system to show you real-time activity for your NGINX server.
  prefs: []
  type: TYPE_NORMAL
- en: As you'll see in the upcoming screenshots, this is quite a comprehensive system.
    Not only does it include a web interface so that you can see the stats, but this
    data is also available as a JSON feed so that it can be directly imported by external
    monitoring tools.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As this is part of the NGINX Plus packages, you''ll need to ensure you have
    NGINX Plus installed and configured correctly. You can test to ensure you have
    NGINX Plus by running `nginx -v`. This should give you an output similar to the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The important part to check is the *plus* in the naming for `nginx-plus-r12-p3`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to use the status module, we need to include it as part of the `server`
    block directive. You can choose to run in on a different port from your main web
    server and also restrict via IP, which is what we''ll do in our recipe. Here''s
    our configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This can be placed in the `/etc/nginx/conf.d/` directory as a separate file
    (for example, `status.conf`), to keep it clean and simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you open up a browser and go to `http://<serveripaddress>:8188/status.html`,
    you should see a page similar to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/abd0b9e7-1040-4b75-a169-e0a85a26a3a0.png)'
  prefs: []
  type: TYPE_IMG
- en: This page is just an HTML page, but uses the JSON data to update the status
    (every second by default). We can see all of the vital server statistics, such
    as the connections, requests, uptime, and traffic.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have multiple server zones configured, you can view the stats individually
    to see the various statistics of your subsystems:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a6bdcb96-2842-4ae9-9ae6-6d785fbcff99.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Likewise, we can see the stats associated with upstream servers if you''re
    using NGINX Plus in a load balancer configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8770adbd-37ec-4774-9e5d-47e3bc2e38f0.png)'
  prefs: []
  type: TYPE_IMG
- en: These insights allow you to precisely see what's going on with all aspects of
    your server in real-time.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We use the `listen` directive to tell NGINX Plus to listen on a different port
    for this `server` block, so that we can isolate it from the main connections.
    In this instance, we have it listening on port `8188`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set `status_zone`, which needs to be defined within each `server` or
    `http` block directive in order to collect statistics. For this recipe, we simply
    have one zone within our statistics block directive called `status-page`. For
    other `server` block directives, you can either combine into one (for example,
    `backend-zone`) or track individually if you require unique statistics per directive.
  prefs: []
  type: TYPE_NORMAL
- en: In order to serve the static `status.html` file, we define the root path where
    the files are located. Then, we ensure any root calls (for example, without a
    trailing `/status.html`) are redirected.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we set the `/status` location to serve the actual statistical data.
    We set this to be JSON format, which means it can be easily ingested into many
    other systems. It's what powers the HTML-based dashboard as well. This is required
    in order to display the statistics.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The HTML dashboard is, of course, only one way to use the stats. Because we
    have direct access to the JSON data, we can pull this data from a third-party
    monitoring system. For instance, we can view what information is available by
    calling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce a JSON based output, similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also reduce the output to the specific component you''re after, for
    example, we can call `/status/connections` to retrieve just the statistics about
    the connections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Don't forget to adjust your accept/allow and/or authentication for third-party
    monitoring systems.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The NGINX Plus status module documentation is available at: [https://nginx.org/en/docs/http/ngx_http_status_module.html](https://nginx.org/en/docs/http/ngx_http_status_module.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic config reloading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In large, high-scale systems where it's critical to minimize downtime, changes
    requiring a restart of services require careful planning. If you have a **Software
    as a Service** (**SaaS**) style platform, having a delay before deploying changes
    or new customer signups could be quite detrimental to your operations.
  prefs: []
  type: TYPE_NORMAL
- en: System downtime can also be required in load balancing situations, where you
    need to add and remove application backends on the fly. Thankfully, NGINX Plus
    allows for the configuration to be reloaded without having to restart the services.
    In this recipe, we'll go through how to update your configuration with a dynamic
    reload.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're using a basic recipe based on our load balancing recipe back in [Chapter
    8,](4709da7c-9dbd-49d8-8fa7-c3fb6a9cdd6a.xhtml) *Load Balancing*. With the open
    source version of NGINX, adding or removing backend servers from an NGINX configuration
    required a full reload in order to use the new changes. While this only has a
    minimal impact on lightly loaded systems, this can be a significant problem when
    it comes to highly loaded systems. As it has to wait for all NGINX worker processes
    to finish before reloading, there's a period where the system won't be processing
    at the same capacity as normal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how our scenario will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/08676d57-deaa-476d-be03-557852dca58c.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to allow the dynamic reload, we''ll configure our `upstream` block
    directive, as well as two `server` block directives. Like most of the NGINX configuration,
    we can place this in a standalone file (for example, `loadbalancer.conf`) within
    the `/etc/nginx/conf.d` directory. Here''s the configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You can also use the HTest tool for ease of testing if this is outside of a
    production environment to simulate the backend servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make changes to this configuration on the fly, we can invoke an API call
    from the command line. Firstly, let''s get a copy of the existing configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This should print a list of servers out, which should match the configuration
    we''ve already loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to add another backend, we can send an add command via `curl`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This should echo out the new server added as confirmation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The new server should be available immediately and will now be part of the round-robin
    assignment.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a similar fashion, we can also remove backend servers on the fly. To remove
    a server, we use the assigned ID to remove it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This will echo back the remaining servers configured, which for our example
    will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to a standard NGINX load balancer configuration, we first define an
    `upstream` block directive. This defines a memory allocation to store the configuration
    so that it can be updated on the fly.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we define our standard `server` block directive. This is as per a standard
    configuration, which simply proxies the connections to the upstream servers.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we then define a separate block directive to handle the `upstream_conf`
    module. We use the separate `server` block directive so that we can bind it to
    a specific port on the localhost and prevent accidental exposure to the internet.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While our example recipe allows for changes to be made on the fly, they aren''t
    persistent if we reboot NGINX Plus. To ensure these changes are maintained between
    reboots, we can add a `state` file to manage the current configuration. This is
    done via updating the `upstream` block directive. Here''s what our updated configuration
    looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We add the `state` directive, which is updated when there are any changes to
    the upstream configuration as well as being reread when NGINX restarts. All other
    server directives within that upstream must also be removed, as you can't combine
    static server configuration with a dynamic, stateful configuration. The state
    file itself is plain text (and uses the standard NGINX server directive format)
    but any direct manipulation of the file is strongly discouraged.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The NGINX Plus `http_upstream_conf` module documentation is available at: [https://nginx.org/en/docs/http/ngx_http_upstream_conf_module.html](https://nginx.org/en/docs/http/ngx_http_upstream_conf_module.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Session persistence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have a scenario where you have a load balancer with multiple backend
    servers (as we covered back in [Chapter 8](4709da7c-9dbd-49d8-8fa7-c3fb6a9cdd6a.xhtml),
    *Load Balancing*), there can be some tricky scenarios where session tracking would
    be difficult to implement. While using the hash-based algorithm can ensure requests
    from the same IP is routed to the same backend, this doesn't always ensure a balanced
    distribution of requests.
  prefs: []
  type: TYPE_NORMAL
- en: One of the key features for NGINX Plus is session persistence, where requests
    from the same client need to be sent to the same server for the life of that session.
    Also known as "sticky" sessions, this can be especially important when it comes
    to payment systems, where the sharing of information between backend servers can
    be quite restrictive.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll reuse our simple, round-robin load balancing scenario and incorporate
    the various session persistence options available in NGINX Plus.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are three different methods to ensuring sticky sessions, each with their
    various pros and cons. Here''s a quick summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cookie`: This method uses a cookie on the first request to store the tracking
    information in order to ensure subsequent requests are routed to the same backend
    server. As it means modifying the headers, it may not be compatible with all systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`learn`: This is a stateful method, which relies on existing data within existing
    response headers to determine a unique identifier in which to track the requests.
    For example, most web frameworks have their own session ID, which can be leveraged
    for tracking. This means that no data modification is required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`route`: Lastly, we can route the request based on variables to explicitly
    choose the upstream server to use. While similar to the cookie method (route also
    uses a cookie to help track), the explicit choice of server can be beneficial
    when you have reasons to push to different clients to different servers. This
    could be used a "feature flag" method of routing clients to newer servers with
    differing features if they match the specific variables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cookie-based tracking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To configure using cookie-based sticky sessions, we can use the following configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon the first request, NGINX will set a cookie to track all subsequent sessions.
    You can confirm the cookie by viewing received HTTP headers using a tool such
    as HTTPie:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This output should show the server headers, which will contain a `Set-Cookie`
    header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Learn-based tracking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you can leverage an existing, unique identifier from your application to
    use for session tracking, you can avoid having to create any further cookies.
    Many common web frameworks set the session as a cookie for tracking, so as long
    as you know the name of the cookie then it can be used. Here''s what our recipe
    looks like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: To test, you'll need to ensure that your application is sending a cookie set
    as `sessionid`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Route-based tracking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last method of creating and ensuring consistent sessions is via routes.
    In order to do this, we also need to tell NGINX Plus how to interpret the routes.
    Here''s our configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'For this recipe, we''re reading a cookie named `route` and then using this
    to determine which server to persistently send the request to. To test, we can
    send a test route cookie to ensure it''s working:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Each request should be served from the upstream server tagged as `server2`,
    which you can verify with the HTest utility or the logs of your backend server.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For our cookie-based session tracking, we set a cookie named `cookbook` to use
    as the tracking for session persistence. This is also set with an expiry of one
    hour. It's also possible to explicitly set the domain and path as well if greater
    restrictions are required.
  prefs: []
  type: TYPE_NORMAL
- en: Our learn-based tracking has three variables set. The first, create is used
    to track from the `upsteam` server, which we look for the cookie set header (`Set-Cookie`)
    using a naming pattern `$upstream_cookie_<cookiename>`. For our recipe, `$upstream_cookie_sessionid`
    means we match the `sessionid`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we use the `lookup` variable to designate what to track from the client.
    This uses a similar tracking method to the create command. This recipe uses the
    `$cookie_sessionid` pattern, which means it will match the contents of a cookie
    named `sessionid`.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, as this is stateful, we need to allocate memory in which to store the
    lookup table. This is done via the `zone` variable. For this recipe we have named
    the zone `client_sessions` and allocated 1 megabyte of memory. This is sufficient
    to store around 8,000 sessions. By default, these sessions are only persistent
    for 10 minutes. So, if you have a higher number of users per 10 minutes or require
    a longer timeout, you may need to increase the memory allocated.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The NGINX Plus `http_upstream_conf` module documentation is available at: [https://nginx.org/en/docs/http/ngx_http_upstream_conf_module.html#sticky](https://nginx.org/en/docs/http/ngx_http_upstream_conf_module.html#sticky)'
  prefs: []
  type: TYPE_NORMAL
