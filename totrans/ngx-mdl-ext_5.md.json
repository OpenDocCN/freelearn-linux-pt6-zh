["```\nngx_addon_name=ngx_http_hello_module\nHTTP_MODULES=\"$HTTP_MODULES ngx_http_hello_module\"\nNGX_ADDON_SRCS=\"$NGX_ADDON_SRCS $ngx_addon_dir/ngx_http_hello_module.c\"\n```", "```\n./configure --add-module=path/to/your/new/module/directory\n```", "```\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include <ngx_http.h>\n\nstatic char *ngx_http_hello(ngx_conf_t *cf, void *post, void*data);\n\nstatic ngx_conf_post_handler_pt ngx_http_hello_p = ngx_http_hello;\n\n/*\n * The structure will hold the value of the\n * module directive hello\n */\ntypedef struct {\n  ngx_str_t   name;\n} ngx_http_hello_loc_conf_t;\n\n/* The function which initializes memory for the module configuration structure       \n */\nstatic void *\nngx_http_hello_create_loc_conf(ngx_conf_t *cf)\n{\n  ngx_http_hello_loc_conf_t  *conf;\n\n  conf = ngx_pcalloc(cf->pool, sizeof(ngx_http_hello_loc_conf_t));\n  if (conf == NULL) {\n    return NULL;\n  }\n\n  return conf;\n}\n/*\n * The command array or array, which holds one subarray for each module\n * directive along with a function which validates the value of the\n * directive and also initializes the main handler of this module\n */\nstatic ngx_command_t ngx_http_hello_commands[] = {\n  { ngx_string(\"hello\"),NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,ngx_conf_set_str_slot,NGX_HTTP_LOC_CONF_OFFSET,offsetof(ngx_http_hello_loc_conf_t, name),&ngx_http_hello_p },\n\n  ngx_null_command\n};\n\nstatic ngx_str_t hello_string;\n\n/*\n * The module context has hooks , here we have a hook for creating\n * location configuration\n */\nstatic ngx_http_module_t ngx_http_hello_module_ctx = {\n  NULL,                          /* preconfiguration */\n  NULL,                          /* postconfiguration */\n\n  NULL,                          /* create main configuration */\n  NULL,                          /* init main configuration */\n\n  NULL,                          /* create server configuration */\n  NULL,                          /* merge server configuration */\n\n  ngx_http_hello_create_loc_conf, /* create location configuration */\n  NULL                           /* merge location configuration */\n};\n\n/*\n * The module which binds the context and commands\n *\n */\nngx_module_t ngx_http_hello_module = {NGX_MODULE_V1,\n  &ngx_http_hello_module_ctx,    /* module context */ngx_http_hello_commands,       /* module directives */NGX_HTTP_MODULE,               /* module type */NULL,                          /* init master */NULL,                          /* init module */NULL,                          /* init process */NULL,                          /* init thread */NULL,                          /* exit thread */NULL,                          /* exit process */NULL,                          /* exit master */NGX_MODULE_V1_PADDING\n};\n\n/*\n * Main handler function of the module.\n */\nstatic ngx_int_t\nngx_http_hello_handler(ngx_http_request_t *r)\n{\n  ngx_int_t    rc;\n  ngx_buf_t   *b;\n  ngx_chain_t  out;\n\n  /* we response to 'GET' and 'HEAD' requests only */\n  if (!(r->method & (NGX_HTTP_GET|NGX_HTTP_HEAD))) {\n    return NGX_HTTP_NOT_ALLOWED;\n  }\n\n  /* discard request body, since we don't need it here */\n  rc = ngx_http_discard_request_body(r);\n\n  if (rc != NGX_OK) {\n    return rc;\n  }\n\n  /* set the 'Content-type' header */\n  r->headers_out.content_type_len = sizeof(\"text/html\") - 1;\n  r->headers_out.content_type.len = sizeof(\"text/html\") - 1;\n  r->headers_out.content_type.data = (u_char *) \"text/html\";\n\n  /* send the header only, if the request type is http 'HEAD' */\n  if (r->method == NGX_HTTP_HEAD) {\n    r->headers_out.status = NGX_HTTP_OK;\n    r->headers_out.content_length_n = hello_string.len;\n    return ngx_http_send_header(r);\n  }\n\n  /* allocate a buffer for your response body */\n  b = ngx_pcalloc(r->pool, sizeof(ngx_buf_t));\n  if (b == NULL) {\n    return NGX_HTTP_INTERNAL_SERVER_ERROR;\n  }\n\n  /* attach this buffer to the buffer chain */\n  out.buf = b;\n  out.next = NULL;\n\n  /* adjust the pointers of the buffer */\n  b->pos = hello_string.data;\n  b->last = hello_string.data + hello_string.len;\n  b->memory = 1;    /* this buffer is in memory */\n  b->last_buf = 1;  /* this is the last buffer in the buffer chain*/\n\n  /* set the status line */\n  r->headers_out.status = NGX_HTTP_OK;\n  r->headers_out.content_length_n = hello_string.len;\n\n  /* send the headers of your response */\n  rc = ngx_http_send_header(r);\n\n  if (rc == NGX_ERROR || rc > NGX_OK || r->header_only) {\n    return rc;\n  }\n\n  /* send the buffer chain of your response */\n  return ngx_http_output_filter(r, &out);\n}\n\n/*\n * Function for the directive hello , it validates its value\n * and copies it to a static variable to be printed later\n */\nstatic char *\nngx_http_hello(ngx_conf_t *cf, void *post, void *data)\n{\n  ngx_http_core_loc_conf_t *clcf;\n  clcf = ngx_http_conf_get_module_loc_conf(cf,ngx_http_core_module);\n  clcf->handler = ngx_http_hello_handler;\n\n  ngx_str_t  *name = data; // i.e., first field ofngx_http_hello_loc_conf_t\n\n  if (ngx_strcmp(name->data, \"\") == 0) {\n    return NGX_CONF_ERROR;\n  }\n  hello_string.data = name->data;\n  hello_string.len = ngx_strlen(hello_string.data);\n\n  return NGX_CONF_OK;\n}\n```", "```\nserver {\nlisten 8080;\nserver_name localhost;\n\nlocation / {\nhello 'Hello World';\n  }\n}\n```", "```\ntypedef struct {\n  ngx_str_t   name;\n} ngx_http_hello_loc_conf_t;\n```", "```\nstatic ngx_command_t ngx_http_hello_commands[] = {{ ngx_string(\"hello\"),NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,ngx_conf_set_str_slot,NGX_HTTP_LOC_CONF_OFFSET,offsetof(ngx_http_hello_loc_conf_t, name),&ngx_http_hello_p },\n\n  ngx_null_command\n};\n```", "```\nNGX_HTTP_MAIN_CONF: directive should be used in main section\nNGX_HTTP_SRV_CONF : directive should be used in the server section\nNGX_HTTP_LOC_CONF : directive should be used in the locationsection\nNGX_HTTP_UPS_CONF : directive should be used in the upstreamsection\nNGX_CONF_NOARGS   : directive will take no arguments\nNGX_CONF_TAKE1    : directive will take 1 argument\nNGX_CONF_TAKE2    : directive will take 2 arguments\n…\nNGX_CONF_TAKE7    : directive will take 7 arguments\nNGX_CONF_TAKE12   : directive will take 1 or 2 arguments\nNGX_CONF_TAKE13   : directive will take 1 or 3 arguments   \nNGX_CONF_TAKE23   : directive will take 2 or 3 arguments\nNGX_CONF_TAKE123  : directive will take 1, 2 or 3 arguments\nNGX_CONF_TAKE1234 : directive will take 1, 2 , 3 or 4 arguments\n\nNGX_CONF_FLAG     : directive accepts a boolean value from \"on\" or\"off\"\nNGX_CONF_1MORE    : directive requires at least one argument\nNGX_CONF_2MORE    : directive requires at least at least twoarguments\n```", "```\n#define NGX_CONF_MAX_ARGS   8\n```", "```\ntypedef struct {\n  ngx_int_t   (*preconfiguration)(ngx_conf_t *cf);\n  ngx_int_t   (*postconfiguration)(ngx_conf_t *cf);\n\n  void       *(*create_main_conf)(ngx_conf_t *cf);\n  char       *(*init_main_conf)(ngx_conf_t *cf, void *conf);\n\n  void       *(*create_srv_conf)(ngx_conf_t *cf);\n  char       *(*merge_srv_conf)(ngx_conf_t *cf, void *prev, void*conf);\n\n  void       *(*create_loc_conf)(ngx_conf_t *cf);\n  char       *(*merge_loc_conf)(ngx_conf_t *cf, void *prev, void*conf);\n} ngx_http_module_t;\n```", "```\n/*\n * The module context has hooks , here we have a hook for creating\n * location configuration\n */\nstatic ngx_http_module_t ngx_http_hello_module_ctx = {NULL,                          /* preconfiguration */NULL,                          /* postconfiguration */NULL,                          /* create main configuration */NULL,                          /* init main configuration */NULL,                          /* create server configuration */NULL,                          /* merge server configuration */ngx_http_hello_create_loc_conf, /* create location configuration*/NULL                           /* merge location configuration*/\n};\n```", "```\n/* The function which initializes memory for the module configuration structure       \n */\nstatic void *\nngx_http_hello_create_loc_conf(ngx_conf_t *cf)\n{\n  ngx_http_hello_loc_conf_t  *conf;\n\n  conf = ngx_pcalloc(cf->pool, sizeof(ngx_http_hello_loc_conf_t));\n  if (conf == NULL) {\n    return NULL;\n  }\n\n  return conf;\n}\n```", "```\nstatic char *ngx_http_example_merge_loc_conf(ngx_conf_t *cf, void *parent,void *child)\n{\n  ngx_http_example_loc_conf_t *prev = parent;\n  ngx_http_example_loc_conf_t *conf = child;\n\n  ngx_conf_merge_uint_value(conf->val1, prev->val1, 10);\n  ngx_conf_merge_uint_value(conf->val2, prev->val2, 20);\n\n  if (conf->val1 < 1) {\n    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\"value 1 must be equal or more than 1\");\n    return NGX_CONF_ERROR;\n  }\n  if (conf->val2 < conf->val1) {\n    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\"val2 must be equal or more than val1\");\n    return NGX_CONF_ERROR;\n  }\n\n  return NGX_CONF_OK;\n}\n```", "```\n#define ngx_conf_merge_value(conf, prev, default) \\\n  if (conf == NGX_CONF_UNSET) { \\\n  conf = (prev == NGX_CONF_UNSET) ? default : prev; \\\n  }\n\n#define ngx_conf_merge_ptr_value(conf, prev, default) \\\n  if (conf == NGX_CONF_UNSET_PTR) { \\\n    conf = (prev == NGX_CONF_UNSET_PTR) ? default : prev; \\\n  }\n\n#define ngx_conf_merge_uint_value(conf, prev, default) \\\n  if (conf == NGX_CONF_UNSET_UINT) { \\\n    conf = (prev == NGX_CONF_UNSET_UINT) ? default : prev; \\\n  }\n\n#define ngx_conf_merge_msec_value(conf, prev, default) \\\n  if (conf == NGX_CONF_UNSET_MSEC) { \\\n    conf = (prev == NGX_CONF_UNSET_MSEC) ? default : prev; \\\n  }\n\n#define ngx_conf_merge_sec_value(conf, prev, default) \\\n  if (conf == NGX_CONF_UNSET) { \\\n    conf = (prev == NGX_CONF_UNSET) ? default : prev; \\\n  }\n\n#define ngx_conf_merge_size_value(conf, prev, default) \\\n  if (conf == NGX_CONF_UNSET_SIZE) { \\\n    conf = (prev == NGX_CONF_UNSET_SIZE) ? default : prev; \\\n  }\n\n#define ngx_conf_merge_off_value(conf, prev, default) \\\n  if (conf == NGX_CONF_UNSET) { \\\n    conf = (prev == NGX_CONF_UNSET) ? default : prev; \\\n  }\n\n#define ngx_conf_merge_str_value(conf, prev, default) \\\n  if (conf.data == NULL) { \\\n  if (prev.data) { \\\n    conf.len = prev.len; \\\n     conf.data = prev.data; \\\n    } else { \\\n    conf.len = sizeof(default) - 1; \\\n    conf.data = (u_char *) default; \\\n    } \\\n  }\n\n#define ngx_conf_merge_bufs_value(conf, prev, default_num,default_size)     \\\n  if (conf.num == 0) { \\\n    if (prev.num) { \\\n      conf.num = prev.num; \\\n      conf.size = prev.size; \\\n      } else { \\\n      conf.num = default_num; \\\n      conf.size = default_size; \\\n      } \\\n  }\n```", "```\n#define NGX_LOG_STDERR            0\n#define NGX_LOG_EMERG             1\n#define NGX_LOG_ALERT             2\n#define NGX_LOG_CRIT              3\n#define NGX_LOG_ERR               4\n#define NGX_LOG_WARN              5\n#define NGX_LOG_NOTICE            6\n#define NGX_LOG_INFO              7\n#define NGX_LOG_DEBUG             8\n```", "```\n#define NGX_MODULE_V1          0, 0, 0, 0, 0, 0, 1\n#define NGX_MODULE_V1_PADDING  0, 0, 0, 0, 0, 0, 0, 0\n\nstruct ngx_module_s {\n  ngx_uint_t            ctx_index;\n  ngx_uint_t            index;\n\n  ngx_uint_t            spare0;\n  ngx_uint_t            spare1;\n  ngx_uint_t            spare2;\n  ngx_uint_t            spare3;\n  ngx_uint_t            version;\n\n  void                 *ctx;\n  ngx_command_t        *commands;\n  ngx_uint_t            type;\n\n  ngx_int_t           (*init_master)(ngx_log_t *log);\n\n  ngx_int_t           (*init_module)(ngx_cycle_t *cycle);\n\n  ngx_int_t           (*init_process)(ngx_cycle_t *cycle);\n  ngx_int_t           (*init_thread)(ngx_cycle_t *cycle);\n  void                (*exit_thread)(ngx_cycle_t *cycle);\n  void                (*exit_process)(ngx_cycle_t *cycle);\n\n  void                (*exit_master)(ngx_cycle_t *cycle);\n\n  uintptr_t             spare_hook0;\n  uintptr_t             spare_hook1;\n  uintptr_t             spare_hook2;\n  uintptr_t             spare_hook3;\n  uintptr_t             spare_hook4;\n  uintptr_t             spare_hook5;\n  uintptr_t             spare_hook6;\n  uintptr_t             spare_hook7;\n};\n```", "```\n/*\n * The module which binds the context and commands\n *\n */\nngx_module_t ngx_http_hello_module = {NGX_MODULE_V1,&ngx_http_hello_module_ctx,    /* module context */ngx_http_hello_commands,       /* module directives */NGX_HTTP_MODULE,               /* module type */NULL,                          /* init master */NULL,                          /* init module */NULL,                          /* init process */NULL,                          /* init thread */NULL,                          /* exit thread */\n  NULL,                          /* exit process */NULL,                          /* exit master */NGX_MODULE_V1_PADDING\n};\n```", "```\n/*\n * Main handler function of the module.\n */\nstatic ngx_int_tngx_http_hello_handler(ngx_http_request_t *r)\n{\n  ngx_int_t    rc;\n  ngx_buf_t   *b;\n  ngx_chain_t  out;\n\n  /* we response to 'GET' and 'HEAD' requests only */\n  if (!(r->method & (NGX_HTTP_GET|NGX_HTTP_HEAD))) {\n    return NGX_HTTP_NOT_ALLOWED;\n  }\n\n  /* discard request body, since we don't need it here */\n  rc = ngx_http_discard_request_body(r);\n\n  if (rc != NGX_OK) {\n    return rc;\n  }\n\n  /* set the 'Content-type' header */\n  r->headers_out.content_type_len = sizeof(\"text/html\") - 1;\n  r->headers_out.content_type.data = (u_char *) \"text/html\";\n  /* send the header only, if the request type is http 'HEAD' */\n  if (r->method == NGX_HTTP_HEAD) {\n    r->headers_out.status = NGX_HTTP_OK;\n    r->headers_out.content_length_n = hello_string.len;\n\n  return ngx_http_send_header(r);\n  }\n\n  /* allocate a buffer for your response body */\n  b = ngx_pcalloc(r->pool, sizeof(ngx_buf_t));\n  if (b == NULL) {\n    return NGX_HTTP_INTERNAL_SERVER_ERROR;\n  }\n\n  /* attach this buffer to the buffer chain */\n  out.buf = b;\n  out.next = NULL;\n\n  /* adjust the pointers of the buffer */\n  b->pos = hello_string.data;\n  b->last = hello_string.data + hello_string.len;\n  b->memory = 1;    /* this buffer is in memory */\n  b->last_buf = 1;  /* this is the last buffer in the buffer chain*/\n\n  /* set the status line */\n  r->headers_out.status = NGX_HTTP_OK;\n  r->headers_out.content_length_n = hello_string.len;\n\n  /* send the headers of your response */\n  rc = ngx_http_send_header(r);\n\n  if (rc == NGX_ERROR || rc > NGX_OK || r->header_only) {\n    return rc;\n  }\n\n  /* send the buffer chain of your response */\n  return ngx_http_output_filter(r, &out);\n}\n```", "```\nserver {\nlisten 8080;\nserver_name localhost;\n\nlocation / {\nhello 'Hello World';\n  }\n}\n```", "```\n  /* we response to 'GET' and 'HEAD' requests only */\n  if (!(r->method & (NGX_HTTP_GET|NGX_HTTP_HEAD))) {\n    return NGX_HTTP_NOT_ALLOWED;\n  }\n```", "```\ntypedef struct {\n  ngx_list_t                        headers;\n\n  ngx_uint_t                        status;\n  ngx_str_t                         status_line;\n\n  ngx_table_elt_t                  *server;\n  ngx_table_elt_t                  *date;\n  ngx_table_elt_t                  *content_length;\n  ngx_table_elt_t                  *content_encoding;\n  ngx_table_elt_t                  *location;\n  ngx_table_elt_t                  *refresh;\n  ngx_table_elt_t                  *last_modified;\n  ngx_table_elt_t                  *content_range;   ngx_table_elt_t                  *accept_ranges;\n  ngx_table_elt_t                  *www_authenticate;\n  ngx_table_elt_t                  *expires;\n  ngx_table_elt_t                  *etag;\n\n  ngx_str_t                        *override_charset;\n\n  size_t                            content_type_len;\n  ngx_str_t                         content_type;\n  ngx_str_t                         charset;\n  u_char                           *content_type_lowcase;\n  ngx_uint_t                        content_type_hash;\n\n  ngx_array_t                       cache_control;\n\n  off_t                             content_length_n;\n  time_t                            date_time;\n  time_t                            last_modified_time;\n} ngx_http_headers_out_t;\n```"]