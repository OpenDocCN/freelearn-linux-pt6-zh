<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;The Core HTTP Module"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. The Core HTTP Module</h1></div></div></div><p>In this chapter, we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Installing new modules and compiling Nginx</li><li class="listitem" style="list-style-type: disc">Running Nginx in debug mode</li><li class="listitem" style="list-style-type: disc">Easy reloading of Nginx using the CLI</li><li class="listitem" style="list-style-type: disc">Splitting configuration files for better management</li><li class="listitem" style="list-style-type: disc">Setting up multiple virtual hosts</li><li class="listitem" style="list-style-type: disc">Setting up a default catch-all virtual host</li><li class="listitem" style="list-style-type: disc">Using wildcards in virtual hosts</li><li class="listitem" style="list-style-type: disc">Setting up the number of worker processes correctly</li><li class="listitem" style="list-style-type: disc">Increasing the size of uploaded files</li><li class="listitem" style="list-style-type: disc">Using dynamic SSI for simple sites</li><li class="listitem" style="list-style-type: disc">Adding content before and after a particular page</li><li class="listitem" style="list-style-type: disc">Enabling auto indexing of a directory</li><li class="listitem" style="list-style-type: disc">Serving any random web page from a directory</li><li class="listitem" style="list-style-type: disc">Serving cookies for identifying and logging users</li><li class="listitem" style="list-style-type: disc">Re-encoding the response to another encoding</li><li class="listitem" style="list-style-type: disc">Enabling Gzip compression on some content types</li><li class="listitem" style="list-style-type: disc">Setting up 404 and other error pages</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec01"/>Introduction</h1></div></div></div><p>This chapter deals with the basics of Nginx configuration and implementation. By the end of it you should be able to compile Nginx on your machine, create virtual hosts, set up user tracking, and get PHP to work.</p></div></div>
<div class="section" title="Installing new modules and compiling Nginx"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec02"/>Installing new modules and compiling Nginx</h1></div></div></div><p>Today, most softwares are designed to be modular and extensible. Nginx, with its great community, has an amazing set of modules out there that lets it do some pretty interesting things. Although most operating system distributions have Nginx binaries in their repositories, it is a necessary skill to be able to compile new, bleeding edge modules, and try them out. Now we will outline how one can go about compiling and installing Nginx with its numerous third-party modules.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec01"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"> The first step is to get the latest Nginx distribution, so that you are in sync with the security and performance patches (<a class="ulink" href="http://sysoev.ru/nginx/nginx-0.7.67.tar.gz">http://sysoev.ru/nginx/nginx-0.7.67.tar.gz</a>). Do note that you will require sudo or root access to do some of the installation steps going ahead.<a class="indexterm" id="id0"/><div class="mediaobject"><img alt="How to do it..." height="156" src="graphics/4965_01_01.jpg"/></div></li><li class="listitem"> Un-tar the Nginx source code. This is simple, you will need to enter the following command:<div class="informalexample"><pre class="programlisting">tar -xvzf nginx-0.7.67.tar.gz
</pre></div></li><li class="listitem"> Go into the directory and configure it. This is essential, as here you can enable and disable the core modules that already come with Nginx. Following is a sample configure command:<div class="informalexample"><pre class="programlisting">./configure - with-debug \
--with-http_ssl_module \
--with-http_realip_module \
--with-http_ssl_module \
--with-http_perl_module \
--with-http_stub_status_module
</pre></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: none">You can figure out more about what other modules and configuration flags use:</li></ul></div><div class="informalexample"><pre class="programlisting">./configure - help
</pre></div></li><li class="listitem"> If you get an error, then you will need to install the build dependencies, depending on your system. For example, if you are running a Debian based system, you can enter the following command:<div class="informalexample"><pre class="programlisting">apt-get build-dep nginx
</pre></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: none">This will install all the required build dependencies, like PCRE and TLS libraries.<a class="indexterm" id="id1"/></li></ul></div></li><li class="listitem"> After this, you can simply go ahead and build it:<div class="informalexample"><pre class="programlisting">sudo make install
</pre></div></li><li class="listitem"> This was the plain vanilla installation! If you want to install some new modules, we take the example of the HTTP subscribe-publish module:</li><li class="listitem"> Download your module (<a class="ulink" href="http://pushmodule.slact.net/downloads/nginx_http_push_module-0.692.tar.gz">http://pushmodule.slact.net/downloads/nginx_http_push_module-0.692.tar.gz</a>).</li><li class="listitem"> Un-tar it at a certain location:/path/to/module.</li><li class="listitem"> Reconfigure Nginx installation:<div class="informalexample"><pre class="programlisting">./configure ..... --add-module=/path/to/module
</pre></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: none">The important part is to point the add-module flag to the right module path. The rest is handled by the Nginx configuration script.</li></ul></div></li><li class="listitem"> You can continue to build and install Nginx as shown in step 5.<a class="indexterm" id="id2"/></li></ol></div><div class="informalexample"><pre class="programlisting">sudo make install
</pre></div><p>If you have followed steps 1 to 10, it will be really easy for you to install any Nginx module.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec02"/>There's more...</h2></div></div></div><p>If you want to check that the module is installed correctly, you can enter the following command:</p><div class="informalexample"><pre class="programlisting">nginx -V
</pre></div><p>A sample output is something as shown in the following screenshot:</p><div class="mediaobject"><img alt="There's more..." height="40" src="graphics/4965_01_02.jpg"/></div><p>This basically gives you the compilation flags that were used to install this particular binary of Nginx, indirectly listing the various modules that were compiled into it.</p></div></div>
<div class="section" title="Running Nginx in debug mode"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec03"/>Running Nginx in debug mode</h1></div></div></div><p>Nginx is a fairly stable piece of software which has been running in production for over a decade and has built a very strong developer community around it. But, like all software there are issues and bugs which crop up under the most critical of situations. When that happens, it's usually best to reload Nginx with higher levels of error logging and if possible, in the debug mode.<a class="indexterm" id="id3"/>
</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec03"/>How to do it...</h2></div></div></div><p>If you want the debug mode, then you will need to compile Nginx with the debug flag (--with-debug). In most cases, most of the distributions have packages where Nginx is pre-compiled with debug flag. Here are the various levels of debugging that you can utilize:<a class="indexterm" id="id4"/>
</p><div class="informalexample"><pre class="programlisting">error_log LOGFILE [debug | info | notice | warn | error | crit | debug_core | debug_alloc | debug_mutex | debug_event | debug_http | debug_imap];
</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip01"/>Tip</h3><p><span class="strong"><strong>Downloading the example code</strong></span></p><p>You can download the example code files for all Packt books you have purchased from your account at <a class="ulink" href="http://www.PacktPub.com">http://www.PacktPub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.PacktPub.com/support">http://www.PacktPub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div><p>If you do not set the error log location, it will log to a compiled-in default log location. This logging is in addition to the normal error logging that you can do per site. Here is what the various specific debug flags do:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left" width="1.15"/><col style="text-align: left" width="2.84657986111111"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Flags</p>
</th><th style="text-align: left" valign="bottom">
<p>Application</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">debug_core</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Lets you dump the core when Nginx crashes</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">debug_alloc</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Logs all memory allocation warnings and errors</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">debug_mutex</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Logs potential mutex issues</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">debug_event</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Logs events module issues</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">debug_http</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is the default HTTP logging</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">debug_imap</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is the default IMAP logging</p>
</td></tr></tbody></table></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec04"/>There's more...</h2></div></div></div><p>Nginx allows us to log errors for specific IP addresses. Here is a sample configuration that will log errors from<code class="literal"> 192.168.1.1</code> and the IP range of<code class="literal"> 192.168.10.0/24:</code>
<a class="indexterm" id="id5"/>
</p><div class="informalexample"><pre class="programlisting">error_log logs/error.log;
events {
debug_connection 192.168.1.1;
debug_connection 192.168.10.0/24;
}
</pre></div><p>This is extremely useful when you want to debug in the production environment, as logging for all cases has unnecessary performance overheads. This feature allows you to not set a global debug on the<code class="literal"> error_log</code>, while being able to see the debug output for specific matched IP blocks based on the user's IP address.</p></div></div>
<div class="section" title="Easy reloading of Nginx using the CLI"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec04"/>Easy reloading of Nginx using the CLI</h1></div></div></div><p>Depending on the system that you have, it will offer one clean way of reloading your Nginx setup<a class="indexterm" id="id6"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Debian based:</strong></span> <code class="literal">/etc/init.d/Nginx reload</code></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Fedora based:</strong></span> <code class="literal">service Nginx reload</code></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>FreeBSD/BSD:</strong></span> <code class="literal">service Nginx reload</code></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Windows:</strong></span> <code class="literal">Nginx -s reload</code></li></ul></div><p>All the preceding commands reload Nginx; they send a HUP signal to the main Nginx process. You can send quite a few control signals to the Nginx master process, as outlined in the following table. These let you manage some of the basic administrative tasks:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left" width="0.755000000000001"/><col style="text-align: left" width="4.7"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Signal</p>
</th><th style="text-align: left" valign="bottom">
<p>Activity</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>TERM,INT</p>
</td><td style="text-align: left" valign="top">
<p>Quick shutdown</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>QUIT</p>
</td><td style="text-align: left" valign="top">
<p>Graceful shutdown</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>HUP</p>
</td><td style="text-align: left" valign="top">
<p>Reload configuration, gracefully shutdown the worker processes and restart them</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>USR1</p>
</td><td style="text-align: left" valign="top">
<p>Reopen the log files</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>USR2</p>
</td><td style="text-align: left" valign="top">
<p>Upgrade the executable on the fly, when you have already installed it</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>WINCH</p>
</td><td style="text-align: left" valign="top">
<p>Gracefully shutdown the worker process</p>
</td></tr></tbody></table></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec05"/>How to do it...</h2></div></div></div><p>Let me run you through the simple steps of how you can reload Nginx from the command line.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"> Open a terminal on your system. Most UNIX-based systems already have fairly powerful terminals, while you can use PuTTY on Windows systems.</li><li class="listitem"> Type in<code class="literal"> ps auxww | grep nginx</code>. This will output something as shown in the following screenshot:<div class="mediaobject"><img alt="How to do it..." height="82" src="graphics/4965_01_03.jpg"/></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: none">If nothing comes, then it means that Nginx is not running on your system.</li></ul></div></li><li class="listitem"> If you get the preceding output, then you can see the master process and the two worker processes (it may be more, depending on your<code class="literal"> worker_processes</code> configuration). The important number is<code class="literal"> 3322</code>, which is basically the PID of the master process.<a class="indexterm" id="id7"/></li><li class="listitem"> To reload Nginx, you can issue the command<code class="literal"> kill -HUP &lt;PID of the nginx master process&gt;</code>. In this case, the PID of the master process is<code class="literal"> 3322</code>. This will basically read the configurations again, gracefully close your current connections, and start new worker processes. You can issue another<code class="literal"> ps auxww | grep nginx</code> to see new PIDs for the worker processes (4582,4583):<div class="mediaobject"><img alt="How to do it..." height="74" src="graphics/4965_01_04.jpg"/></div></li><li class="listitem"> If the worker PIDs do not change it means that you may have a problem while reloading the configuration files. Go ahead and check the Nginx error log.</li></ol></div><p>This is very useful while writing scripts, which control Nginx configuration. A good example is when you are deploying code on production; you will temporarily point the site to a static landing page.<a class="indexterm" id="id8"/>
</p></div></div>
<div class="section" title="Splitting configuration files for better management"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec06"/>Splitting configuration files for better management</h1></div></div></div><p>By default, when you are installing Nginx you get this one monolithic configuration file which contains a whole lot of sample configurations. Due to its extremely modular and robust designing, Nginx allows you to maintain your configuration file as a set of multiple linked files.<a class="indexterm" id="id9"/>
</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec06"/>How to do it...</h2></div></div></div><p>Let's take a sample configuration file<code class="literal"> nginx.conf</code> and see how can it be broken into logical, maintainable pieces:</p><div class="informalexample"><pre class="programlisting">user www www; #This directive determines the user and group of the processes started
worker_processes 2;
error_log logs/error.log;
pid logs/nginx.pid;
events {
worker_connections 1024;
}
http {
include mime.types;
default_type application/octet-stream;
gzip on;
gzip_min_length 5000;
gzip_buffers 4 8k;
gzip_types text/plain text/html text/css application/x-javascript text/xml application/xml application/xml+rss text/javascript;
gzip_proxied any;
gzip_comp_level 2;
ignore_invalid_headers on;
server {
listen 80;
server_name www.example1.com;
location / {
root /var/www/www.example1.com;
index index.php index.html index.htm;
}
location ~ \.php$ {
include conf/fcgi.conf;
fastcgi_pass 127.0.0.1:9000;
}
}
}
</pre></div><p>The preceding configuration is basically serving a simple PHP site at<code class="literal"> http://www.example1.com</code> using FastCGI. Now we can go ahead and split this file into the following structure:<a class="indexterm" id="id10"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">nginx.conf:</code> The central configuration file remains</li><li class="listitem" style="list-style-type: disc"><code class="literal">fcgi.conf:</code> This will contain all the FastCGI configurations</li><li class="listitem" style="list-style-type: disc"><code class="literal">sites-enabled/:</code> This directory will contain all the sites that are enabled (much like Apache2's sites-enabled directory)</li><li class="listitem" style="list-style-type: disc"><code class="literal">sites-available/:</code> This directory will contain all the sites that are not active, but available (again, much like Apache2's sites-available)</li><li class="listitem" style="list-style-type: disc"><code class="literal">sites-enabled/site1.conf:</code> This is the sample virtual host configuration of the sample PHP site</li></ul></div><p>The following code is for the new<code class="literal"> nginx.conf</code>
</p><div class="informalexample"><pre class="programlisting">user www www;
worker_processes 2;
error_log logs/error.log;
pid logs/nginx.pid;
events {
worker_connections 1024;
}
http {
include mime.types;
default_type application/octet-stream;
gzip on;
gzip_min_length 5000;
gzip_buffers 4 8k;
gzip_types text/plain text/html text/css application/x-javascript text/xml application/xml application/xml+rss text/javascript;
gzip_proxied any;
gzip_comp_level 2;
ignore_invalid_headers on;
includes sites-available/*;
}
</pre></div><p>If you notice, you will see how<code class="literal"> includes</code> has allowed the inclusion of external configuration files. It should be noted that if we have any errors in any of the files, the Nginx server will fail to reload.<a class="indexterm" id="id11"/>
</p><p>Here is the FastCGI configuration which is used by this setup; generally most Nginx installations provide a default one.</p><p>The following is the code for<code class="literal"> fcgi.conf:</code>
</p><div class="informalexample"><pre class="programlisting">fastcgi_param QUERY_STRING $query_string;
fastcgi_param REQUEST_METHOD $request_method;
fastcgi_param CONTENT_TYPE $content_type;
fastcgi_param CONTENT_LENGTH $content_length;
fastcgi_param SCRIPT_NAME $fastcgi_script_name;
fastcgi_param REQUEST_URI $request_uri;
fastcgi_param DOCUMENT_URI $document_uri;
fastcgi_param DOCUMENT_ROOT $document_root;
fastcgi_param SERVER_PROTOCOL $server_protocol;
fastcgi_param GATEWAY_INTERFACE CGI/1.1;
fastcgi_param SERVER_SOFTWARE nginx/$nginx_version;
fastcgi_param REMOTE_ADDR $remote_addr;
fastcgi_param REMOTE_PORT $remote_port;
fastcgi_param SERVER_ADDR $server_addr;
fastcgi_param SERVER_PORT $server_port;
fastcgi_param SERVER_NAME $server_name;
fastcgi_index index.php ;
fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name ;
# PHP only, required if PHP was built with --enable-force-cgi-redirect
fastcgi_param REDIRECT_STATUS 200;
fastcgi_connect_timeout 60;
fastcgi_send_timeout 180;
fastcgi_read_timeout 180;
fastcgi_buffer_size 128k;
fastcgi_buffers 4 256k;
fastcgi_busy_buffers_size 256k;
fastcgi_temp_file_write_size 256k;
fastcgi_intercept_errors on;
</pre></div><p>The following is the code for<code class="literal"> sites-enabled/site1.conf:</code>
<a class="indexterm" id="id12"/>
</p><div class="informalexample"><pre class="programlisting">server {
listen 80;
server_name www.example1.com;
location / {
root /var/www/www.example1.com;
index index.php index.html index.htm;
}
location ~ \.php$ {
include conf/fcgi.conf;
fastcgi_pass 127.0.0.1:9000;
}
}
</pre></div><p>This sort of a file arrangement allows clean separation of the main configuration and the auxiliary ones. It also promotes structured thinking, which is useful when you have to quickly switch or deploy sites.</p><p>We will go over the various configurations that you see in these files in other chapters. For example,<code class="literal"> fcgi.conf</code> is covered in the recipe to get PHP working with Nginx using FastCGI.</p></div></div>
<div class="section" title="Setting up multiple virtual hosts"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec07"/>Setting up multiple virtual hosts</h1></div></div></div><p>Usually any web server hosts one or more domains, and Nginx, like any good web server, allows you to easily configure as many virtual hosts as you want.<a class="indexterm" id="id13"/>
</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec07"/>How to do it...</h2></div></div></div><p>Let's take a simple example. You want to set up a simple set of webpages on<a class="ulink" href="http://www.example1.com"> www.example1.com</a>. Here is the sample configuration which needs to go into the<code class="literal"> sites-enabled/site1.conf:</code>
</p><div class="informalexample"><pre class="programlisting">server {
listen 80;
server_name www.example1.com example1.com;
access_log /var/log/Nginx/example1.com/access.log;
error_log /var/log/Nginx/example1.com/error.log;
location / {
root /var/www/www.example1.com;
index index.html index.htm;
}
}
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec08"/>How it works...</h2></div></div></div><p>So let's see how this works. The<code class="literal"> listen</code> defines the port on which the web server is listening (in this case, its 80)! The<code class="literal"> server_name</code> lets you easily define the domain that maps to this virtual host configuration. Inside, you can start defining how the virtual host works. In this case it serves set of HTML pages from the<code class="literal"> /var/www/www.example1.com</code> directory.</p><p>So when you reload your Nginx configuration assuming that your DNS records point correctly at your server, you should see your HTML pages load when you access the web address (in this case,<a class="ulink" href="http://www.example1.com)"> http://www.example1.com)</a>.<a class="indexterm" id="id14"/>
</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec09"/>There's more...</h2></div></div></div><p>Here is a quick checklist to get you started:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"> Create a simple directory with the HTML files.</li><li class="listitem"> Create a simple configuration file containing the virtual host configuration for<code class="literal"> www.example1.com</code>.</li><li class="listitem"> Reload Nginx.</li><li class="listitem"> Point your DNS server to the correct server running Nginx.</li><li class="listitem"> Load<code class="literal"> www.example1.com</code>.</li></ol></div></div></div>
<div class="section" title="Setting up a default catch-all virtual host"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Setting up a default catch-all virtual host</h1></div></div></div><p>Once you are comfortable setting up the virtual hosts, you will end up in a situation where you have a lot of domains pointing at the IP. In addition to the domains, you would also have the web server responding to the IP addresses it hosts, and many other unused subdomains of the domains pointing at it. We can take a look at this with a simple example, so you have<a class="ulink" href="http://www.example1.com"> http://www.example1.com</a> pointing at the IP address, you have configured a virtual host to handle the domains<a class="ulink" href="http://www.example1.com"> www.example1.com</a> and<a class="ulink" href="http://example1.com"> example1.com</a>. In such a scenario, when the user types in<code class="literal"> abc.example1.com</code> or an IP address the web server will not be able to serve the relevant content (be it 404 or some other promotional page).<a class="indexterm" id="id15"/>
</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec10"/>How to do it...</h2></div></div></div><p>For situations like the one above, one can utilize the default catchall virtual host that Nginx provides; here is a simple example where this default catchall virtual host serves a simple set of web pages.</p><p>The following is the code for<code class="literal"> sites-enabled/default.conf:</code>
</p><div class="informalexample"><pre class="programlisting">server {
listen 80 default;
server_name _;
location / {
root /var/www/default;
index index.html index.htm;
}
}
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec11"/>How it works...</h2></div></div></div><p>The key thing to note is the fact that you are listening on the default port and that the<code class="literal"> server_name</code> is "_" which is the catchall mechanism. So whenever the user enters a domain for which you have no defined virtual host, pages will get server from the<code class="literal"> /var/www/default</code> directory.</p></div></div>
<div class="section" title="Using wildcards in virtual hosts"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Using wildcards in virtual hosts</h1></div></div></div><p>Imagine a situation where you need to create an application that needs to serve dynamic pages on subdomains! In that case, you will need to set up a virtual host in Nginx that can utilize wildcards. Nginx has been made ground up to handle such a scenario. So let's take our favorite example of<a class="ulink" href="http://www.example1.com"> http://www.example1.com</a>. Let's say you are building an application that needs to handle the various subdomains such as <code class="literal">a.example1.com</code>, <code class="literal">b.example1.com</code>, and so on. The following configuration would let the application behind handle all these various subdomains.<a class="indexterm" id="id16"/>
</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec12"/>How to do it...</h2></div></div></div><p>You will need to set a wildcard on the DNS entry. Without the DNS entries, the domain (and subdomains) will never resolve to your server IP. A sample DNS entry is given below which points the domain<code class="literal"> http://example1.com</code> to the IP<code class="literal"> 69.9.64.11:</code>
<a class="indexterm" id="id17"/>
</p><div class="informalexample"><pre class="programlisting">example1.com. IN A 69.9.64.11
</pre></div><p>Once you know how your DNS works, you can add this to your<code class="literal"> nginx.conf</code> inside the http section:</p><div class="informalexample"><pre class="programlisting">server {
listen 80;
server_name example1.com *.example1.com;
location / {
........
}
}
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec13"/>How it works...</h2></div></div></div><p>The important part to note is that in this case, you are serving all the subdomains using the same code base. We have also set the virtual host to serve the non-www domain as well (example1.com which is different from<a class="ulink" href="http://www.example1.com)"> www.example1.com)</a>.</p><p>So when you type<a class="ulink" href="http://a.example1.com"> a.example1.com</a>, your web application will receive<a class="ulink" href="http://a.example1.com"> a.example1.com</a> as the domain that was requested from the web server and it can process the HTTP response accordingly.</p></div></div>
<div class="section" title="Setting up the number of worker processes correctly"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Setting up the number of worker processes correctly</h1></div></div></div><p>Nginx like any other UNIX-based server software, works by spawning multiple processes and allows the configuration of various parameters around them as well. One of the basic configurations is the number of worker processes spawned! It is by far one of the first things that one has to configure in Nginx.<a class="indexterm" id="id18"/>
</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec14"/>How to do it...</h2></div></div></div><p>This particular configuration can be found at the top of the sample configuration file<code class="literal"> nginx.conf:</code>
<a class="indexterm" id="id19"/>
</p><div class="informalexample"><pre class="programlisting">user www www;
worker_processes 5;
error_log logs/error.log;
pid logs/nginx.pid;
worker_rlimit_nofile 8192;
events {
worker_connections 4096;
}
</pre></div><p>In the preceding configuration, we can see how the various process configurations work. You first set the UNIX user under which the process runs, then you can set the number of worker processes that Nginx needs to spawn, after that we have some file locations where the errors are logged and the PIDs (process IDs) are saved.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec15"/>How it works...</h2></div></div></div><p>By default,<code class="literal"> worker_processes</code> is set at 2. It is a crucial setting in a high performance environment as Nginx uses it for the following reasons:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It uses SMP, which allows you to efficiently use multi-cores or multi-processors systems very efficiently and have a definite performance gain.</li><li class="listitem" style="list-style-type: disc">It increases the number of processes decreases latency as workers get blocked on disk I/O.</li><li class="listitem" style="list-style-type: disc">It limits the number of connections per process when any of the various supported event types are used. A worker process cannot have more connections than specified by the<code class="literal"> worker_connections</code> directive.</li></ul></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec16"/>There's more...</h2></div></div></div><p>It is recommended that you set<code class="literal"> worker_processes</code> as the number of cores available on your server. If you know the values of<code class="literal"> worker_processes</code> and<code class="literal"> worker_connections</code>, one can easily calculate the maximum number of connections that Nginx can handle in the current setup.</p><p>
<span class="emphasis"><em>Maximum clients</em></span> =<code class="literal"> worker_processes</code> *<code class="literal"> worker_connections</code>
</p></div></div>
<div class="section" title="Increasing the size of uploaded files"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Increasing the size of uploaded files</h1></div></div></div><p>Usually when you are running a site where the user uploads a lot of files, you will see that when they upload a file which is more than 1MB in size you get an Nginx error stating, "Request entity too Large" (413), as shown in the following screenshot. We will look at how Nginx can be configured to handle larger uploads.<a class="indexterm" id="id20"/>
</p><div class="mediaobject"><img alt="Increasing the size of uploaded files" height="159" src="graphics/4965_01_05.jpg"/></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec17"/>How to do it...</h2></div></div></div><p>This is controlled by one simple part of the Nginx configuration. You can simply paste this in the server part of the Nginx configuration:</p><div class="informalexample"><pre class="programlisting">client_max_body_size 100M; # M stands for megabytes
</pre></div><p>This preceding configuration will allow you to upload a 100 megabyte file. Anything more than that, and you will receive a 413. You can set this to any value which is less than the available disk space to Nginx, which is primarily because Nginx downloads the file to a temporary location before forwarding it to the backend application.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec18"/>There's more...</h2></div></div></div><p>Nginx also lets us control other factors related to people uploading files on the web application, like timeouts in case the client has a slow connection. A slow client can keep one of your application threads busy and thus potentially slow down your application. This is a problem that is experienced on all the heavy multimedia user-driven sites, where the consumer uploads all kinds of rich data such as images, documents, videos, and so on. So it is sensible to set low timeouts.</p><div class="informalexample"><pre class="programlisting">client_body_timeout 60; # parameter in seconds
client_body_buffer_size 8k;
client_header_timeout 60; # parameter in seconds
client_header_buffer_size 1k;
</pre></div><p>So, here the first two settings help you control the timeout when the body is not received at one read-step (basically, if the server is queried and no response comes back). Similarly, you can set the timeout for the HTTP header as well. The following table lists out the various directives and limits you can set around client uploading.<a class="indexterm" id="id21"/>
</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left" width="2.1625"/><col style="text-align: left" width="3.31401909722222"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Directive</p>
</th><th style="text-align: left" valign="bottom">
<p>Use</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">client_body_in_file_only</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This directive forces Nginx to always store a client request body in temporary disk files, even if the file size is 0.</p>
<p>The file will not be removed at request completion.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">client_body_in_single_buffer</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This directive specifies whether to keep the whole body in a single client request buffer.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">client_body_buffer_size</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This directive specifies the client request body buffer size.</p>
<p>If the request body is more than the buffer, then the entire request body or some part is written in a temporary file.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">client_body_temp_path</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This directive assigns the directory for storing the temporary files in it with the body of the request.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">client_body_timeout</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This directive sets the read timeout for the request body from client.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">client_header_buffer_size</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This directive sets the header buffer size for the request header from client.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">client_header_timeout</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This directive assigns timeout with reading of the title of the request of client.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">client_max_body_size</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This directive assigns the maximum accepted body size of client request, indicated by the line Content-Length in the header of request.</p>
</td></tr></tbody></table></div></div></div>
<div class="section" title="Using dynamic SSI for simple sites"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Using dynamic SSI for simple sites</h1></div></div></div><p>With the advent of modern feature-full web servers, most of them have Server-Side Includes (SSI) built in. Nginx provides easy SSI support which can let you do pretty much all basic web stuff.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec19"/>How to do it...</h2></div></div></div><p>Let's take a simple example and start understanding what one can achieve with it.<a class="indexterm" id="id22"/>
</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"> Add the following code to the<code class="literal"> nginx.conf</code> file:<div class="informalexample"><pre class="programlisting">server {
…..
location / {
ssi on;
root /var/www/www.example1.com;
}
}
</pre></div></li><li class="listitem"> Add the following code to the<code class="literal"> index.html</code> file:<div class="informalexample"><pre class="programlisting">&lt;html&gt;
&lt;body&gt;
&lt;!--# block name="header_default" --&gt;
the header testing
&lt;!--# endblock --&gt;
&lt;!--# include file="header.html" stub="header_default" →
&lt;!--# echo var="name" default="no" --&gt;
&lt;!--# include file="footer.html"--&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre></div></li><li class="listitem"> Add the following code to the<code class="literal"> header.html</code> file:<div class="informalexample"><pre class="programlisting">&lt;h2&gt;Simple header&lt;/h2&gt;
</pre></div></li><li class="listitem"> Add the following code to the<code class="literal"> footer.html</code> file:<div class="informalexample"><pre class="programlisting">&lt;h2&gt;Simple footer&lt;/h2&gt;
</pre></div></li></ol></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec20"/>How it works...</h3></div></div></div><p>This is a simple example where we can see that you can simply include some partials in the larger page, and in addition to that you can create block as well within the page. So the<code class="literal">&lt;block&gt;</code> directive allows you to create silent blocks that can be included later, while the<code class="literal">&lt;include&gt;</code> directive can be used to include HTML partials from other files, or even URL end points. The<code class="literal">&lt;echo&gt;</code> directive is used to output certain variables from within the Nginx context.<a class="indexterm" id="id23"/>
</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec21"/>There's more...</h3></div></div></div><p>You can utilize this feature for all kinds of interesting setups where:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">You are serving different blocks of HTML for different browsers types</li><li class="listitem" style="list-style-type: disc">You want to optimize and speed up certain common blocks of the sites</li><li class="listitem" style="list-style-type: disc">You want to build a simple site with template inheritance without installing any other scripting language</li></ul></div></div></div><div class="section" title="Adding content before and after a particular page"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl1sec15"/>Adding content before and after a particular page</h2></div></div></div><p>Today, in most of the sites that we visit, the webpage structure is formally divided into a set of boxes. Usually, all sites have a static header and a footer block. Here, in this following page you can see the YUI builder generating the basic framework of such a page.<a class="indexterm" id="id24"/>
</p><p>In such a scenario, Nginx has a really useful way of adding content before and after it serves a certain page. This will potentially allow you to separate the various blocks and optimize their performance individually, as well.</p><p>Let's have a look at an example page:</p><div class="mediaobject"><img alt="Adding content before and after a particular page" src="graphics/4965_01_06.jpg" width="308"/></div><p>So here we want to insert the header block before the content, and then append the footer block:<a class="indexterm" id="id25"/>
</p><div class="mediaobject"><img alt="Adding content before and after a particular page" src="graphics/4965_01_07.jpg" width="323"/></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec22"/>How to do it…</h3></div></div></div><p>The sample configuration for this particular page would look like this:</p><div class="informalexample"><pre class="programlisting">server {
listen 80;
server_name www.example1.com;
location / {
add_before_body /red_block
add_after_body /blue_block;
...
}
location /red_block/ {
…
}
location /blue_block/ {
….
}
}
</pre></div><p>This can act as a performance enhancer by allowing you to load CSS based upon the browser only. There can be cases where you want to introduce something into the header or the footer on short notice, without modifying your backend application. This provides an easy fix for those situations.<a class="indexterm" id="id26"/>
</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note02"/>Note</h3><p>This module is not installed by default and it is necessary to enable it when building Nginx.</p></div></div><div class="informalexample"><pre class="programlisting">./configure with-http_addition_module
</pre></div></div></div><div class="section" title="Enabling auto indexing of a directory"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl1sec16"/>Enabling auto indexing of a directory</h2></div></div></div><p>Nginx has an inbuilt auto-indexing module. Any request where the index file is not found will route to this module. This is similar to the directory listing that Apache displays.<a class="indexterm" id="id27"/>
</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec23"/>How to do it...</h3></div></div></div><p>Here is the example of one such Nginx directory listing. It is pretty useful when you want to share some files over your local network. To start auto index on any directory all you need to do is to carry out the following example and place it in the server section of the Nginx configuration file:<a class="indexterm" id="id28"/>
</p><div class="informalexample"><pre class="programlisting">server {
location 80;
server_name www.example1.com;
location / {
root /var/www/test;
autoindex on;
}
}
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec24"/>How it works...</h3></div></div></div><p>This will simply enable auto indexing when the user types in<code class="literal"> http://www.example1.com</code>. You can also control some other things in the listings in this way:<a class="indexterm" id="id29"/>
</p><div class="informalexample"><pre class="programlisting">autoindex_exact_size off;
</pre></div><p>This will turn off the exact file size listing and will only show the estimated sizes. This can be useful when you are worried about file privacy issues.</p><div class="informalexample"><pre class="programlisting">autoindex_localtime on;
</pre></div><p>This will represent the timestamps on the files as your local server time (it is GMT by default):</p><div class="mediaobject"><img alt="How it works..." height="178" src="graphics/4965_01_08.jpg"/></div><p>This image displays a sample index auto-generated by Nginx using the preceding configuration. You can see the filenames, timestamp, and the file sizes as the three data columns.<a class="indexterm" id="id30"/>
</p></div></div><div class="section" title="Serving any random web page from a directory"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl1sec18"/>Serving any random web page from a directory</h2></div></div></div><p>There has been a recent trend for a lot of sites to test out their new pages based upon the A/B methodology. You can explore more about its history and the various companies that have adopted this successfully as a part of their development process at<a class="ulink" href="http://en.wikipedia.org/wiki/A/B_testing"> http://en.wikipedia.org/wiki/A/B_testing</a>. In this practice, you have a set of pages and some metric (such as number of registrations, or the number of clicks on a particular element). Then you go about getting people to randomly visit these pages and get data about their behavior on them. This lets you iteratively improve the page and the elements on them.<a class="indexterm" id="id31"/>
</p><div class="mediaobject"><img alt="Serving any random web page from a directory" src="graphics/4965OS_01_09.jpg" width="184"/></div><p>Nginx has something that will let you to run your own A-B test without writing any code at all. It allows you to randomly select any web page from a directory and display it.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec25"/>How to do it...</h3></div></div></div><p>Let's have a look at a sample configuration which needs to be placed within the HTTP section of the Nginx configuration:<a class="indexterm" id="id32"/>
</p><div class="informalexample"><pre class="programlisting">server {
listen 80;
server_name www.example1.com;
location / {
root /var/www/www.example1.com/test_index;
random_index on;
}
}
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec26"/>How it works...</h3></div></div></div><p>Let's assume that you have some files in the<code class="literal"> /var/www/www.example1.com/test_index</code> directory. When you turn on the random index it will scan the directory and then send a randomly picked file instead of the default<code class="literal"> index.html</code>. The only exceptions are plain files. Whole filenames which start with a dot will not be part of the site of files to be picked from.</p><p>So here are two sample test pages, with slightly differing headers. Notice that the URLs are the same. So it will let you determine if the end user is clicking through more with the red link or the blue link using pure statistical methods:</p><div class="mediaobject"><img alt="How it works..." height="120" src="graphics/4965_01_10.jpg"/></div><p>The preceding screenshot displays<code class="literal"> A.html</code> on opening the site. There is equal probability of opening both the pages, much like the tossing of a coin and getting heads or tails.<a class="indexterm" id="id33"/>
</p><div class="mediaobject"><img alt="How it works..." height="117" src="graphics/4965_01_11.jpg"/></div><p>So, using the A-B testing as an example, you can set an<code class="literal"> A.html</code> and a<code class="literal"> B.html</code>, which would be served to the user randomly. It would allow you to easily measure a lot of interesting client behavior by simply analyzing the Nginx access logs.</p></div></div><div class="section" title="Serving cookies for identifying and logging users"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl1sec20"/>Serving cookies for identifying and logging users</h2></div></div></div><p>Nginx has a useful functionality of serving cookies for identifying users. This is very useful in tracking anonymous user behavior in case a website does not want to employ external analytics software. This module is compatible with the<code class="literal"> mod_uid</code> module in Apache2, which provides a similar functionality.<a class="indexterm" id="id34"/>
</p><div class="section" title="How to do it…"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec27"/>How to do it…</h3></div></div></div><p>Here is a sample configuration for this module. This goes in the server section of the configuration:</p><div class="informalexample"><pre class="programlisting">userid on;
userid_name uid;
userid_domain example1.com;
userid_path /;
userid_expires 365d;
userid_p3p 'policyref="/w3c/p3p.xml", CP="CUR ADM OUR NOR STA NID"';
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec28"/>How it works...</h3></div></div></div><p>Now let's see and understand what the various directives are about. The first<code class="literal"> userid</code> directive enables this module; the second assigns a name to the cookie which is going to be written on the client side. The next three directives are the standard cookie information that is needed (the primary domain, the path, and the time of expiry). The last directive enables the browser to understand the privacy practices that the website follows. This is done by using the P3P protocol which allows websites to declare their intended usage that they collect about the user. It is basically an XML file that allows you to programmatically display your privacy policy. The following code is a simple example configuration of how you can define a policy where the data is removed after 4 months:</p><div class="informalexample"><pre class="programlisting">&lt;META &gt;
&lt;POLICY-REFERENCES&gt;
&lt;EXPIRY max-age="10000000"/&gt;&lt;!-- about four months --&gt;
&lt;/POLICY-REFERENCES&gt;
&lt;/META&gt;
</pre></div><p>This XML put on the server will objectively define the privacy policies of the site to the incoming bots or users.<a class="indexterm" id="id35"/>
</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec29"/>There's more...</h3></div></div></div><p>On enabling this module, some variables are available in the Nginx configuration which allow you do fairly interesting things. You have access to some variables in the configuration contest, like<code class="literal"> $uid_got,$uid_set</code>.</p><p>These can be used for writing interesting rewrite rules. A simple application using these variables is to log the users coming on your site and then determining the user bounce rates on your website by parsing the logs.</p></div></div><div class="section" title="Re-encoding the response to another encoding"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl1sec22"/>Re-encoding the response to another encoding</h2></div></div></div><p>File encoding is a major issue on most websites, a lot of time the database (MySQL in most cases) is configured to run using the Latin-1 encoding instead of the UTF-8 encoding that is the prevalent standard. Nginx provides an easy solution for changing your web page encoding on-the-fly, so that your users do not end up with garbled characters on your website<a class="indexterm" id="id36"/>
</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec30"/>How to do it...</h3></div></div></div><p>All you need to do is to place this in the server section of your Nginx configuration:</p><div class="informalexample"><pre class="programlisting">charset windows-1251;
source_charset koi8-r;
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec31"/>How it works...</h3></div></div></div><p>This basically defines the fact that the source character set is<code class="literal"> koi8-r</code>. If the encoding is different from the charset character set, then re-encoding is carried out. In case your original response already has a "Content-Type" header present then you will need to use the following to override and do the re-encoding:</p><div class="informalexample"><pre class="programlisting">overrride_charset on;
</pre></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec32"/>There's more...</h3></div></div></div><p>You can also decide how the re-encoding happens by defining a character mapping. A simple example is the following:</p><div class="informalexample"><pre class="programlisting">charset_map koi8-r windows-1251 {
C0 FE ; # small yu
C1 E0 ; # small a
C2 E1 ; # small b
C3 F6 ; # small ts
# ...
}
</pre></div><p>Nginx lets you do these neat little things that can make your site more accessible and usable for the end-user.</p></div></div><div class="section" title="Enabling Gzip compression on some content types"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl1sec24"/>Enabling Gzip compression on some content types</h2></div></div></div><p>As the Web has evolved, we have had improvements in web server and browser technologies. In recent times, with the booming consumer Internet market, the web application has had to become faster.</p><p>Compression techniques, which were already present, have come of age and now most sites enable a fairly high degree of compression on the pages they serve. Nginx being state of the art, has Gzip compression and allows a whole lot of options on how to go about it.<a class="indexterm" id="id37"/>
</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec33"/>How to do it...</h3></div></div></div><p>You will need to modify your Nginx configuration file and add the following directives:</p><div class="informalexample"><pre class="programlisting">http {
gzip on;
gzip_min_length 1000;
gzip_comp_level 6;
gzip_proxied expired no-cache no-store private auth;
gzip_types text/plain application/xml;
gzip_disable "MSIE [1-6]\.";
server {
….
}
}
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec34"/>How it works...</h3></div></div></div><p>This sample configuration allows you to turn on the Gzip compression of the outgoing page for all pages which are over 1000 bytes. This limit is set because compression technology performance degrades as the page size becomes smaller. You can then set the various MIME types for which the compression should occur; this particular example will compress only plain text files and XML files.<a class="indexterm" id="id38"/>
</p><p>Older browsers are not the best when it comes to utilizing this, and you can disable Gzip depending on the browser type. One of the most interesting settings is the level of compression where you need to make a choice between the amount of CPU that you want to spend on compressing and serving the pages (the<span class="emphasis"><em> higher this number, more of your CPU time will go towards compressing and sending pages)</em></span>. It is recommended to follow a middle path on this particular setting; the client also spends more CPU time decompressing the page if you set this. A sensible setting of this value would be six.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec35"/>There's more...</h3></div></div></div><p>For proxy requests,<code class="literal"> gzip_proxied</code> actually allows or disallows the compression of the response of the proxy request based on the request and the response. You can use the following parameters:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left" width="1.3878125"/><col style="text-align: left" width="4.06950520833333"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>parameter</p>
</th><th style="text-align: left" valign="bottom">
<p>Function</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">off</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Disables compression for all proxy requests</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">expired</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Enables compression, if the<code class="literal"> Expires</code> header prevents caching</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">no-cache</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Enables compression if<code class="literal"> Cache-Control</code> header contains<code class="literal"> no-cache</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">no-store</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Enables compression if<code class="literal"> Cache-Control</code> header contains<code class="literal"> no-store</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">private</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Enables compression if<code class="literal"> Cache-Control</code> header contains<code class="literal"> private</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">no_last_modified</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Enables compression if<code class="literal"> Last-Modified</code> isn't set</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">no_etag</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Enables compression if there is no<code class="literal"> ETag</code> header</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">auth</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Enables compression if there is an<code class="literal"> Authorization</code> header</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">any</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Enables compression for all requests</p>
</td></tr></tbody></table></div><p>So in the preceding example (expired<code class="literal"> no-cache no-store private auth)</code> it is clear that the compression is enabled when the<code class="literal"> Expires</code> header prevents caching, when the<code class="literal"> Cache-Control</code> contains<code class="literal"> no-cache, no-store</code>, or<code class="literal"> private</code>, and when there is an<code class="literal"> Authorization</code> header present. This allows tremendous control on how the compression is delivered to the client's browser.</p></div></div><div class="section" title="Setting up 404 and other error pages"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl1sec25"/>Setting up 404 and other error pages</h2></div></div></div><p>All web applications have errors and missing pages, and Nginx has easy methods of ensuring that the end user has a good experience when the application does not respond correctly. It successfully handles all the HTTP errors with default pages, which can gracefully notify the users that something has gone wrong.<a class="indexterm" id="id39"/>
</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec36"/>How to do it...</h3></div></div></div><p>Nginx allows you to do pretty interesting things with error pages. Following are some example configurations which can be placed within the HTTP or server section.</p><p>We are also going to define a named location using the "@" prefix after location. These locations are not used during the normal processing of any request and are intended to only process internally redirected requests.</p><div class="informalexample"><pre class="programlisting">location @fallback (
proxy_pass http://backend;
)
error_page 404 /404.html;
error_page 502 503 504 /50x.html;
error_page 403 http://example1.com/forbidden.html;
error_page 404 = @fallback;
error_page 404 =200 /.empty.gif;
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl2sec37"/>How it works...</h3></div></div></div><p>The first example allows you to map a simple 404 page to a simple HTML. The next example allows the mapping of various application error codes to another generic application error HTML page. You can also map the error page to some other external site all together (<code class="literal">http://example1.com/forbidden.html</code>). The fourth example allows you to map the page to another location, defined as<code class="literal"> @fallback</code>. The last example is interesting as it actually allows you to change the response code to a 200 (HTTP OK). This is useful in situations where you have excessive 404 pages on the site, and would prefer not sending a 404 back as reply, but a 200 with a very small GIF file in return.<a class="indexterm" id="id40"/>
</p><p>You can utilize this very effectively to give the end user a better experience when they inadvertently reach dead ends and application errors on your site.</p><p>If you do not set these error pages correctly, you will get the default Nginx error pages which may not be useful to the user and may turn them away.</p><div class="mediaobject"><img alt="How it works..." height="126" src="graphics/4965_01_12.jpg"/></div></div></div></div></body></html>