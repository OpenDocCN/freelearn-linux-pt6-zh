- en: Chapter 5. Troubleshooting Rare Specific Problems
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章 排查罕见的特定问题
- en: The most interesting problems you may encounter with Nginx or any other piece
    of complex software (or any other human endeavor, for that matter) are usually
    firmly situated in the category of "Misc". This dreaded class of troubles contains
    everything that does not fall into other convenient classes that you as a reader
    and a professional spent time and efforts in previous chapters. Nginx is known
    for its stability and robustness, so you might never get a chance to encounter
    anything we describe here in your professional career. Still, in the spirit of
    "better safe than sorry", we would highly recommend reading the chapter just in
    case.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能遇到的与 Nginx 或任何其他复杂软件（或任何其他人类事业）相关的最有趣的问题，通常都属于“杂项”类别。这个让人头痛的问题类别包括了所有不属于你作为读者和专业人士在前几章花费时间和精力探讨的其他方便类别的内容。Nginx
    以其稳定性和可靠性而闻名，因此你在职业生涯中可能永远不会遇到我们在这里描述的任何问题。不过，本着“未雨绸缪”的精神，我们强烈建议你阅读本章，以防万一。
- en: 'In this chapter, you will learn about the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍以下主题：
- en: Different security warnings that users may encounter on your websites and how
    to fix them
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户在你的网站上可能遇到的不同安全警告以及如何修复它们
- en: A couple of reasons why users may see very obsolete versions of web pages that
    were updated and how to fix such cases
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可能看到已更新的网页非常过时的几个原因，以及如何解决这种情况
- en: Several curious configuration problems that will help you better understand
    the inner workings of Nginx and how to solve them
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些有趣的配置问题，它们将帮助你更好地理解 Nginx 的内部工作原理以及如何解决它们
- en: Anyway, let us start from what we consider more frequent and easier to fix and
    then move to less obvious and much more obscure issues.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 不管怎样，让我们从那些我们认为更常见、更容易修复的问题开始，然后再讨论那些不那么明显、更为复杂的问题。
- en: Security warnings
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全警告
- en: It is a fact that the web is moving to HTTPS. Even 3 – 4 years ago, plain text
    HTTP was a perfectly normal choice unless you build a bank interface. Today, in
    the age of global personalization and sophisticated attackers, websites are slowly
    embracing total encryption. There are a number of reasons for that, and deep discussion
    is out of the scope of this book. Instead, you are kindly referred to this document
    [https://www.eff.org/encrypt-the-web-report](https://www.eff.org/encrypt-the-web-report).
    Basically, in the next 2-3 years, HTTP will become de facto deprecated as an end
    user protocol and that brings us to a world of problems dealing with the public
    key infrastructure of HTTPS. HTTPS relies on TLS, which uses X.509 PKI with CAs,
    CRLs, OSCP, and so on. The abundance of abbreviations in the previous sentence
    is deliberate; this is a complex topic in itself, which regularly confuses the
    most experienced specialists. The design of the X.509 key and certificate infrastructure
    is known to be very complex, but the task it solves is not a simple one either.
    One of the most interesting recent initiatives to simplify the solution is the
    project **Let's Encrypt**, which is available at [https://letsencrypt.org](https://letsencrypt.org).
    They advertise as the free certificate vendor (certification authority, or CA
    in X.509 lingo), but they also provide a set of protocols, services, and tools
    which allow painless and transparent certificate management. They are not yet
    fully operational as of March 2016, so watch that space.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 网络正在转向 HTTPS 这一事实是不争的事实。即使是在三到四年前，纯文本的 HTTP 也是一个完全正常的选择，除非你在构建银行接口。如今，在全球个性化和复杂攻击者的时代，网站正在慢慢采用完全加密。这样做有很多原因，深入讨论超出了本书的范围。你可以参考这篇文档
    [https://www.eff.org/encrypt-the-web-report](https://www.eff.org/encrypt-the-web-report)。基本上，在未来
    2-3 年里，HTTP 将成为事实上的废弃协议，而这将把我们带入一个充满 HTTPS 公钥基础设施问题的世界。HTTPS 依赖于 TLS，TLS 使用 X.509
    PKI，涉及 CA、CRL、OSCP 等等。前一句话中的缩写故意较多；这是一个复杂的主题，常常让经验最丰富的专家也感到困惑。X.509 密钥和证书基础设施的设计已知非常复杂，但它解决的任务也并不简单。一个最近有趣的简化解决方案的倡议是
    **Let's Encrypt** 项目，网址为 [https://letsencrypt.org](https://letsencrypt.org)。他们宣称是免费的证书提供商（在
    X.509 术语中是认证机构，或 CA），但他们还提供一套协议、服务和工具，允许无痛且透明的证书管理。截至 2016 年 3 月，他们还没有完全投入运营，因此请关注这个领域的动态。
- en: Setting up HTTPS on Nginx is a topic thoroughly described in many articles and
    books around the web, so we won't spend much time on it. You have probably done
    it several times.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Nginx 上设置 HTTPS 是一个在许多文章和书籍中都有详细描述的主题，因此我们不会花太多时间讨论这个话题。你可能已经做过好几次了。
- en: There are some cases in which your visitors may encounter HTTPS-related security
    warnings when requesting pages from your website.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，当访问者请求你网站的页面时，他们可能会遇到与HTTPS相关的安全警告。
- en: 'Let''s say that you have something like this in your website configuration:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在你的网站配置中有如下内容：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When the X.509 infrastructure was invented in the end of 1980s, one of the tasks
    it tried to solve was the issue of mutual authentication and trust between parties
    in a secure communication channel. While encryption does not strictly require
    this kind of authentication, it is still considered important that your browser
    trusts the server on the other side of an encrypted HTTPS connection at least
    in the sense of that server presenting some undeniable proof that it is what it
    claims to be. The implementation of that proof are the digital certificates that
    servers present while negotiating the connection, and a number of policies on
    a client. Amusingly, if you are familiar with other PKI schemes, for example,
    PGP/GPG, then you probably asked yourself why X.509 requires a separate entity
    in addition to the obvious key pair (public and private), which is actually required
    to implement asymmetrical cryptography. Well, the idea is that the certificate
    is a document from a third party about the server, whereas the keys are technical
    data used during encryption. The loose PGP analog of the certificate are the signatures
    from other people your keys may or may not have.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当X.509基础设施在1980年代末期被发明时，它试图解决的任务之一是确保在安全通信通道中各方之间的相互认证和信任问题。虽然加密并不严格要求这种认证，但仍然认为重要的是你的浏览器能够信任加密的HTTPS连接另一端的服务器，至少从服务器提供某种不可否认的证明它是所声称的那样。这个证明的实现形式就是服务器在协商连接时展示的数字证书，以及客户端上的一些政策。有趣的是，如果你熟悉其他公钥基础设施（PKI）方案，例如PGP/GPG，那么你可能会问，为什么X.509在必要的公私钥对（其实是实施非对称加密所必需的）之外，还需要一个额外的实体。其实，证书的作用就是作为第三方对服务器的证明，而密钥则是加密过程中使用的技术数据。类似于PGP的松散类比，证书就像是其他人签署的、你可能有也可能没有的密钥签名。
- en: Domain name mismatch
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 域名不匹配
- en: The most common certificates HTTPS server use are of **Domain Validation** (**DV**)
    type, and the most important policy that a client will enforce against a connection
    to a server with a DV certificate is that the domain name mentioned inside the
    certificate matches the domain name of the actual TCP connection endpoint.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: HTTPS服务器最常用的证书是**域名验证**（**DV**）类型，而客户端对连接到具有DV证书的服务器施行的最重要政策是证书中提到的域名必须与实际TCP连接端点的域名相匹配。
- en: 'A problem with this policy manifests itself with these nasty scary full-screen
    errors:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个政策的问题表现为这些可怕的全屏错误：
- en: '![Domain name mismatch](img/B04329_05_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![域名不匹配](img/B04329_05_01.jpg)'
- en: 'The earlier-mentioned image is from Chromium, the open browser that is the
    base for Google Chrome. The next example is from Firefox:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 前面提到的图像来自Chromium，它是Google Chrome的基础开源浏览器。下一个示例来自Firefox：
- en: '![Domain name mismatch](img/B04329_05_02.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![域名不匹配](img/B04329_05_02.jpg)'
- en: 'The next example is from mobile Safari on iOS:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例来自iOS上的移动版Safari：
- en: '![Domain name mismatch](img/B04329_05_03.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![域名不匹配](img/B04329_05_03.jpg)'
- en: The root of this problem lies in the historic convention of having one and only
    one fully qualified domain name per certificate. If you have aliases (and most
    websites usually do have at least the common pair—one with "www." and one without
    "www."), you either have to purchase separate certificates or use extensions to
    the original X.509\. Fortunately, those extensions are pretty widely supported;
    the last problems we remember were with default Windows Phone 7 browsers, and
    if you have significant number of such clients, you probably know what to do and
    have resources to solve that problem with a dedicated project.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的根源在于历史上的约定，即每个证书只能有一个完全限定的域名。如果你有别名（大多数网站通常至少有一对常见的—一个带“www.”，一个不带“www.”），你要么需要购买单独的证书，要么使用原始X.509的扩展。幸运的是，这些扩展得到了广泛支持；我们记得的最后问题出现在默认的Windows
    Phone 7浏览器上，如果你有大量这类客户端，你可能知道该怎么做，并且有资源通过专门的项目解决这个问题。
- en: 'The extensions you need are: wildcard certificates and multidomain certificates
    or SAN certificates. Your HTTPS certificates vendor will have those in store.
    They are usually a bit more expensive but too useful to ignore. Wildcard certificates
    allow you to request certificates for domain patterns that look like `*.example.com`,
    whereas **Subject Alternative Names** (**SANs**) are a way to enumerate the list
    of domains that this certificate is valid for.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要的扩展功能是：通配符证书和多域证书或 SAN 证书。你的 HTTPS 证书供应商会提供这些证书。它们通常会稍微贵一些，但太有用，值得投资。通配符证书允许你为类似
    `*.example.com` 的域名模式申请证书，而**主题备用名称**（**SANs**）是一种列举该证书有效的域名列表的方式。
- en: Expired certificates
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过期证书
- en: 'The next most common error message that you may encounter is as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能遇到的下一个最常见的错误消息如下：
- en: '![Expired certificates](img/B04329_05_04.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![过期证书](img/B04329_05_04.jpg)'
- en: 'Now we will show Chromium and Microsoft Internet Explorer errors as examples:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将以 Chromium 和 Microsoft Internet Explorer 为例展示错误：
- en: '![Expired certificates](img/B04329_05_05.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![过期证书](img/B04329_05_05.jpg)'
- en: iOS and Mobile Safari chose the strategy to show one type of HTTPS error message
    for both of the most common errors.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: iOS 和 Mobile Safari 选择了一种策略，对这两种最常见的错误消息显示相同的 HTTPS 错误信息。
- en: The philosophy behind digital certificate expiration is rather simple. Because
    a certificate is an electronic document asserting someone's identity as verified
    by a third party (that is your certificates vendor or **Certificate Authority**
    (**CA**) in X.509 speak) in the absence of said third party, it should have expiration
    date to ensure regular re-evaluations of that identity. Vendors will go out of
    their way to remind you about your certificates, but in spite of this, expirations
    happen a little too often in the wild.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 数字证书过期的哲学其实很简单。因为证书是一个由第三方（即你的证书供应商或**证书颁发机构**（**CA**），在 X.509 术语中）验证的电子文档，证明某个人的身份，在没有第三方的情况下，它应该有一个过期日期，以确保对该身份进行定期重新评估。供应商会尽力提醒你证书的过期情况，但尽管如此，过期事件在实际操作中仍然发生得有些频繁。
- en: This is a very embarrassing moment for any system administrator responsible
    for a web server. Almost as embarrassing as forgetting to renew the domain delegation
    (this also happens a lot). Most of the monitoring solutions, both standalone and
    hosted, will have a sensor for that. We even found a specific monitoring tool
    just for certificate expiration at [https://snitch.io/](https://snitch.io/) although
    we have not had the chance to use it. One of the most robust tools to ensure that
    your TLS certificates are renewed on time is, surprisingly, Google Calendar. Acquire
    the habit of always creating an event with a reminder 4 weeks before the expiration
    date right after you receive each new certificate file. This will save you, we
    promise.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何负责 Web 服务器的系统管理员来说，这是一个非常尴尬的时刻。几乎和忘记续订域名委托一样尴尬（这种情况也经常发生）。大多数监控解决方案，无论是独立的还是托管的，都有一个用于监控证书过期的传感器。我们甚至找到了一个专门用于证书过期监控的工具，[https://snitch.io/](https://snitch.io/)，尽管我们还没有机会使用它。确保及时续订TLS证书的最可靠工具之一，令人惊讶的是，居然是
    Google 日历。在每次收到新的证书文件后，养成一个习惯，即在过期日期前四周创建一个事件并设置提醒。这将为你节省很多麻烦，我们保证。
- en: You may ask how a problematic certificate could end up in production. Well,
    most of the time, production certificates are not used on development and test
    deployments because of the old convention mentioned earlier—having one domain
    name per certificate. Because this limit is long obsolete, you may include your
    test hostnames inside certificates and that will remove one additional difference
    between your production and test (or stage, depending on your release life cycle)
    environments.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，为什么有问题的证书会出现在生产环境中。嗯，大多数时候，生产环境中的证书并不会在开发和测试环境中使用，这与之前提到的老传统有关——每个证书只对应一个域名。因为这个限制已经过时，你可以将测试主机名包含在证书中，这样可以消除生产环境和测试环境（或阶段环境，取决于你的发布生命周期）之间的另一个差异。
- en: Insecure warnings for valid certificates
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有效证书的安全警告
- en: There are hundreds of different Certificate Authorities (CAs) now; some of them
    worked for many years and some are just starting. If you had time to get familiar
    with X.509 PKI, you will know that clients should have the root certificate for
    each and every issuer (that is, CA) in their trusted storage. Otherwise, all the
    server certificates issued by that particular CA will be invalid. In an ideal
    world, all user computers and mobile devices have a very up-to-date list of trusted
    root certificates. Unfortunately, an ideal world does not exist, and you may face
    a real problem when some of the more conservative clients' browsers consider your
    web servers insecure because they do not yet have the relevant CA root certificate
    in their trusted storage.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有数百种不同的证书颁发机构（CA）；其中一些已经存在多年，而另一些则是新成立的。如果您有时间熟悉 X.509 PKI，您会知道客户端应该拥有每个颁发机构（即
    CA）的根证书，且这些证书应存储在其受信存储中。否则，所有该 CA 颁发的服务器证书都将无效。在理想的世界里，所有用户的计算机和移动设备都会拥有一个非常更新的受信根证书列表。不幸的是，理想世界并不存在，您可能会面临实际问题——一些较保守的客户端浏览器可能会因为没有相关的
    CA 根证书而认为您的 Web 服务器不安全。
- en: To work around such problems, your CA may provide you with their own certificate
    that you should concatenate with your own and present to the clients as a certificate
    set (or chain). This will work because X.509 supports a certificate chain to verify
    the endpoint certificate. Your certificate will refer to the CA certificate, which
    if provided will refer the client further down the chain until one of the referred
    intermediate CA certificates is found in the trusted root certificate storage
    of the client.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些问题，您的 CA 可能会提供自己的证书，您应该将其与自己的证书连接起来并将其作为证书集（或链）提供给客户端。这样做是有效的，因为 X.509
    支持证书链来验证端点证书。您的证书将引用 CA 证书，如果提供的话，CA 证书将进一步引用客户端信任的根证书存储中的某个中间 CA 证书。
- en: 'The easiest way to do this is with a simple `cat` command:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是使用一个简单的 `cat` 命令：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Then, specify the path to this compound file in your `ssl_certificate` directive.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在您的 `ssl_certificate` 指令中指定此复合文件的路径。
- en: The mixed – content warning
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 混合内容警告
- en: Although the two types of HTTPS problems we demonstrated earlier are true errors
    and web browsers will actively prevent users from working around them, there are
    some less critical problems that still may compromise the trust of your clients.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们之前展示的两种 HTTPS 问题是实际的错误，且 Web 浏览器会主动阻止用户绕过它们，但仍然有一些不太严重的问题可能会损害客户端的信任。
- en: One of the most massive and, at the same time, elusive warnings is the so-called
    "Mixed content" warning. The idea is that any HTTPS page should never embed HTTP
    objects because the overall security level of the page is the level of its least
    secure component. If you have even one image object that was fetched via plaintext
    HTTP, then it may compromise the whole page and even the whole application at
    times. All modern browsers give warnings about this situation although the actual
    interface implementation may vary.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见且同时也是最难以捉摸的警告之一是所谓的“混合内容”警告。其理念是，任何 HTTPS 页面都不应该嵌入 HTTP 对象，因为页面的整体安全级别取决于其最不安全的组件。如果您有一个通过明文
    HTTP 获取的图片对象，它可能会危及整个页面，甚至有时危及整个应用程序。所有现代浏览器都会对这种情况发出警告，尽管实际的界面实现可能有所不同。
- en: 'These are some examples. The first one is from a desktop version of Firefox:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是一些示例。第一个来自 Firefox 的桌面版本：
- en: '![The mixed – content warning](img/B04329_05_06.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![混合内容警告](img/B04329_05_06.jpg)'
- en: 'The second example is from a desktop version of Chromium:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个示例来自 Chromium 的桌面版本：
- en: '![The mixed – content warning](img/B04329_05_07.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![混合内容警告](img/B04329_05_07.jpg)'
- en: Also, modern browsers make a distinction between active and passive content,
    the former including scripts, active objects, such as Flash, style sheets, and
    whole external documents as IFrames. Active mixed content is usually blocked outright,
    whereas passive mixed content only issues warnings. There is a recommendation
    from W3C about "Mixed content" that contains all the best practices and recommendations
    about handling the issue. You may well use it as a guide about what to expect.
    Refer to [http://www.w3.org/TR/mixed-content/](http://www.w3.org/TR/mixed-content/).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，现代浏览器区分了主动内容和被动内容，前者包括脚本、活动对象（如Flash）、样式表和整个外部文档（如IFrames）。主动混合内容通常会被直接阻止，而被动混合内容则只会发出警告。W3C关于“混合内容”有一个建议，其中包含了处理该问题的所有最佳实践和建议。你可以将其作为你对预期情况的指南。请参阅[http://www.w3.org/TR/mixed-content/](http://www.w3.org/TR/mixed-content/)。
- en: 'Linking insecurely to your own content is an obvious error on the side of the
    developers. They should never ever use direct absolute links with the `http:`
    scheme anymore. Fixing this may be quite easy using a couple of global full-text
    searches through all the documents and templates. Just ensure that all your secondary
    hosts are reachable via HTTPS and change `http://` in links to either `https://`
    or just `//` if you feel like saving a few bytes per link by using a clever trick
    of schemeless (or schemaless) URLs. A URL without a scheme looks like the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 将不安全的链接指向你自己的内容是开发人员显而易见的错误。他们应该永远不再使用带有`http:`协议的直接绝对链接。通过对所有文档和模板进行几次全局全文搜索，修复这个问题可能非常简单。只需确保所有的二级主机都可以通过HTTPS访问，并将链接中的`http://`更改为`https://`，或者如果你想通过使用巧妙的无协议URL（schemeless）技巧节省每个链接的一些字节，也可以使用`//`。没有协议的URL如下所示：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The idea exploits a rarely used but required by all standards feature of relative
    URL resolution. This is also the reason for the second name: protocol-relative.
    URLs with two slashes will inherit the scheme from the base document. Refer to
    RFC3986 [http://tools.ietf.org/html/rfc3986#section-4.2](http://tools.ietf.org/html/rfc3986#section-4.2)
    for more information.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法利用了相对URL解析的一个很少使用但所有标准都要求的特性。这也是第二个名称“协议相对”的原因：带有两个斜杠的URL会继承基础文档的协议。有关更多信息，请参考RFC3986
    [http://tools.ietf.org/html/rfc3986#section-4.2](http://tools.ietf.org/html/rfc3986#section-4.2)。
- en: Note
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It will be more secure and practical in the long run to just ensure HTTPS availability
    and always use `https://` instead of `//`. It is completely safe and does not
    decrease (already absent) security of your documents retrieved via insecure HTTP.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 从长远来看，确保HTTPS可用并始终使用`https://`而不是`//`会更安全和实用。这是完全安全的，不会降低（本来就没有的）通过不安全的HTTP获取的文档的安全性。
- en: 'As a workaround solution (that may become semi-permanent), you may use the
    power of Nginx to help your developers change all links to internal resources
    using on-the-fly substitution. Nginx source contains a special module named `ngx_http_sub_module`,
    which is not usually built by default although it depends on the author of the
    Nginx package in your distribution. To check whether it is available, run this
    command:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种解决方法（可能变成半永久性），你可以利用Nginx的功能帮助你的开发人员通过即时替换修改所有指向内部资源的链接。Nginx源代码中包含一个名为`ngx_http_sub_module`的特殊模块，通常并不默认构建，尽管它依赖于你所在发行版中的Nginx包的作者。要检查它是否可用，请运行以下命令：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you see `1`, then your Nginx is linked with `sub_module`. Otherwise, you
    need to compile it using `--with-http_sub_module` parameter to `configure`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到`1`，说明你的Nginx已与`sub_module`连接。否则，你需要使用`--with-http_sub_module`参数编译它。
- en: 'This is the example that you will need to modify for your own situation:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你需要根据自己的情况修改的示例：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The second line with `sub_filter_types` directive is only needed if your CSS
    files contain absolute URLs of images. It is as dirty a hack as many `sub_module`
    applications are, but it may solve at least some of the immediate problems you
    have. Remember to include all your assets hosts.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当你的CSS文件包含图像的绝对URL时，才需要使用带有`sub_filter_types`指令的第二行。这就像许多`sub_module`应用程序一样，是一种不太优雅的解决方法，但它至少可能解决你面临的一些立即问题。记得包括所有的资产主机。
- en: There are two main sources of insecure external content your website may contain.
    The first includes external trackers, advertisement networks, commenting systems,
    and the like. In 2016, all of these have the support for HTTPS websites. The only
    reason they may the mixed content warnings is incorrect embedding code (for example,
    very old).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您的网站可能包含两种主要来源的不安全外部内容。第一种包括外部追踪器、广告网络、评论系统等。在 2016 年，这些都已支持 HTTPS 网站。它们可能出现混合内容警告的唯一原因是嵌入代码不正确（例如，使用非常旧的代码）。
- en: The other source of insecure objects is **User-generated Content** (**UGC**).
    If your website has a way for users to post some data that may be displayed in
    the context of your pages afterwards, then you might have this problem. Examples
    include commenting systems, blogs, forums, messaging, and so on. This is not as
    rare as it might seem at first thought.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种不安全对象的来源是 **用户生成内容**（**UGC**）。如果您的网站允许用户发布一些数据，这些数据可能会在您的页面中显示出来，那么您可能会遇到这个问题。例子包括评论系统、博客、论坛、消息等。这种情况比看起来的要常见得多。
- en: One way to find the culprits of the mixed content violation is using the browser
    console. Recent browsers display warnings about which objects are insecure. There
    are also tools for crawling websites and identifying insecure embeds, but these
    may not be relied upon, especially if you have a complex website that may not
    be easily crawled. Refer to, for example, [https://www.whynopadlock.com/](https://www.whynopadlock.com/)
    or [https://www.jitbit.com/sslcheck/](https://www.jitbit.com/sslcheck/).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 查找混合内容违规的罪魁祸首的一种方法是使用浏览器控制台。近期的浏览器会显示哪些对象是不安全的。也有一些工具可以爬取网站并识别不安全的嵌入内容，但这些工具可能不可靠，尤其是当你的网站较为复杂，且不容易被爬取时。例如，可以参考
    [https://www.whynopadlock.com/](https://www.whynopadlock.com/) 或 [https://www.jitbit.com/sslcheck/](https://www.jitbit.com/sslcheck/)。
- en: '![The mixed – content warning](img/B04329_05_08.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![混合内容警告](img/B04329_05_08.jpg)'
- en: Mozilla provides a good page on Mixed Content too. You are very welcome to consult
    it at [https://developer.mozilla.org/en-US/docs/Security/MixedContent](https://developer.mozilla.org/en-US/docs/Security/MixedContent).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Mozilla 也提供了关于混合内容的一个很好的页面，欢迎参考：[https://developer.mozilla.org/en-US/docs/Security/MixedContent](https://developer.mozilla.org/en-US/docs/Security/MixedContent)。
- en: While fixing the embedding code of external components is rather straightforward,
    dealing with UGC content is much harder. Suppose that you have a way for your
    users to specify their image avatars by entering URLs pointing to those images.
    You cannot just change the URL from `http:` to `https:` because this may just
    break the link. You cannot be sure that all those far-away hosts support and will
    always support HTTPS. The only way to provide such a service for your own users
    is to serve all that remote content yourself by proxying it.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然修复外部组件的嵌入代码相对简单，但处理用户生成内容（UGC）要困难得多。假设你提供了一种方式，让用户通过输入指向图片的 URL 来指定他们的头像。你不能仅仅将
    URL 从 `http:` 改为 `https:`，因为这样可能会破坏链接。你无法确保所有远程主机都支持并将永远支持 HTTPS。为用户提供此类服务的唯一方法是通过代理自己提供所有远程内容。
- en: This is an important hack that involves some of the less popular Nginx magic
    and requires collaboration with your developer team, but in the end, you will
    have a very efficient proxy for the external content. Brace yourself.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个重要的技巧，涉及一些不太常见的 Nginx 魔法，并且需要与您的开发团队合作，但最终您将拥有一个非常高效的外部内容代理。做好准备。
- en: Building a secure proxy for the external content
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建外部内容的安全代理
- en: Here is an example of a simple but relatively secure proxy for external images.
    It may be extended to other types of content with ease.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个简单但相对安全的外部图片代理示例。它可以轻松扩展到其他类型的内容。
- en: 'The relevant part of Nginx configuration looks like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Nginx 配置的相关部分如下：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It uses several Nginx modules to implement resources that look like:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用了多个 Nginx 模块来实现如下资源：
- en: '`https://proxy.example.com/insecure/5f814704a38d9bc1915fd19fa0c7a00a/images.external.com/image.gif`'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`https://proxy.example.com/insecure/5f814704a38d9bc1915fd19fa0c7a00a/images.external.com/image.gif`'
- en: The prefix "insecure" may also look like "secure" and encodes the protocol part
    of the original URL. When requested, this URL will either generate the response
    from a local cache or request an external image via HTTP, cache it locally, and
    send to the client.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: “不安全”前缀也可能看起来像“安全”，并编码原始 URL 的协议部分。当请求时，该 URL 将从本地缓存生成响应，或通过 HTTP 请求外部图片，将其缓存到本地并发送给客户端。
- en: The first named location block provides a fallback, that is, an empty `1 x 1`
    image that we will serve on all invalid requests.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命名的 location 块提供了一个回退，即一个空的 `1 x 1` 图像，我们将在所有无效请求中提供这个图像。
- en: The second big location block anchored at `/` is the main configuration. Since
    we have a dedicated hostname for the proxy, we work right from the root. First,
    there are declarations of caching and secure link parameters. After checking the
    validity of the request by using a condition on `$secure_link` variable, we compute
    the original, source URL schema or protocol. We use `/secure/` as the prefix for
    HTTPS, and any other prefix will mean simple insecure HTTP.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个大的 location 块锚定在 `/`，这是主配置。由于我们为代理配置了专用主机名，因此我们从根目录开始工作。首先声明了缓存和安全链接参数。在使用
    `$secure_link` 变量的条件检查请求有效性后，我们计算原始的源 URL 模式或协议。我们使用 `/secure/` 作为 HTTPS 的前缀，任何其他前缀将表示简单的不安全
    HTTP。
- en: A couple of `image_filter_*` directives configure the image filter to only ever
    check the first 10 megabytes. Proxy timeouts provide us with reasonably robust
    HTTP client. We do not want to hang endlessly on very slow (or maliciously slow)
    servers while also processing those servers that are not as fast as everyone hopes.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 `image_filter_*` 指令配置了图像过滤器，只检查前 10 兆字节。代理超时为我们提供了一个相对稳健的 HTTP 客户端。我们不希望在非常慢（或恶意地慢）服务器上无限期挂起，同时还要处理那些并不像每个人希望的那么快的服务器。
- en: The interesting parts of the configuration are the secure link and image filter
    functionality that employ `ngx_http_secure_link` and `ngx_http_image_filter` modules,
    respectively.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 配置中有趣的部分是安全链接和图像过滤功能，分别使用了 `ngx_http_secure_link` 和 `ngx_http_image_filter`
    模块。
- en: The image filter module is the simpler of the two. It runs several heuristic
    checks against the contents of an image file to ensure that it is indeed a GIF,
    PNG, or JPEG image. This protects from several of the older browser security bugs
    that could be exploited with specially crafted responses masquerading as images.
    See [http://nginx.org/en/docs/http/ngx_http_image_filter_module.html](http://nginx.org/en/docs/http/ngx_http_image_filter_module.html)
    for more information.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图像过滤模块是两者中较简单的一个。它会对图像文件的内容进行若干启发式检查，以确保它确实是 GIF、PNG 或 JPEG 图像。这可以防止利用伪装成图像的特制响应所导致的旧版浏览器安全漏洞。更多信息请见[http://nginx.org/en/docs/http/ngx_http_image_filter_module.html](http://nginx.org/en/docs/http/ngx_http_image_filter_module.html)。
- en: The secure link module checks the cryptographic signature in the URL. The idea
    is that without the signature, you will create an HTTP proxy open to the whole
    world, which is a helpful resource for malicious actors of all kinds. The signature
    should be generated on the application side by your development team. The algorithm
    is described in the module documentation at [http://nginx.org/en/docs/http/ngx_http_secure_link_module.html](http://nginx.org/en/docs/http/ngx_http_secure_link_module.html).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 安全链接模块检查 URL 中的加密签名。其目的是，如果没有签名，你将创建一个对全世界开放的 HTTP 代理，这将成为各种恶意行为者的有用资源。签名应由你的开发团队在应用程序端生成。算法在模块文档中有描述，详见[http://nginx.org/en/docs/http/ngx_http_secure_link_module.html](http://nginx.org/en/docs/http/ngx_http_secure_link_module.html)。
- en: This module has a second, even more secure mode of operation that will also
    check the signature for expiration. We recommend that you implement that one too,
    see the documentation for details. The example mentioned earlier uses the easiest
    possible mode for the sake of brevity.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块还有第二种更加安全的操作模式，它还会检查签名的有效期。我们建议你也实现这种模式，详情请见文档。前面提到的示例为了简洁起见，使用了最简单的模式。
- en: This proxy is not a final solution that we usually install in production but
    a simple version. For example, it does not properly process redirected images.
    As you may see from the last lines, many HTTP response codes including those 3xx
    that are responsible for redirects are considered errors and get redirected to
    an empty GIF. A solution for that is a good exercise in the Nginx configuration.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代理并不是我们通常在生产环境中安装的最终解决方案，而是一个简单版本。例如，它没有正确处理重定向的图像。正如你从最后几行看到的那样，许多 HTTP 响应代码（包括那些负责重定向的
    3xx 代码）被视为错误，并被重定向到一个空的 GIF。解决这个问题是 Nginx 配置中的一个不错的练习。
- en: Solving problems with cache
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决缓存问题
- en: 'We spent a lot of time on providing good caching, that is, saving intermediate
    results and serving saved copies instead of recalculating from scratch for the
    same requests. This works perfectly only in a perfect world (for example, a pure
    functional world where functions and, by extension, GET/HEAD HTTP requests do
    not have side effects). In the real world, two equal requests may sometimes lead
    to different responses. There are two basic reasons for it: the earlier-mentioned
    side effects, which change the state despite the perceived idempotence of GET/HEAD,
    or flawed equality relationship between requests. A good example of this is ignoring
    wall time when the response depends on it.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们花了很多时间提供良好的缓存机制，即保存中间结果，并为相同请求提供已保存的副本，而不是从头开始重新计算。这只有在完美的世界中才能完美运行（例如，在一个纯函数的世界里，函数以及由此派生的
    GET/HEAD HTTP 请求没有副作用）。在现实世界中，有时两个相同的请求会导致不同的响应。造成这种情况的原因有两个：前面提到的副作用，它们改变了状态，尽管
    GET/HEAD 看似是幂等的，或者请求之间的等价关系存在缺陷。一个好的例子是，当响应依赖于墙时，忽略时间。
- en: Such problems usually manifest themselves as complaints about seeing stale versions
    of some pages on your website or seeing pages that belong to other users. Although
    you can tolerate the first type to some extent (for example, as a compromise for
    performance), the second type is a major offense and a blocker for the operation
    of your business.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这种问题通常表现为抱怨在你的网站上看到过时版本的页面，或者看到属于其他用户的页面。虽然你在某种程度上可以容忍第一种情况（例如，作为性能的妥协），但第二种情况是一个重大问题，并且会阻碍你的业务运作。
- en: 'The hunt for the misbehaving caches is a process that involves the same two
    sides that we discussed in the previous chapter. The caching may happen both inside
    Nginx as the effect of the caching upstream directives and on the side that is
    closer to the client—either the very browser that initiated the request or one
    of the intermediate caching proxies. The effect of the client-side caches is usually
    smaller these days, so it is safer to start switching it off first. You need to
    have this directive in all scopes:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找出现问题的缓存是一个涉及前一章讨论的两个方面的过程。缓存可能在 Nginx 内部发生，作为上游缓存指令的效果，也可能发生在离客户端更近的地方——无论是发起请求的浏览器，还是某个中间缓存代理。如今，客户端缓存的影响通常较小，因此最好首先关闭客户端缓存。你需要在所有作用域中使用此指令：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Any negative value will work. This instructs Nginx to emit `Cache-Control:
    no-cache` HTTP response header alongside the content. It will effectively break
    client-side caching with a couple of caveats. First, we do not have direct control
    of those caches, of course, and they are free to comply with the standards of
    the modern web at will. For example, they may be configured to ignore `no-cache`
    in an ill-advised attempt to save on traffic. The authors personally debugged
    a couple of cases of such overzealous frugality, and it was a nightmare. And,
    second, even fully compliant caches may lag because to receive the `no-cache`
    instruction they need to reach the origin server while actively trying to avoid
    that, which is the whole point of caching.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '任何负值都有效。这指示 Nginx 在内容旁边发送 `Cache-Control: no-cache` HTTP 响应头。它将有效地破坏客户端缓存，但有一些注意事项。首先，当然我们无法直接控制这些缓存，它们可以自由地遵循现代
    Web 标准。例如，它们可能会配置为忽略 `no-cache`，以不明智地尝试节省流量。作者个人调试过几次此类过度节俭的案例，简直是噩梦。其次，即使完全遵守标准的缓存也可能存在延迟，因为为了接收
    `no-cache` 指令，它们需要联系源服务器，而它们正在积极避免这样做，而这正是缓存的核心目的。'
- en: 'The second step in this troubleshooting process is switching off the caching
    inside Nginx upstream caches. As was explained in the previous chapter, each Nginx
    upstream has a family of directives that configure caching for this particular
    upstream connection. The main switch for the whole mechanism is the `*_cache`
    directive. In the case of `ngx_fastcgi` upstream, the directive looks like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个故障排除过程的第二步是关闭 Nginx 上游缓存中的缓存。如前一章所解释的，每个 Nginx 上游都有一组指令，用于配置该特定上游连接的缓存机制。整个机制的主要开关是
    `*_cache` 指令。在 `ngx_fastcgi` 上游的情况下，指令如下所示：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, the `zone` is an identifier of the so-called cache zone, which is basically
    a collection of caching configuration or caching profile. To switch caching off,
    you will use the fixed zone name `off`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`zone` 是所谓缓存区的标识符，它基本上是一个缓存配置或缓存配置文件的集合。要关闭缓存，你将使用固定的区域名称 `off`。
- en: It will take immediate effect (the common cycle of `nginx -t` and then `sudo
    service nginx reload`, or analog for your distribution should be second nature
    by this time), but it may also devastate your actual application upstream by significantly
    increasing the incoming request rate. Be aware of that. You may take smaller steps
    in troubleshooting the cache by using the `*_cache_bypass` or `*_cache_valid`
    directives in a smart way. The first one provides a way to skip caching some of
    the responses altogether, and the second is a quick-and-dirty way to limit the
    age of the entries in the cache.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 它将立即生效（此时常见的 `nginx -t` 和然后 `sudo service nginx reload` 或者你的发行版的类似命令应该已经非常熟悉了），但它也可能通过显著增加进入请求速率严重影响你的实际应用上游。请注意这一点。你可以通过智能使用
    `*_cache_bypass` 或 `*_cache_valid` 指令来逐步采取较小的步骤来排除缓存问题。第一个提供了跳过完全缓存某些响应的方法，而第二个则是限制缓存条目年龄的快速脏方法。
- en: The `*_cache_valid` directive does not override the expiration parameters set
    via HTTP response headers from the upstream application. So for it to be effective,
    you will also need to remove those headers with a `*_ignore_headers` directive
    first.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`*_cache_valid` 指令不会覆盖通过上游应用程序的 HTTP 响应头设置的过期参数。因此，为了使其有效，你还需要首先使用 `*_ignore_headers`
    指令移除这些头。'
- en: 'Again, the asterisk here means the actual upstream type; in the case of FastCGI
    upstream you will use `fastcgi_cache_valid` and `fastcgi_ignore_headers` directives.
    The simple example will look like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这里的星号表示实际的上游类型；对于 FastCGI 上游，你将使用 `fastcgi_cache_valid` 和 `fastcgi_ignore_headers`
    指令。一个简单的示例将如下所示：
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It will force caching all the responses for 1 minute. Unfortunately, it will
    also cache the responses that the upstream does not intend to be cached because
    Nginx will also ignore `Cache-Control: no-cache` in this configuration. Be careful
    not to leave your troubleshooting session in production.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '它将强制缓存所有响应 1 分钟。不幸的是，它也会缓存上游不希望被缓存的响应，因为在这种配置下，Nginx 也会忽略 `Cache-Control: no-cache`。请注意不要在生产环境中留下你的故障排除会话。'
- en: Obsolete pages and VirtualBox
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 废弃页面和 VirtualBox
- en: There is one other possible problem that manifests itself as users (or, more
    frequently, developers) seeing old versions of web pages in HTTP responses. There
    is a bug in VirtualBox virtualization software, which is very popular as a development
    virtualization solution (for example, with Vagrant or, more lately, Otto). VirtualBox
    is also sometimes used as a production virtualization technology. It has a feature
    named "shared folders", which allows it to have a copy of the host machine folder
    inside one of the guest machines.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个可能的问题表现为用户（或者更频繁地是开发人员）在 HTTP 响应中看到旧版本的网页。这是 VirtualBox 虚拟化软件的一个 bug，在开发虚拟化解决方案中非常流行（例如，使用
    Vagrant 或者最近的 Otto）。VirtualBox 有一个名为“共享文件夹”的功能，允许它在一个客户机中拥有主机机器文件夹的副本。
- en: The bug is in the handling of the `sendfile()` Linux kernel syscall inside VirtualBox.
    This syscall directly copies a file to a TCP socket, avoiding extra unneeded memory
    copies and providing all possible optimizations for this rather specific but very
    popular special case. You can imagine how well this case suits many Nginx workloads.
    Even if it is not just serving local static files, Nginx cache may use `sendfile()`
    very efficiently.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 bug 是在 VirtualBox 内部处理 `sendfile()` Linux 内核系统调用时出现的。这个系统调用直接将文件复制到 TCP 套接字，避免额外不必要的内存复制，并为这个相当特定但非常流行的特殊情况提供所有可能的优化。你可以想象在许多
    Nginx 工作负载中，这种情况是多么有效。即使它不只是提供本地静态文件，Nginx 缓存也可以非常高效地使用 `sendfile()`。
- en: 'The support for `sendfile()` is conditional and may be switched off using this
    directive:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `sendfile()` 的支持是有条件的，可以使用以下指令关闭：
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It is highly recommended if you run Nginx inside VirtualBox and serve files
    from a shared folder.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 VirtualBox 内运行 Nginx 并且从共享文件夹中提供文件，则强烈推荐。
- en: Apache migration problems
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Apache 迁移问题
- en: One of the Apache features that Nginx chose not to replicate is the support
    for the so-called `.htaccess` files. Those files were invented as a way to easily
    configure access control for individual virtual hosts in a virtual hosting environment
    where clients are only able to see their own subfolders via the magic of `chroot`
    (often called from ftpd). The implementation is rather simple; this is an autoincluded
    piece of configuration that Apache constantly monitors for changes. Not every
    possible Apache configuration directive is allowed in `.htaccess` (but many of
    them are, essentially, all that do not require a restart).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Nginx 选择不复制的 Apache 特性之一是对所谓 `.htaccess` 文件的支持。这些文件最初是作为一种方便的方式，用于在虚拟主机环境中配置单独虚拟主机的访问控制，在这种环境中，客户端只能通过
    `chroot`（通常通过 ftpd 调用）看到自己的子文件夹。其实现非常简单；这是一个自动包含的配置部分，Apache 会持续监控其变化。并非所有可能的
    Apache 配置指令都允许出现在 `.htaccess` 中（但很多都可以，基本上是那些不需要重启的指令）。
- en: This feature was (ab)used as a convenient way to distribute the relevant web
    server configuration inside the source code for a website or a web application.
    Although the idea is still relevant, the Apache implementation with a silent change
    monitoring and transparent reconfiguration is not considered well designed. So,
    instead of the proper `.htaccess` support, Nginx suggests to explicitly include
    site-specific configuration files and then reload the configuration.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能曾被（滥）用作一种便捷的方法，将相关的 Web 服务器配置分发到网站或 Web 应用程序的源代码中。尽管这个想法仍然有效，但 Apache 实现的静默变更监控和透明重配置被认为设计不佳。因此，Nginx
    建议显式地包含特定站点的配置文件，然后重新加载配置，而不是使用合适的 `.htaccess` 支持。
- en: If your website source directory contains some `.htaccess` files, chances are
    that you will need to manually convert the directives into either a section inside
    the main `nginx.conf` or a separate file, which is to be included from `nginx.conf`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的网站源目录包含一些 `.htaccess` 文件，那么你很可能需要手动将这些指令转换成主 `nginx.conf` 文件中的某个部分，或者转换成一个单独的文件，再从
    `nginx.conf` 中包含该文件。
- en: One particular case is the proliferation of Apache `mod_rewrite` directives
    inside the `.htaccess` files. This will give you a hard time in the general case
    because Nginx uses a very different language for the URL rewriting functionality.
    One especially difficult case is the web apps that modify their own rewrite rules
    in `.htaccess` as part of their normal workload. Unfortunately, you have to either
    run an instance of Apache for them or order the rewrite of the relevant parts
    of their code altogether.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一个特殊的情况是 `.htaccess` 文件中 Apache `mod_rewrite` 指令的泛滥。这会在一般情况下给你带来麻烦，因为 Nginx
    使用与 URL 重写功能完全不同的语言。一个特别棘手的情况是那些在正常工作负载中修改自己 `.htaccess` 中重写规则的 Web 应用程序。不幸的是，你要么需要为它们运行一个
    Apache 实例，要么必须重新编写相关部分的代码。
- en: 'Here is an example of some old Apache rewrite rules:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一些旧版 Apache 重写规则的示例：
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The idea here was to break the so-called hotlinking – a practice when images
    were directly embedded in external documents, and this web host sent the bytes
    without getting any real users.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的想法是打破所谓的热链接——一种将图片直接嵌入到外部文档中的做法，而这个 Web 主机会发送字节，而没有实际用户访问。
- en: 'The same logic could be implemented for Nginx using these directives:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的逻辑可以通过以下指令在 Nginx 中实现：
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Although Nginx actually contains a special module for referrer checking, it
    will do the same job in a much more elegant way. Refer to the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Nginx 实际上包含一个用于引荐来源检查的特殊模块，但它以更加优雅的方式完成相同的工作。请参见以下内容：
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The logic of long chains of the Apache `mod_rewrite` rules poorly translates
    into Nginx. You should rethink the tasks and try to implement the solutions using
    more elegant ways that Nginx provides, such as `try_files` or special modules.
    See also [http://nginx.org/en/docs/http/converting_rewrite_rules.html](http://nginx.org/en/docs/http/converting_rewrite_rules.html).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Apache `mod_rewrite` 规则的长链逻辑在 Nginx 中表现较差。你应该重新思考任务，并尝试使用 Nginx 提供的更优雅的方式来实现解决方案，例如
    `try_files` 或特定模块。另见 [http://nginx.org/en/docs/http/converting_rewrite_rules.html](http://nginx.org/en/docs/http/converting_rewrite_rules.html)。
- en: There are several tools to help convert static sets of the Apache `mod_rewrite`
    directives into the Nginx syntax. In our practice, they are all only partially
    useful and always require human fixes in the end. You may look at [http://winginx.com/en/htaccess](http://winginx.com/en/htaccess).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些工具可以帮助将静态的 Apache `mod_rewrite` 指令集转换为 Nginx 语法。在我们的实践中，它们都只有部分用处，最终总是需要人工修复。你可以查看
    [http://winginx.com/en/htaccess](http://winginx.com/en/htaccess)。
- en: By the way, this tool does not handle the earlier-mentioned example with the
    HTTP Referrer properly.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，这个工具没有正确处理之前提到的 HTTP 引荐问题。
- en: Solving problems with WebSockets
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决 WebSockets 的问题
- en: '**WebSockets** are a modern protocol that allows a web application to have
    persistent, duplex, long-living connections to servers, similar to real TCP connections
    (and they are, under the hood, pretty normal TCP connections).'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**WebSockets**是一种现代协议，它允许 web 应用程序与服务器之间建立持久、双向、长时间的连接，类似于真实的 TCP 连接（实际上，它们在底层就是普通的
    TCP 连接）。'
- en: WebSockets use the special URL scheme `ws://` (or `wss://` for secure), and
    you will see that in your browser error console if you try to run a WebSocket-opening
    web application from an Nginx-powered server.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: WebSockets 使用特殊的 URL 方案 `ws://`（或用于安全连接的 `wss://`），如果你尝试从 Nginx 支持的服务器运行 WebSocket
    开放的 web 应用程序，你会在浏览器的错误控制台看到它。
- en: The philosophy behind WebSockets directly conflicts with the buffered-reverse
    proxy idea that is the foundation of Nginx as a web accelerator. See the previous
    chapter for the comprehensive introduction into what makes Nginx fast. Fortunately,
    modern Nginx is so much more than just a simple reverse proxy. It has so much
    to offer that even without the buffering and cheap connection pools, it is too
    valuable to ditch because of WebSockets. And since version 1.3.13, which was released
    almost 3 years ago, in early 2013, Nginx has had special support to create long-living
    tunnels between the client and the server, which was specifically introduced to
    support WebSockets.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: WebSockets 背后的理念与 Nginx 作为 Web 加速器的缓冲反向代理理念直接冲突。有关 Nginx 如何提高性能的详细介绍，请参见上一章。幸运的是，现代的
    Nginx 已不仅仅是一个简单的反向代理。它提供了许多功能，即使没有缓冲和廉价的连接池，它也因 WebSockets 而变得不可或缺。自从 2013 年初发布的
    1.3.13 版本以来，Nginx 就已特别支持在客户端和服务器之间创建持久的隧道连接，这一功能专门用于支持 WebSockets。
- en: 'To enable upgrading a normal HTTP connection to a WebSocket, you have to do
    this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用将正常 HTTP 连接升级为 WebSocket，你需要执行以下操作：
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You should appreciate how the support was introduced without a single new directive.
    The configuration language is already rich enough for this. The magic happens
    due to the `Upgrade:` header sent by the client and the `101 Switching Protocols`
    HTTP response code from the server.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该理解，支持的引入没有增加任何新的指令。配置语言本身已经足够丰富来实现这一点。神奇的部分发生在客户端发送的 `Upgrade:` 头部和服务器返回的
    `101 Switching Protocols` HTTP 响应码之间。
- en: One very important parameter is the timeout specified with the `proxy_read_timeout
    method`. The default value of 1 minute might not be sufficient for your (and most
    other) WebSocket use cases. The whole idea of direct long-living connections between
    the app in the browser and the server may be defeated by a short proxy timeout.
    It is perfectly normal for a WebSocket connection to be idle for long periods
    of time, and this is the reason for the increased timeout value. The other solution
    is implementing some sort of heartbeats or pings between the sides of the connection.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常重要的参数是通过`proxy_read_timeout`方法指定的超时。1 分钟的默认值可能不足以满足你的（以及大多数其他）WebSocket
    使用场景。浏览器应用程序与服务器之间的直接长时间连接的整个概念可能会因短暂的代理超时而受到影响。WebSocket 连接在长时间空闲的情况下是完全正常的，这也是为什么需要增加超时值的原因。另一种解决方案是实现连接双方之间的心跳或
    ping。
- en: Showing a file upload progress bar
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示文件上传进度条
- en: 'Uploading files from the web browser to the server is a rather common feature
    of modern web applications. Any number of CMS or publishing systems allows users
    to upload images to include these with their textual content, as shown in the
    following image:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 从 web 浏览器向服务器上传文件是现代 web 应用程序中相当常见的功能。许多内容管理系统或发布系统允许用户上传图像并将其与文本内容一起使用，如下图所示：
- en: '![Showing a file upload progress bar](img/B04329_05_09.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![显示文件上传进度条](img/B04329_05_09.jpg)'
- en: Here is an example of a web upload in progress. The basic idea behind one of
    the algorithms to implement the progress bar is to initiate a POST request in
    an IFrame and then poll some well-known URL for the progress counter. Modern browsers
    allow us to get the progress information right on the client's side; this is a
    part of XMLHttpRequest Level 2 and was standardized about 3 years ago. There are
    a lot of older web applications that still rely on the older methods.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个正在进行的网页上传示例。实现进度条的一个基本算法思想是，在一个IFrame中发起POST请求，然后轮询一个知名的URL来获取进度计数器。现代浏览器允许我们直接在客户端获取进度信息；这是XMLHttpRequest
    Level 2的一部分，约三年前标准化。仍然有很多旧版网页应用依赖于旧的方式。
- en: The described method only works if your client-side posts to your server-side
    with the same speed that the user actually sees in their interface. The problem
    is Nginx that buffers the long POST and then quickly and efficiently pushes it
    to the server-side code. The progress-poller process will not be able to get any
    progress until the very last moment when suddenly the entirety of the upload process
    happens in an instant.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 所描述的方法只有在客户端到服务器端的POST请求与用户在界面中实际看到的上传速度相同的情况下才有效。问题在于Nginx会缓存长时间的POST请求，然后快速高效地将其推送到服务器端代码。进度轮询进程将无法获取任何进度，直到最后一刻，上传过程才会瞬间完成。
- en: There are several solutions to it. A dirty workaround is to process the uploads
    that you want to show progress for outside of Nginx. That is, have a backend server
    that is directly connected to the Internet, POST all your files to it, and get
    your progress from it.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种解决方案。一种临时的解决方法是将需要显示进度的上传操作移到Nginx之外处理。也就是说，使用一个直接连接到互联网的后端服务器，将所有文件POST到该服务器，并从它那里获取进度。
- en: 'A much better solution is to spend some resources and reimplement the progress
    bar part of the interface to use progress events available in modern browsers.
    The JavaScript (with jQuery + jQuery Form plugin) code will look as simple as
    this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的解决方案是投入一些资源，重新实现界面中的进度条部分，使用现代浏览器中可用的进度事件。JavaScript（配合 jQuery + jQuery Form
    插件）代码看起来会像这样简单：
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'A somewhat strange, middle-ground solution would be to use the `nginx_uploadprogress`
    module, which provides its own progress reporting endpoint. The example configuration
    will look like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一种有点奇怪的折中方案是使用`nginx_uploadprogress`模块，它提供了自己的进度报告端点。示例配置将如下所示：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The client side will have to mark all the POSTs to the `/` location with a special
    header or GET parameter `X-Progress-ID`, which may also be used to get the progress
    of that particular upload via the `/progress` resource.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端需要标记所有发送到`/`位置的POST请求，使用一个特殊的头部或GET参数`X-Progress-ID`，该参数也可以用来通过`/progress`资源获取该上传过程的进度。
- en: Solving the problem of an idle upstream
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决空闲上游的问题
- en: We devoted a great deal of content to the concept of upstreams. Just to remind
    you, upstreams are entities that generate HTTP responses that Nginx sends to the
    clients. Usually, an upstream contains several (or at least one) servers speaking
    one of the supported protocols, such as FastCGI or plain HTTP. Nginx uses sophisticated
    client code to very efficiently proxy the communication between the clients and
    the upstream in a transparent way by also optimizing the number of idle connections
    and wasted memory. There are a number of algorithms that Nginx uses to balance
    the client load on all the members of an upstream block, and one of those algorithms
    is known to bite the unsuspecting web administrators.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们花了很多篇幅介绍上游（upstreams）的概念。提醒一下，上游是指生成HTTP响应的实体，这些响应被Nginx发送给客户端。通常，一个上游包含多个（或至少一个）使用支持的协议（如FastCGI或普通HTTP）的服务器。Nginx使用复杂的客户端代码以透明的方式非常高效地代理客户端与上游之间的通信，同时优化空闲连接的数量和浪费的内存。Nginx有多个算法来平衡客户端在上游块中所有成员之间的负载，其中一个算法已知会让毫无防备的网页管理员吃亏。
- en: 'The configuration under discussion looks like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 正在讨论的配置如下所示：
- en: '[PRE16]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The first line sets up the handling of some location or the whole server by
    proxying everything to a named upstream. The mentioned upstream is configured
    in the block later. It consists of three servers and a special directive `ip_hash`,
    which turns on an algorithm to use when choosing one of the three servers that
    will actually process each incoming request.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行设置了通过代理将某个位置或整个服务器的请求转发到指定的上游。上述上游将在后面的块中进行配置。它由三台服务器和一个特殊的指令`ip_hash`组成，该指令在选择三台服务器中的一台时会启用一种算法，处理每个传入请求。
- en: The default algorithm is the so-called weighted round-robin. In our simple configuration
    without any weights, the round-robin would choose the servers one after the other
    in that order and rewind back to the first after the last. It is an efficient
    and simple algorithm that will surely balance the load in a good fashion. One
    significant disadvantage of it is that the requests from the same client may end
    up being processed on different upstream servers, which sometimes is not good,
    for example, because of the caching in RAM on the individual upstream servers.
    The directive `ip_hash` will turn the round-robin off, and instead, servers will
    be chosen based on a hash value computed from the IP address of the client.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 默认算法是所谓的加权轮询。在我们没有任何权重的简单配置中，轮询会按照顺序依次选择服务器，并在最后一台之后回到第一台。这是一个高效且简单的算法，能够以一种良好的方式平衡负载。它的一个显著缺点是，来自同一客户端的请求可能会在不同的上游服务器上处理，这有时并不好，例如，由于各个上游服务器的
    RAM 缓存。指令`ip_hash`会关闭轮询，取而代之的是，服务器将根据从客户端的 IP 地址计算出的哈希值来选择。
- en: One of the consequences is that the same client will always talk to the same
    server (unless that server is down, in which case the hash value will point to
    another server trying to minimize the effect on the rest of the servers in the
    upstream). The other consequence is that your client load will be distributed
    between servers only as evenly as your client IP addresses. Usually, when you
    have enough load to justify proper upstream blocks with many servers, your client
    IP pool will already be big and diverse enough. Sometimes there is another proxy
    in front of Nginx, and all your incoming requests look like they come from a very
    limited set of addresses. In this case, you have a subtle and hard-to-debug problem,
    which may or may not lead to a disaster.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 其结果之一是，相同的客户端将始终与同一台服务器通信（除非该服务器宕机，在这种情况下，哈希值会指向另一台服务器，尽量减少对上游其他服务器的影响）。另一个结果是，你的客户端负载将仅根据客户端
    IP 地址在服务器之间分配得一样均匀。通常，当负载足够大以至于需要适当的上游块和多台服务器时，客户端 IP 池已经足够大且多样化。有时 Nginx 前面还有另一个代理，所有传入的请求看起来都来自非常有限的地址集。在这种情况下，你可能会遇到一个微妙且难以调试的问题，这个问题可能会导致灾难，亦或不会。
- en: If you are lucky, you will note that the load on your upstream servers is very
    uneven. For example, if one of those three servers is completely idle although
    there are no problems with it, and it happily responds to direct requests.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你幸运的话，你会注意到上游服务器的负载非常不均衡。例如，如果这三台服务器中的一台完全空闲，尽管它没有问题，而且它很高兴地响应直接请求。
- en: The quick and dirty workaround here is to remove the `ip_hash` directive. The
    proper solution will require you to employ the `ngx_http_realip` module and provide
    better data for the IP-hashing algorithm. The idea is to save the real client
    IP address to a special HTTP request header on the proxy that is located in front
    of the Nginx and then take it from there instead of the real endpoint address
    of incoming TCP connections. This module may not be compiled in your version of
    Nginx.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的快速简便的解决方法是移除`ip_hash`指令。正确的解决方案需要你使用`ngx_http_realip`模块，并为 IP 哈希算法提供更好的数据。这个思路是将真实的客户端
    IP 地址保存到位于 Nginx 前面的代理的特殊 HTTP 请求头中，然后从那里获取，而不是使用传入 TCP 连接的真实端点地址。这个模块可能在你当前版本的
    Nginx 中没有编译。
- en: There are also other consistent hashing strategies that you might consider.
    Refer to the full documentation for hashing at [http://nginx.org/en/docs/http/ngx_http_upstream_module.html#hash](http://nginx.org/en/docs/http/ngx_http_upstream_module.html#hash).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以考虑其他一致性哈希策略。关于哈希的完整文档，请参考[http://nginx.org/en/docs/http/ngx_http_upstream_module.html#hash](http://nginx.org/en/docs/http/ngx_http_upstream_module.html#hash)。
- en: Summary
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have provided you with a number of seemingly unconnected
    cases that you may or may not have the luck to face for real. We have quickly
    recapped on the most popular troubles with SSL/TLS certificates that webmasters
    encounter starting from the most embarrassing expiration to building a whole caching
    proxy for external insecure content. We have also described a number of cases
    with caching, URL rewriting rules migration, file-upload progress interfaces,
    and concluded with the mystery of an idle upstream. The next chapter is devoted
    to building a proper monitoring system for your Nginx-powered servers. We will
    move from solving problems to actively preventing them.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们为您提供了一些看似无关的案例，您可能会有机会面对这些问题，也可能不会。我们快速回顾了网站管理员遇到的最常见SSL/TLS证书问题，从最尴尬的证书过期开始，到为外部不安全内容构建完整的缓存代理。我们还描述了许多涉及缓存、URL重写规则迁移、文件上传进度接口的案例，并以一个空闲上游的谜题作为结尾。下一章将专门讨论为您的Nginx服务器构建一个适当的监控系统。我们将从解决问题转向主动预防问题。
