<html><head></head><body>
<div id="_idContainer049">
<h1 class="chapter-number" id="_idParaDest-156"><a id="_idTextAnchor688"/><span class="koboSpan" id="kobo.1.1">8</span></h1>
<h1 id="_idParaDest-157"><a id="_idTextAnchor689"/><span class="koboSpan" id="kobo.2.1">NGINX within a Cloud Infrastructure</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the evolving landscape of web infrastructure, the shift from traditional server configurations to cloud architectures is undeniable. </span><span class="koboSpan" id="kobo.3.2">Traditional deployments, where servers were manually configured to host multiple sites or applications, are now giving way to more agile and scalable cloud-based methods. </span><span class="koboSpan" id="kobo.3.3">This chapter looks at the practical aspects of adopting a cloud infrastructure, highlighting the resource management efficiencies, enhanced security, and improved management of high traffic demands </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">it offers.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">In this chapter, we will focus on the role of NGINX within a cloud infrastructure, using Docker as the platform of choice. </span><span class="koboSpan" id="kobo.5.2">By integrating NGINX with Docker, we’ll demonstrate how to orchestrate multiple services seamlessly, fostering a resilient and adaptable environment. </span><span class="koboSpan" id="kobo.5.3">Whether Docker is a new concept to you or not, rest assured that we’ll guide you through your first Docker experience, with NGINX as a common thread, ensuring a smooth and understandable journey into </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">containerized deployment.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">This chapter covers the </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.9.1">Understanding </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">cloud infrastructure</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.11.1">Using Docker</span></span></li>
<li><span class="koboSpan" id="kobo.12.1">Setting up NGINX </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">inside Docker</span></span></li>
<li><span class="koboSpan" id="kobo.14.1">Setting up NGINX inside Docker to proxy </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">host applications</span></span></li>
</ul>
<h1 id="_idParaDest-158"><a id="_idTextAnchor690"/><span class="koboSpan" id="kobo.16.1">Understanding cloud infrastructure</span></h1>
<p><span class="koboSpan" id="kobo.17.1">Cloud services </span><a id="_idIndexMarker463"/><span class="koboSpan" id="kobo.18.1">are an integral part of our online existence. </span><span class="koboSpan" id="kobo.18.2">Our mobile applications synchronize seamlessly with their desktop counterparts, and the server once familiar to us has transformed into today’s cloud—a concept that simplifies life for users while making web infrastructure more complex. </span><span class="koboSpan" id="kobo.18.3">This digital metamorphosis has revolutionized the way we store and interact with our data, moving us toward an always-connected, </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">cloud-centric reality.</span></span></p>
<h2 id="_idParaDest-159"><a id="_idTextAnchor691"/><span class="koboSpan" id="kobo.20.1">The traditional approach</span></h2>
<p><span class="koboSpan" id="kobo.21.1">To comprehend the</span><a id="_idIndexMarker464"/><span class="koboSpan" id="kobo.22.1"> intricacies of cloud infrastructure, let’s revisit traditional setups with a modern </span><em class="italic"><span class="koboSpan" id="kobo.23.1">cloud</span></em><span class="koboSpan" id="kobo.24.1"> lens. </span><span class="koboSpan" id="kobo.24.2">Consider the case of WordPress, the renowned open source platform for website creation, which runs on a web server, a PHP server, and a database server. </span><span class="koboSpan" id="kobo.24.3">The classic method is to install each component on a single machine—a simple solution for hosting a </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">solitary blog:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer045">
<span class="koboSpan" id="kobo.26.1"><img alt="Figure 8.1: A traditional approach to running your web project" src="image/B21787_08_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.27.1">Figure 8.1: A traditional approach to running your web project</span></p>
<p><span class="koboSpan" id="kobo.28.1">However, scaling this model reveals its limitations. </span><span class="koboSpan" id="kobo.28.2">Various software dependencies may require multiple, sometimes contradictory versions, making coexistence difficult. </span><span class="koboSpan" id="kobo.28.3">What’s more, as services expand, managing them on a single server becomes more and </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">more complicated.</span></span></p>
<h2 id="_idParaDest-160"><a id="_idTextAnchor692"/><span class="koboSpan" id="kobo.30.1">The cloud approach</span></h2>
<p><span class="koboSpan" id="kobo.31.1">In the </span><a id="_idIndexMarker465"/><span class="koboSpan" id="kobo.32.1">pursuit of hosting multiple services on a single server, we often encounter a common problem: </span><strong class="bold"><span class="koboSpan" id="kobo.33.1">conflicting software dependencies</span></strong><span class="koboSpan" id="kobo.34.1">. </span><span class="koboSpan" id="kobo.34.2">Imagine needing to run two applications, one requiring PHP 7.4 and the other PHP 8.3. </span><span class="koboSpan" id="kobo.34.3">Docker addresses this by encapsulating applications in containers, isolated environments that operate independently of the underlying Linux distribution’s </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">software versions.</span></span></p>
<p><span class="koboSpan" id="kobo.36.1">Advantages of using Docker containers include </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.38.1">Version management</span></strong><span class="koboSpan" id="kobo.39.1">: Docker</span><a id="_idIndexMarker466"/><span class="koboSpan" id="kobo.40.1"> containers simplify the process of maintaining and changing software versions, making it easy to go back </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">if necessary</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.42.1">Isolation and efficiency</span></strong><span class="koboSpan" id="kobo.43.1">: Containers isolate applications, which not only improves portability for easier migration but also ensures that the resource consumption of one doesn’t affect </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">the others</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.45.1">Deployment streamlining</span></strong><span class="koboSpan" id="kobo.46.1">: By overcoming the Docker learning curve, deployment and scaling become easier to manage, offering a degree of flexibility not found in </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">traditional configurations</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.48.1">Let’s revisit</span><a id="_idIndexMarker467"/><span class="koboSpan" id="kobo.49.1"> the blog hosting scenario, now </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">using Docker:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer046">
<span class="koboSpan" id="kobo.51.1"><img alt="Figure 8.2: An example of how it would look running WordPress with Docker" src="image/B21787_08_2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.52.1">Figure 8.2: An example of how it would look running WordPress with Docker</span></p>
<p><span class="koboSpan" id="kobo.53.1">The server runs a Linux distribution and, on top of this, two separate containers act as minimal Linux environments, each carrying only what’s needed to run its </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">respective applications.</span></span></p>
<p><span class="koboSpan" id="kobo.55.1">The addition of a service such as Nextcloud, which could run PHP 8.3, alongside WordPress on PHP 7.4, demonstrates the ability </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">of Docker:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer047">
<span class="koboSpan" id="kobo.57.1"><img alt="Figure 8.3: An example of how it would look running multiple containers with Docker" src="image/B21787_08_3.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.58.1">Figure 8.3: An example of how it would look running multiple containers with Docker</span></p>
<p><span class="koboSpan" id="kobo.59.1">As shown, this </span><a id="_idIndexMarker468"/><span class="koboSpan" id="kobo.60.1">configuration allows many Docker images, each with its own specific software version, to run simultaneously in an isolated environment. </span><span class="koboSpan" id="kobo.60.2">If a security problem occurs in one container, its effects are confined, protecting the rest of </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">the system.</span></span></p>
<p><span class="koboSpan" id="kobo.62.1">This chapter won’t cover advanced topics such as Docker Swarm</span><a id="_idIndexMarker469"/><span class="koboSpan" id="kobo.63.1"> for </span><strong class="bold"><span class="koboSpan" id="kobo.64.1">high availability</span></strong><span class="koboSpan" id="kobo.65.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.66.1">HA</span></strong><span class="koboSpan" id="kobo.67.1">) or Kubernetes for scalability, but these are important areas to explore for the advancement of </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">cloud infrastructure.</span></span></p>
<h1 id="_idParaDest-161"><a id="_idTextAnchor693"/><span class="koboSpan" id="kobo.69.1">Using Docker</span></h1>
<p><span class="koboSpan" id="kobo.70.1">In the previous section, we explored </span><a id="_idIndexMarker470"/><span class="koboSpan" id="kobo.71.1">the fundamentals of cloud architectures. </span><span class="koboSpan" id="kobo.71.2">We’re now going to move on from theory to practice by installing and configuring Docker step by step to launch our </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">first container.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.73.1">Docker</span></strong><span class="koboSpan" id="kobo.74.1"> is </span><a id="_idIndexMarker471"/><span class="koboSpan" id="kobo.75.1">not just a tool but a paradigm shift—a new era where software can be packaged and isolated, ensuring consistency across environments. </span><span class="koboSpan" id="kobo.75.2">By the end of this section, Docker will be more than a concept; it will be an integral part of your toolbox, starting with the deployment of an </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">NGINX container.</span></span></p>
<h2 id="_idParaDest-162"><a id="_idTextAnchor694"/><span class="koboSpan" id="kobo.77.1">Installing Docker</span></h2>
<p><span class="koboSpan" id="kobo.78.1">Fortunately </span><a id="_idIndexMarker472"/><span class="koboSpan" id="kobo.79.1">for us, the Docker team has provided a script that simplifies the installation process. </span><span class="koboSpan" id="kobo.79.2">This script is compatible with a range of Linux distributions, including </span><strong class="bold"><span class="koboSpan" id="kobo.80.1">Red Hat Enterprise Linux</span></strong><span class="koboSpan" id="kobo.81.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.82.1">RHEL</span></strong><span class="koboSpan" id="kobo.83.1">), CentOS, Fedora, Debian, Ubuntu, and</span><a id="_idIndexMarker473"/> <span class="No-Break"><span class="koboSpan" id="kobo.84.1">their derivatives.</span></span></p>
<p><span class="koboSpan" id="kobo.85.1">To install Docker, you will need to run the script with root privileges. </span><span class="koboSpan" id="kobo.85.2">Open your terminal and enter the </span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.87.1">
# curl -s https://get.docker.com | bash</span></pre> <p><span class="koboSpan" id="kobo.88.1">With this</span><a id="_idIndexMarker474"/><span class="koboSpan" id="kobo.89.1"> single command, Docker will be installed natively on your system using custom repositories adapted to your Linux distribution’s package manager. </span><span class="koboSpan" id="kobo.89.2">This means that updating Docker will be as easy as updating any other package on </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">your system.</span></span></p>
<h2 id="_idParaDest-163"><a id="_idTextAnchor695"/><span class="koboSpan" id="kobo.91.1">Your first Docker container</span></h2>
<p><span class="koboSpan" id="kobo.92.1">There </span><a id="_idIndexMarker475"/><span class="koboSpan" id="kobo.93.1">are many ways to operate Docker containers. </span><span class="koboSpan" id="kobo.93.2">For instance, you can launch a container using a </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">simple command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.95.1">
root@docker:~# docker run -d nginx
latest: Pulling from library/nginx
e1caac4eb9d2: Pull complete</span></pre> <p><span class="koboSpan" id="kobo.96.1">This command pulls the NGINX image from Docker Hub and starts a new container in detached mode. </span><span class="koboSpan" id="kobo.96.2">However, this container runs with default settings and isn’t yet configured for </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">specific use.</span></span></p>
<p><span class="koboSpan" id="kobo.98.1">To customize the container, you can pass additional parameters. </span><span class="koboSpan" id="kobo.98.2">For example, to map the container’s port 80 to the host’s port 80, allowing web traffic to reach the container, you would run </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">the following:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.100.1">
root@docker:~# docker run -d nginx -p 80:80</span></pre> <p><span class="koboSpan" id="kobo.101.1">The first command launches the NGINX container with the default configuration. </span><span class="koboSpan" id="kobo.101.2">The second command runs the same container, but now it is accessible via the host machine’s port 80. </span><span class="koboSpan" id="kobo.101.3">But what if you require a more advanced and complete configuration? </span><span class="koboSpan" id="kobo.101.4">This is where Docker Compose steps in, offering a solution for managing multi-container Docker applications </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">with ease.</span></span></p>
<p><span class="koboSpan" id="kobo.103.1">In the context of this book, the NGINX image serves as an excellent example of Docker’s capabilities as it showcases how containerization simplifies the deployment of services that traditionally require </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">dedicated servers.</span></span></p>
<p><span class="koboSpan" id="kobo.105.1">As we explore deeper, we’ll see how to tailor an NGINX container to serve static content or act as a reverse</span><a id="_idIndexMarker476"/><span class="koboSpan" id="kobo.106.1"> proxy, introducing the concept of Docker volumes and how to use them to serve custom configuration files </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">and content.</span></span></p>
<h2 id="_idParaDest-164"><a id="_idTextAnchor696"/><span class="koboSpan" id="kobo.108.1">Simplifying with Docker Compose</span></h2>
<p><span class="koboSpan" id="kobo.109.1">After </span><a id="_idIndexMarker477"/><span class="koboSpan" id="kobo.110.1">running our first Docker container, it became clear that managing a container’s parameters directly from the command line can quickly become cumbersome. </span><strong class="bold"><span class="koboSpan" id="kobo.111.1">Docker Compose</span></strong><span class="koboSpan" id="kobo.112.1"> simplifies this process by allowing us to define and run multi-container Docker applications using a YAML file </span><span class="No-Break"><span class="koboSpan" id="kobo.113.1">for configuration.</span></span></p>
<p><span class="koboSpan" id="kobo.114.1">Let’s create an equivalent setup to the one we ran in the previous section—an NGINX container with port 80 exposed to the </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">host machine:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.116.1">Begin by creating a </span><strong class="source-inline"><span class="koboSpan" id="kobo.117.1">/root/nginx</span></strong><span class="koboSpan" id="kobo.118.1"> directory, and within that directory, save a file named </span><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">docker-compose.yml</span></strong><span class="koboSpan" id="kobo.120.1"> with the </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">following content:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.122.1">
version: '3'
services:
  nginx:
    image: nginx:latest
    ports:
      - "80:80"</span></pre></li> </ol>
<p class="callout-heading"><span class="koboSpan" id="kobo.123.1">A reminder</span></p>
<p class="callout"><span class="koboSpan" id="kobo.124.1">Although the file format is called </span><em class="italic"><span class="koboSpan" id="kobo.125.1">YAML</span></em><span class="koboSpan" id="kobo.126.1">, the extension needs to </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">be </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">.yml</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">.</span></span></p>
<p class="list-inset"><span class="koboSpan" id="kobo.130.1">In this </span><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">docker-compose.yml</span></strong><span class="koboSpan" id="kobo.132.1"> file, we’ve defined a service named </span><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">nginx</span></strong><span class="koboSpan" id="kobo.134.1">, using the official </span><strong class="source-inline"><span class="koboSpan" id="kobo.135.1">nginx</span></strong><span class="koboSpan" id="kobo.136.1"> image tagged with </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">latest</span></strong><span class="koboSpan" id="kobo.138.1">, which means it will be updated every time we pull it from Docker Hub. </span><span class="koboSpan" id="kobo.138.2">If you wish, you can specify a fixed version, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.139.1">nginx:1.25.4</span></strong><span class="koboSpan" id="kobo.140.1">. </span><span class="koboSpan" id="kobo.140.2">More details can be found on the Docker Hub for NGINX </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">page (</span></span><a href="https://hub.docker.com/_/nginx/"><span class="No-Break"><span class="koboSpan" id="kobo.142.1">https://hub.docker.com/_/nginx/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.143.1">).</span></span></p>
<ol>
<li value="2"><span class="koboSpan" id="kobo.144.1">Now, with the Docker Compose file saved, run the following command in the </span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">same directory:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.146.1">root@nginx:~/nginx# docker compose up</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.147.1">[+] Running 1/1</span></strong>
<strong class="bold"> </strong><strong class="bold"><span class="koboSpan" id="kobo.148.1">✔</span></strong><strong class="bold"><span class="koboSpan" id="kobo.149.1"> Container nginx-nginx-1  Created</span></strong></pre></li> <li><span class="koboSpan" id="kobo.150.1">You’ve</span><a id="_idIndexMarker478"/><span class="koboSpan" id="kobo.151.1"> just launched your first container using Docker Compose. </span><span class="koboSpan" id="kobo.151.2">To stop this container, simply use the </span><em class="italic"><span class="koboSpan" id="kobo.152.1">Ctrl</span></em><span class="koboSpan" id="kobo.153.1"> + </span><em class="italic"><span class="koboSpan" id="kobo.154.1">C</span></em><span class="koboSpan" id="kobo.155.1"> shortcut (</span><strong class="source-inline"><span class="koboSpan" id="kobo.156.1">^C</span></strong><span class="koboSpan" id="kobo.157.1">). </span><span class="koboSpan" id="kobo.157.2">Alternatively, you can start the container in detached mode with </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">up -d</span></strong><span class="koboSpan" id="kobo.159.1"> and stop it </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">down</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.163.1">root@nginx:~/nginx# docker compose up -d</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.164.1">root@nginx:~/nginx# docker compose down</span></strong></pre></li> </ol>
<p><span class="koboSpan" id="kobo.165.1">With Docker Compose, running NGINX in Docker becomes a matter of defining the desired state in a file, which is easier to manage and read than standalone commands. </span><span class="koboSpan" id="kobo.165.2">In the next section, we’ll explore how to further configure NGINX in Docker, tailoring it to our </span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">specific needs.</span></span></p>
<h1 id="_idParaDest-165"><a id="_idTextAnchor697"/><span class="koboSpan" id="kobo.167.1">Setting up NGINX inside Docker</span></h1>
<p><span class="koboSpan" id="kobo.168.1">Having become</span><a id="_idIndexMarker479"/><span class="koboSpan" id="kobo.169.1"> familiar with Docker Compose, we’re set to advance our container usage. </span><span class="koboSpan" id="kobo.169.2">In this section, we’ll improve our NGINX container by adding personalized configurations and </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">website content.</span></span></p>
<p><span class="koboSpan" id="kobo.171.1">Let’s begin by</span><a id="_idIndexMarker480"/><span class="koboSpan" id="kobo.172.1"> revisiting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">docker-compose.yml</span></strong><span class="koboSpan" id="kobo.174.1"> file we created earlier. </span><span class="koboSpan" id="kobo.174.2">This file already specifies the NGINX service and maps the container’s port 80 to port 80 on the host machine, making the web server accessible from </span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">the host.</span></span></p>
<p><span class="koboSpan" id="kobo.176.1">Next, we want our NGINX container to serve our website using the actual configuration files and content from our host machine. </span><span class="koboSpan" id="kobo.176.2">To achieve this, we’ll use Docker volumes. </span><span class="koboSpan" id="kobo.176.3">Volumes are the preferred mechanism for persisting data generated and used by Docker containers. </span><span class="koboSpan" id="kobo.176.4">Here’s how you can modify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">docker-compose.yml</span></strong><span class="koboSpan" id="kobo.178.1"> file to mount </span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">a volume:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.180.1">
version: '3'
services:
  nginx:
    image: nginx:latest
    ports:
      - «80:80»
    volumes:
      - ./config/nginx.conf:/etc/nginx/nginx.conf
      - ./html:/usr/share/nginx/html</span></pre> <p><span class="koboSpan" id="kobo.181.1">In this</span><a id="_idIndexMarker481"/><span class="koboSpan" id="kobo.182.1"> setup, </span><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">./config/nginx.conf</span></strong><span class="koboSpan" id="kobo.184.1"> is the path to your custom NGINX configuration file on your host machine. </span><strong class="source-inline"><span class="koboSpan" id="kobo.185.1">/etc/nginx/nginx.conf</span></strong><span class="koboSpan" id="kobo.186.1"> is the path where the NGINX container expects to find the configuration file. </span><span class="koboSpan" id="kobo.186.2">The </span><a id="_idIndexMarker482"/><span class="koboSpan" id="kobo.187.1">second volume, </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">./html</span></strong><span class="koboSpan" id="kobo.189.1">, is the directory on your host machine that contains your website’s content, mounted into </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">/usr/share/nginx/html/</span></strong><span class="koboSpan" id="kobo.191.1"> in the </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">Docker container.</span></span></p>
<p><span class="koboSpan" id="kobo.193.1">This approach ensures that you can edit your NGINX configuration or website content directly on your host machine, and those changes will be reflected inside </span><span class="No-Break"><span class="koboSpan" id="kobo.194.1">the container.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.195.1">A note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.196.1">NGINX is preconfigured; therefore, you can skip mounting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">nginx.conf</span></strong><span class="koboSpan" id="kobo.198.1"> volume and use the default settings. </span><span class="koboSpan" id="kobo.198.2">Do mount the </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">html</span></strong><span class="koboSpan" id="kobo.200.1"> directory as it is where NGINX expects to find web content </span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">to serve.</span></span></p>
<h2 id="_idParaDest-166"><a id="_idTextAnchor698"/><span class="koboSpan" id="kobo.202.1">Integrating PHP with NGINX using Docker Compose</span></h2>
<p><span class="koboSpan" id="kobo.203.1">As we</span><a id="_idIndexMarker483"/><span class="koboSpan" id="kobo.204.1"> progress, our</span><a id="_idIndexMarker484"/><span class="koboSpan" id="kobo.205.1"> next step is to elevate our</span><a id="_idIndexMarker485"/><span class="koboSpan" id="kobo.206.1"> NGINX server to handle dynamic content with PHP. </span><span class="koboSpan" id="kobo.206.2">This combination is common in the web development world, and Docker Compose makes it easy </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">to implement.</span></span></p>
<p><span class="koboSpan" id="kobo.208.1">We’ll start by extending our existing </span><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">docker-compose.yml</span></strong><span class="koboSpan" id="kobo.210.1"> file to include a PHP service, and then we</span><a id="_idIndexMarker486"/><span class="koboSpan" id="kobo.211.1"> will ensure NGINX can </span><a id="_idIndexMarker487"/><span class="koboSpan" id="kobo.212.1">communicate with the PHP</span><a id="_idIndexMarker488"/><span class="koboSpan" id="kobo.213.1"> service </span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">using FastCGI:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.215.1">First, we need to</span><a id="_idIndexMarker489"/><span class="koboSpan" id="kobo.216.1"> add a PHP service that runs </span><strong class="bold"><span class="koboSpan" id="kobo.217.1">FastCGI Process Manager</span></strong><span class="koboSpan" id="kobo.218.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">php-fpm</span></strong><span class="koboSpan" id="kobo.220.1">). </span><span class="koboSpan" id="kobo.220.2">Here’s how the updated </span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">docker-compose.yml</span></strong><span class="koboSpan" id="kobo.222.1"> file </span><span class="No-Break"><span class="koboSpan" id="kobo.223.1">might look:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.224.1">
version: '3'
services:
  nginx:
    image: nginx:latest
    ports:
      - "80:80"
    volumes:
      - ./config/nginx.conf:/etc/nginx/nginx.conf
      - ./html:/usr/share/nginx/html
    depends_on:
      - php
  php:
    image: php:8.3-fpm
    volumes:
      - ./html:/usr/share/nginx/html</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.225.1">In this setup, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">php</span></strong><span class="koboSpan" id="kobo.227.1"> service uses the official PHP image with </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">php-fpm</span></strong><span class="koboSpan" id="kobo.229.1">. </span><span class="koboSpan" id="kobo.229.2">We also mount the </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">html</span></strong><span class="koboSpan" id="kobo.231.1"> directory into the PHP container to ensure it has access to the same web files </span><span class="No-Break"><span class="koboSpan" id="kobo.232.1">as NGINX.</span></span></p></li> <li><span class="koboSpan" id="kobo.233.1">Before starting the Docker containers, we need to make sure NGINX and PHP communicate. </span><span class="koboSpan" id="kobo.233.2">Let’s </span><a id="_idIndexMarker490"/><span class="koboSpan" id="kobo.234.1">edit the </span><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">nginx.conf</span></strong><span class="koboSpan" id="kobo.236.1"> file to include FastCGI parameters. </span><span class="koboSpan" id="kobo.236.2">Here’s an </span><a id="_idIndexMarker491"/><span class="koboSpan" id="kobo.237.1">example of </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">nginx.conf</span></strong><span class="koboSpan" id="kobo.239.1"> with</span><a id="_idIndexMarker492"/><span class="koboSpan" id="kobo.240.1"> included </span><span class="No-Break"><span class="koboSpan" id="kobo.241.1">FastCGI parameters:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.242.1">
events {}
http {
  server {
    listen 80;
    server_name localhost;
    root /usr/share/nginx/html;
    index index.php index.html index.htm;
    location / {
        try_files $uri $uri/ =404;
    }
    location ~ \.php$ {
      try_files $uri =404;
      fastcgi_pass php:9000;
      fastcgi_index index.php;
      fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
      include fastcgi_params;
    }
  }
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.243.1">This configuration instructs NGINX to forward requests for </span><a id="_idIndexMarker493"/><span class="koboSpan" id="kobo.244.1">PHP files to the PHP-FPM service running in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">php</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.246.1"> container.</span></span></p></li> </ol>
<p class="callout-heading"><span class="koboSpan" id="kobo.247.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.248.1">NGINX resolves the </span><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">php</span></strong><span class="koboSpan" id="kobo.250.1"> service name using Docker’s internal DNS to communicate with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">php-fpm</span></strong><span class="koboSpan" id="kobo.252.1"> service. </span><span class="koboSpan" id="kobo.252.2">If you rename the service in your </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">docker-compose.yml</span></strong><span class="koboSpan" id="kobo.254.1"> file, remember to update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">nginx.conf</span></strong><span class="koboSpan" id="kobo.256.1"> file accordingly to match the new </span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">service name.</span></span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.258.1">With</span><a id="_idIndexMarker494"/><span class="koboSpan" id="kobo.259.1"> this </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">docker-compose.yml</span></strong><span class="koboSpan" id="kobo.261.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">nginx.conf</span></strong><span class="koboSpan" id="kobo.263.1"> configuration, you can run </span><strong class="source-inline"><span class="koboSpan" id="kobo.264.1">docker compose up</span></strong><span class="koboSpan" id="kobo.265.1">, and NGINX will serve both your static content and your dynamic </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">PHP pages:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.267.1">root@nginx:~/nginx# docker compose up</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.268.1">[+] Running 2/0</span></strong>
<strong class="bold"> </strong><strong class="bold"><span class="koboSpan" id="kobo.269.1">✔</span></strong><strong class="bold"><span class="koboSpan" id="kobo.270.1"> Container docker-php-1    Created</span></strong>
<strong class="bold"> </strong><strong class="bold"><span class="koboSpan" id="kobo.271.1">✔</span></strong><strong class="bold"><span class="koboSpan" id="kobo.272.1"> Container docker-nginx-1  Created</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.273.1">Attaching to nginx-1, php-1</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.274.1">php-1 [02-Mar-2024 11:42:30] NOTICE: fpm is running, pid 1</span></strong></pre></li> <li><span class="koboSpan" id="kobo.275.1">After</span><a id="_idIndexMarker495"/><span class="koboSpan" id="kobo.276.1"> launching your containers, to check that NGINX and PHP are interacting correctly, create a PHP file containing </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">&lt;?php phpinfo(); ?&gt;</span></strong><span class="koboSpan" id="kobo.278.1">. </span><span class="koboSpan" id="kobo.278.2">This will display a PHP information page when accessed, confirming successful communication between </span><span class="No-Break"><span class="koboSpan" id="kobo.279.1">the containers:</span></span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer048">
<span class="koboSpan" id="kobo.280.1"><img alt="Figure 8.4: phpinfo running within Docker" src="image/B21787_08_4.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.281.1">Figure 8.4: phpinfo running within Docker</span></p>
<p><span class="koboSpan" id="kobo.282.1">This</span><a id="_idIndexMarker496"/><span class="koboSpan" id="kobo.283.1"> subsection has guided you through adding a PHP service to your Docker environment and configuring NGINX to process PHP scripts via FastCGI. </span><span class="koboSpan" id="kobo.283.2">This configuration</span><a id="_idIndexMarker497"/><span class="koboSpan" id="kobo.284.1"> mimics</span><a id="_idIndexMarker498"/><span class="koboSpan" id="kobo.285.1"> a production environment, providing a solid foundation for building and deploying PHP applications </span><span class="No-Break"><span class="koboSpan" id="kobo.286.1">with Docker.</span></span></p>
<p><span class="koboSpan" id="kobo.287.1">In the next section, we’ll explore how to configure a Docker-contained NGINX to proxy applications running directly on the </span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">host server.</span></span></p>
<h1 id="_idParaDest-167"><a id="_idTextAnchor699"/><span class="koboSpan" id="kobo.289.1">Setting up NGINX inside Docker to proxy host applications</span></h1>
<p><span class="koboSpan" id="kobo.290.1">Fortunately</span><a id="_idIndexMarker499"/><span class="koboSpan" id="kobo.291.1"> for us, Docker is built with inherent support for container-to-host connections. </span><span class="koboSpan" id="kobo.291.2">When setting up NGINX inside a container, a special </span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">host.docker.internal</span></strong><span class="koboSpan" id="kobo.293.1"> hostname is used to target the </span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">host machine.</span></span></p>
<p><span class="koboSpan" id="kobo.295.1">Here’s a sample NGINX proxy configuration for interfacing with a web application hosted on </span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">the server:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.297.1">
server {
    listen 80;
    location /hostapp {
        proxy_pass http://host.docker.internal:4000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}</span></pre> <p><span class="koboSpan" id="kobo.298.1">To ensure NGINX can communicate with the host server’s web application, check that the host’s firewall </span><a id="_idIndexMarker500"/><span class="koboSpan" id="kobo.299.1">allows incoming traffic on the </span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">specified ports.</span></span></p>
<p><span class="koboSpan" id="kobo.301.1">Concluding this section, we’ve successfully bridged the containerized NGINX with host-resident applications, leveraging Docker’s internal </span><span class="No-Break"><span class="koboSpan" id="kobo.302.1">networking features.</span></span></p>
<p><span class="koboSpan" id="kobo.303.1">In the next section, we’ll recap what we learned in </span><span class="No-Break"><span class="koboSpan" id="kobo.304.1">this book.</span></span></p>
<h1 id="_idParaDest-168"><a id="_idTextAnchor700"/><span class="koboSpan" id="kobo.305.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.306.1">In this chapter, we’ve taken our first steps with Docker and Docker Compose, set up an NGINX container, added PHP, and learned to proxy traffic to a web app on the </span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">host server.</span></span></p>
<p><span class="koboSpan" id="kobo.308.1">Combined with the knowledge from the previous chapters, the exercises in this chapter have highlighted NGINX’s potential as a key asset in cloud infrastructure, strengthening security and managing traffic efficiently, well suited for SSL handling, load balancing, and </span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">content caching.</span></span></p>
<p><span class="koboSpan" id="kobo.310.1">In the next chapter, we’ll learn how to deploy and update NGINX with automated tasks using </span><span class="No-Break"><span class="koboSpan" id="kobo.311.1">orchestration tools.</span></span></p>
</div>
</body></html>