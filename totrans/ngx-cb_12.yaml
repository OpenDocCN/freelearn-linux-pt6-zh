- en: OpenResty
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing OpenResty
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with OpenResty Lua
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lua microservices with OpenResty
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A simple hit counter with a Redis backend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Powering API gateways with OpenResty
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you've ever wondered whether you can make a few changes to NGINX dynamically
    or wanted a bit more flexibility, then you're going to love OpenResty.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2f639334-f4ef-41c0-a7f5-2edabbf6488c.png)'
  prefs: []
  type: TYPE_IMG
- en: Think of OpenResty as NGINX with the kitchen sink thrown in; it's a combination
    of NGINX, along with Lua scripting, and several additional third-party modules
    all packaged up and ready to use. The inclusion of Lua scripting and additional
    modules allows NGINX to be extended to be a full web application rather than simply
    a web server.
  prefs: []
  type: TYPE_NORMAL
- en: Some may fear that this additional functionality comes with a performance hit,
    but this simply isn't the case. Large platforms, such as **Cloudflare**, use a
    combination of NGINX and Lua to achieve what they do at scale, and it's due to
    the power of OpenResty. In fact, the original creator, Yichun Zhang worked for
    Cloudflare on OpenResty and has now formed a separate OpenResty foundation to
    steward the platform going forward.
  prefs: []
  type: TYPE_NORMAL
- en: This power allows complicated scenarios such as **Web Application Firewalls**
    (**WAFs**) to be tightly integrated at the website level, allowing the combination
    of per-site flexibility with the high-speed aspects NGINX is known for. In fact,
    many are even starting to use OpenResty for their full framework and it can be
    especially effective for a simple microservice-driven system.
  prefs: []
  type: TYPE_NORMAL
- en: This is just one of the many examples. In this chapter, you'll see that OpenResty
    is a great fit for many scenarios where you want to use NGINX but also wish to
    add a bit of dynamic flair.
  prefs: []
  type: TYPE_NORMAL
- en: Installing OpenResty
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenResty is packaged for the easy installation of most Linux distributions,
    but there are binary packages for both Windows and OS X available as well. As
    most production deployments will predominantly be Linux-based, we'll concentrate
    on Linux for our recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have NGINX already installed, you'll need to uninstall it first to remove
    any other conflicts.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Official repositories exist for most major Linux installations, but we'll focus
    on just CentOS 7 and Ubuntu 16.04 LTS to cover the two most common scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: CentOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To add the repository, the first thing we need is the `yum-utils` package.
    This makes the creation of repositories as simple as a one-line installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'With `yum-utils` installed, we can now create the `openresty` repository on
    our server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will automatically fetch the remote repository file and place it in the
    correct location for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the repository installed and enabled, we can now install OpenResty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This will install the latest OpenResty package, as well as all the required
    dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable the service to start on boot, we can enable it via `systemd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can start the service via `systemd` as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This will start NGINX, which will be preconfigured with all the OpenResty additions.
    As it comes with a simple configuration (as NGINX does out-of-the-box), you can
    quickly open a browser and see the output via the IP to confirm it''s working:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/58cbc56d-aff3-4944-8ba8-4b876af7d1d1.png)'
  prefs: []
  type: TYPE_IMG
- en: Ubuntu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To install OpenResty on an Ubuntu-based system, first we need to import the
    **GPG** key used for signing the packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Like the CentOS installation, we can use a helper package to make the installation
    of the repository easy. To install it, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now install the repository for OpenResty and then refresh the `package`
    indexes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'With the repository installed, we can now install the OpenResty package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Once all the dependencies and OpenResty packages are installed, you can now
    set the service to start on boot and then start it so that you can test the service.
    You can do this via `systemd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If you don't see any errors, you will then be able browse to the IP address
    of your server (or virtual machine) and see the OpenResty test page, as shown
    in the previous CentOS installation instructions.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The locations of the configuration files and system libraries are slightly different
    to a standard NGINX installation, so it's important to remember the location.
    By default, OpenResty installs to `/usr/local/openresty`. For example, if you
    look for the NGINX configuration files, they'll be stored in `/usr/local/openresty/nginx/conf`.
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the standard NGINX configuration file, you won't see any real
    difference between it and the standard package. Because OpenResty is essentially
    just NGINX with additional modules compiled, you can easily take an existing NGINX
    configuration (like any of the ones covered in this book) and extend the functionality
    with the additional OpenResty modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can confirm these modules are available by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This should give you an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We can confirm that there are additional modules installed, such as `lua_upstream`
    and `luajit`, which form the core of the OpenResty capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: "For official installation instructions, refer to [https://openresty.org/en/installation.html](6863d7d3-d70d-4aa7-a96d-a799f0bb8667.xhtml).\uFEFF"
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with OpenResty Lua
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the key powers of OpenResty is the built-in Lua scripting language. For
    those not familiar with Lua, it's a high-performance, yet lightweight scripting
    language. This is why, when it's combined with the NGINX event engine, it results
    in a very powerful combination.
  prefs: []
  type: TYPE_NORMAL
- en: Being a dynamically typed and interpreted language makes Lua similar to other
    scripting languages, such as JavaScript, but there are some subtle differences
    (especially syntax-wise). If you're new to Lua, then it's worthwhile reading through
    a few basic tutorials to familiarize yourself with the syntax and differences.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we'll use the standard OpenResty modules, so no further changes
    are required to get started.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll start with using one of the most basic functions in OpenResty and Lua,
    which is the `content_by_lua_block` block directive. This allows us to insert
    Lua code directly in line with our NGINX configuration, providing rapid and dynamic
    changes. The first recipe returns a basic string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If you browse to the URL (or use cURL to make the request), you should simply
    get `This is a simple test` as the HTTP response. Running a simple Apache Benchmark
    against this URL (just to show a baseline performance) shows that it can serve
    this URL over 20,000 times a second on a modestly resourced VM. While the code
    isn't overly complex, it does show that the overheads for adding Lua have a very
    minimal effect on performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need to return the data as JSON, then this is quite simple to do as
    well. Using the basic example, as we used previously, we can leverage the Lua
    CJSON library (compiled with OpenResty by default) to encode the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If we call the `/simplejsontest` URL, you should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This, of course, barely scratches the surface of what can be achieved with Lua,
    but this should at least get you started.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In both recipes, we utilized Lua modules to provide (albeit simplistic) output
    based on Lua code. While the code is in line with the NGINX configuration, it
    runs directly within each worker process. This gives it massive concurrency out-of-the-box,
    which, combined with the native speed of Lua, means it's incredibly powerful.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For more details on the Lua module, refer to [https://github.com/openresty/lua-nginx-module#readme](https://github.com/openresty/lua-nginx-module#readme).
  prefs: []
  type: TYPE_NORMAL
- en: Lua microservices with OpenResty
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the quickest, natural extensions of OpenResty is to create and run a
    microservice directly, rather than having to proxy it to another external service.
    For those not familiar with microservices, this is a methodology of breaking down
    a software platform into small, independent services rather than a single, monolithic
    system. Here''s a basic diagram of how the services may look for a web application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/74ba2c1f-c837-4089-be2a-07ee4a28ff01.png)'
  prefs: []
  type: TYPE_IMG
- en: This means that each microservice can be independently upgraded, changed, and
    scaled as required; keeping it to one task means the code should remain easier
    to manage.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we're going to focus on just one microservice. In a real-world
    deployment, these microservices could be as high as 150 for a complex platform,
    and many typically hover between the range of 10-30.
  prefs: []
  type: TYPE_NORMAL
- en: For this microservice, we're going to take advantage of the built-in Lua DNS
    module (`lua-resty-dns`) to provide a resolution tool and return the result as
    JSON. As a real-world example, we're going to look up the **Mail Exchanger** (**MX**)
    record. This could be part of a platform for email migration, anti-spam validation,
    or similar and would traditionally require NGINX to proxy the connection to an
    external application.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create our microservice, we''re going to create a `location` block directive
    with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If you browse to the IP or the name of the server and pass the domain as a
    get variable with the name to test, you should receive a copy of the MX records
    back in JSON format for that domain. For example, if we call `http://openresty.nginxcookbook.com/getmxrecord/?domain=instagram.com`,
    you should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: There can be more than one MX record; this is why you see an array returned
    within the JSON data for the records.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We start by loading the CJSON and Lua OpenResty DNS modules and initiating the
    DNS module by setting the nameservers to `8.8.8.8` (Google's free open resolver).
  prefs: []
  type: TYPE_NORMAL
- en: Then, we parse the `GET` argument, named domain. Through the NGINX API, Lua
    can call this directly via the `domain` name. If the get variable you wanted was
    named shop, you could have called it via `ngx.var.arg_shop`.
  prefs: []
  type: TYPE_NORMAL
- en: This is then validated by ensuring the variable is set (for example, the `GET`
    argument was passed) and then checking for a basic domain. The formats of the
    regular expressions within Lua are slightly different to the more common **Perl-Compatible
    Regular Expressions** (**PCRE**), but the concept remains the same. We ensure
    that the domains start with alphanumeric characters (using `%w`); they should
    contain at least one dot (`.`) and alphanumeric characters. While it's not a perfect
    validator, the advent of all the new **Top-Level Domains** (**TLDs**) has made
    this considerably harder to do.
  prefs: []
  type: TYPE_NORMAL
- en: After ensuring the domain is valid, we run a query, specifying the query type
    to be MX. If we receive a result, this is encoded via the CJSON module to return
    the results as JSON code.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a production environment, you can use the standard NGINX rate-limiting features
    (as covered in [Chapter 9](c879c343-0d45-42e7-9f86-2217fd837e4d.xhtml), *Advanced
    Features*) to limit the abuse of a service like this, especially if it's exposed
    directly to the internet. The advantage of OpenResty is that you still have the
    full power of NGINX to use outside of the enhancements it provides.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For more information on Lua-resty-dns module, refer to [https://github.com/openresty/lua-resty-dns](https://github.com/openresty/lua-resty-dns)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information on Lua NGINX API variables, refer to [https://github.com/openresty/lua-nginx-module#ngxvarvariable](https://github.com/openresty/lua-nginx-module#ngxvarvariable)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple hit counter with a Redis backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One simple example to show the ease of extendibility of OpenResty is with a
    basic hit counter. Taking it a step further, we're going to use a Redis backend
    so that the counter is both persistent and could also be part of a clustered deployment
    to give a combined hit counter. This will also introduce you to the basics of
    how OpenResty can directly talk to many other services outside of the basic proxying
    of connections or via FPM.
  prefs: []
  type: TYPE_NORMAL
- en: In a deployment where every bit of optimization possible is critical, this could
    also be used to retrieve cached data direct from Redis, allowing the application
    servers to simply write cache data to Redis in an asynchronized manner.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll need access to a Redis daemon or cluster from this server. This could
    be in the form of a full cluster or you can simply have Redis installed alongside
    OpenResty on the same server.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To implement our simple hit counter, we''re going to add a basic location block
    directive to our main `nginx.conf` configuration file. Here''s the block directive
    to add:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If we call the `/redistest` URL, we should see the counter increase each time
    the page is refreshed.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We again used `content_by_lua_block` to return content, and this contains our
    basic counter code. It starts by making a connection to Redis on the localhost
    (`127.0.0.1`) and returns an error if the connection fails.
  prefs: []
  type: TYPE_NORMAL
- en: If the connection is successful, we attempt to fetch a value from Redis with
    a key named `counter`. In the event that there's no data or an invalid number,
    we set the counter to `0` (zero). Then, we increment the Lua variable to indicate
    there's been a hit to this URL. This is then stored back in Redis (via the `set`
    command), and the value of the counter is returned as plain text with a status
    of `200` (the default for `ngx.say`).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For more information on the `lua-resty-redis` module, refer to [https://github.com/openresty/lua-resty-redis.](https://github.com/openresty/lua-resty-redis)
  prefs: []
  type: TYPE_NORMAL
- en: Powering API Gateways with OpenResty
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our previous recipe, we explored a basic microservice to look up DNS records.
    While this can be limited per service to prevent abuse, ideally, we want to configure
    a centralized point to manage this. Otherwise, any limits across multiple services
    will not be considered as a whole and will need to be individually implemented
    per service. The following figure explains the differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f68f3d6a-adbd-4928-9d31-b7f82b84578d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To build a centralized API gateway, we need to consider the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Request routing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rate limiting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Load balancing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This recipe will cover a basic implementation of an API gateway to get you started
    with some of the core concepts. Because of the ease of implementation, it provides
    a rapid way to get started with the management of a few, small microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because we'll be centralizing some of the information, we need access to a **Redis**
    daemon accessible from the server. This could be in the form of a full cluster
    or should simply have Redis installed alongside OpenResty on the same server.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to have a test URL, you can set it via `redis-cli`, using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our API gateway is going to be a simplified version of a production system to
    ensure it is easy to follow. Being OpenResty-based, it means it's easily extendible
    to suit your needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `nginx.conf` file (located in `/usr/local/openresty/nginx/conf`), add
    the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike the previous recipes, where we added the details within a `lua` block
    directive, this time we''ve separated the code into individual files for ease
    of management. Within the `nginx` directory (within the main `OpenResty` directory),
    we''ve created an `apigateway` directory to store the files for ease of management.
    Here''s the code for the `auth.lua` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll create a file to store the routing application code, named `route.lua`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can test the authentication by running a call with and without the `X-API-KEY`
    header. Without the header, we can either browse to the URL or use cURL to send
    a `GET` request to `/api/v1`, and it should display the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Conversely, with the correct header set, we should see the expected result
    returned. To test this, we can run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The returned value should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There's quite a bit going on in this recipe, so we'll go through it section
    by section. Firstly, the core NGINX configuration has two main sections. The first
    is the proxy location block directive, which is what we use to make external requests.
    This is because within `route.lua`, the `location.capture` function only works
    for internal requests. While, in this recipe, we've only made an internal request,
    having this `proxy_pass` directive allows us to easily incorporate external calls.
    It simply takes the remote request as part of the URI to pass through. We've also
    locked it down (using `allow` / `deny`) to the localhost to prevent any external
    misuse.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we define our API location block directive. To keep the code within the
    main configuration file neat and precise, we store the configuration in an external
    file so that the code management is easier.
  prefs: []
  type: TYPE_NORMAL
- en: Our `auth.lua` file contains our authentication code. For the sake of keeping
    this recipe simple to follow, I've created a basic table type (which is an associative
    array) to store a few test API keys in; for a production system, these would be
    pulled from an external data source.
  prefs: []
  type: TYPE_NORMAL
- en: We then define a `badAuth` function, which gives us an easy way to return an
    `HTTP 401` error to let the client connection know the connection wasn't authorized.
  prefs: []
  type: TYPE_NORMAL
- en: The next function we've defined is `isAuthorised`. This simply iterates through
    our table of allowed API keys to determine whether there is a match or not.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we extract the `X-API-KEY` header to interrogate the value. If it's
    nil, that is, the header hasn't been set, we use `badAuth` to return `401`. If
    it's not nil, we use the `isAuthorised` function to determine whether there is
    a match or not. If there's a match, there's simply nothing further for our code
    to do and OpenResty will start processing the content components.
  prefs: []
  type: TYPE_NORMAL
- en: This brings us to our routing code contained within the `route.lua` file. Like
    our previous recipe, we make a connection to our Redis server. This is used to
    provide dynamic routing. This means, to change our endpoints or even to provide
    new API functions, there's no requirement to restart our API gateway to detect
    these changes.
  prefs: []
  type: TYPE_NORMAL
- en: To get the endpoint URI to call, we use `ngx.var.uri` as the key. In our example,
    this has been configured as `/api/v1/test`. If this exists, we use `ngx.location.capture`
    to proxy this through and retrieve the data. A successful return of data is then
    sent back to the client, parsed as JSON using the `CJSON` module. In the case
    of an error, we simply return an error message and set the HTTP status to `500`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What''s missing from this recipe is any form of **rate limiting**. We could
    again incorporate either the standard NGINX module or use the `lua-resty-limit-traffic`
    module to provide extended functionality; alternatively, you can go for a fully
    featured API system, such as Kong:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9c98cab7-4369-40f2-8c51-a242ace9aa7b.png)'
  prefs: []
  type: TYPE_IMG
- en: Based on OpenResty, Kong offers a very highly configurable API gateway and microservice
    management system with features such as a REST-based administration, easy horizontal
    scaling, and a modular plugin system for easy extension. Authentication features,
    such as OAuth, JWT, LDAP, and more, are all available out-of-the-box and it has
    security features such as ACLs and CORs to provide high levels of protection.
  prefs: []
  type: TYPE_NORMAL
- en: If you move beyond a few basic services or want to provide your API to the public,
    it's well worth considering Kong as your starting point.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For more information on **Lua NGINX API variables**, refer to [https://github.com/openresty/lua-nginx-module#ngxvarvariable](https://github.com/openresty/lua-nginx-module#ngxvarvariable)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information on **OpenResty FAQ**, refer to [https://openresty.org/en/faq.html](https://openresty.org/en/faq.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: "You can visit the official website of **Kong** at [https://getkong.org/\uFEFF\
    ](https://getkong.org/)"
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
