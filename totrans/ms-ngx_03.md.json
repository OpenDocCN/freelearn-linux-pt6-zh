["```\nmail {\n  auth_http  localhost:9000/auth;\n\n  server {\n    listen  110;\n    protocol  pop3;\n    proxy  on;\n  }\n}\n```", "```\nmail {\n  pop3_capabilities    TOP USER;\n}\n```", "```\nmail {\n  pop3_auth    apop cram-md5;\n}\n```", "```\nmail {\n  auth_http  localhost:9000/auth;\n\n  imap_capabilities    IMAP4rev1 UIDPLUS QUOTA;\n  imap_auth    login cram-md5;\n\n  server {\n    listen 143;\n    protocol imap;\n    proxy on;\n  }\n}\n```", "```\nmail {\n  auth_http  localhost:9000/auth;\n\n  smtp_capabilities  PIPELINING 8BITMIME DSN;\n  smtp_auth    login cram-md5;\n\n  server {\n    listen 25;\n    protocol smtp;\n    proxy on;\n  }\n}\n```", "```\nmail {\n  # allow STLS for POP3 and STARTTLS for IMAP and SMTP\n  starttls    on;\n  # prefer the server's list of ciphers, so that we may determine security\n  ssl_prefer_server_ciphers  on;\n  # use only these protocols\n     ssl_protocols    TLSv1 SSLv3;\n  # use only high encryption cipher suites, excluding those\n  #   using anonymous DH and MD5, sorted by strength\n     ssl_ciphers    HIGH:!ADH:!MD5:@STRENGTH;\n  # use a shared SSL session cache, so that all workers can\n  #   use the same cache\n  ssl_session_cache    shared:MAIL:10m;\n  # certificate and key for this host\n  ssl_certificate      /usr/local/etc/nginx/mail.example.com.crt;\n  ssl_certificate_key  /usr/local/etc/nginx/mail.example.com.key;\n}\n```", "```\n$ openssl req -newkey rsa:2048 -nodes -out mail.example.com.csr -keyout mail.example.com.key\n\n```", "```\nGenerating a 2048 bit RSA private key \n....................................................................................................................+++ \n....................+++ \nwriting new private key to 'mail.example.com.key' \n----- \nYou are about to be asked to enter information that will be incorporated \ninto your certificate request. \nWhat you are about to enter is what is called a Distinguished Name or a DN. \nThere are quite a few fields but you can leave some blank \nFor some fields there will be a default value, \nIf you enter '.', the field will be left blank. \n----- \nCountry Name (2 letter code) [AU]:CH \nState or Province Name (full name) [Some-State]:Zurich \nLocality Name (eg, city) []:ZH \nOrganization Name (eg, company) [Internet Widgits Pty Ltd]:Example Company \nOrganizational Unit Name (eg, section) []: \nCommon Name (e.g. server FQDN or YOUR name) []:mail.example.com \nEmail Address []: \nPlease enter the following 'extra' attributes \nto be sent with your certificate request \nA challenge password []: \nAn optional company name []: \n\n```", "```\n$ openssl x509 -req -days 365 -in mail.example.com.csr -signkey mail.example.com.key -out mail.example.com.crt\n\n```", "```\nSignature ok \nsubject=/C=CH/ST=Zurich/L=ZH/O=Example Company/CN=mail.example.com \nGetting Private key \n\n```", "```\nevents {\n    worker_connections 1024;\n}\n\nmail {\n     server_name  mail.example.com;\n     auth_http  localhost:9000/auth;\n\n     proxy on;\n\n     ssl_prefer_server_ciphers\ton;\n     ssl_protocols    TLSv1 SSLv3;\n     ssl_ciphers      HIGH:!ADH:!MD5:@STRENGTH;\n     ssl_session_cache\t  shared:MAIL:10m;\n     ssl_certificate  \t/usr/local/etc/nginx/mail.example.com.crt;\n     ssl_certificate_key  /usr/local/etc/nginx/mail.example.com.key;\n\n     pop3_capabilities\t  TOP USER;\n     imap_capabilities\t  IMAP4rev1 UIDPLUS QUOTA;\n     smtp_capabilities\t  PIPELINING 8BITMIME DSN;\n\n     pop3_auth    apop cram-md5;\n     imap_auth    login cram-md5;\n     smtp_auth    login cram-md5;\n\n     server {\n        listen 25;\n        protocol smtp;\n        timeout 120000;\n        }\n     server {\n        listen 465;\n        protocol smtp;\n        ssl on;\n        }\n     server {\n        listen 587;\n        protocol smtp;\n        starttls on;\n        }\n     server {\n        listen 110;\n        protocol pop3;\n        starttls on;\n        }\n     server {\n        listen 995;\n        protocol pop3;\n        ssl on;\n        }\n     server {\n        listen 143;\n        protocol imap;\n        starttls on;\n        }\n     server {\n        listen 993;\n        protocol imap;\n        ssl on;\n        }\n}\n```", "```\n      # the authentication mechanism\n      meth = @env['HTTP_AUTH_METHOD']\n      # the username (login)\n      user = @env['HTTP_AUTH_USER']\n      # the password, either in the clear or encrypted, depending on the\n      #  authentication mechanism used\n      pass = @env['HTTP_AUTH_PASS']\n      # need the salt to encrypt the cleartext password, used for some\n      #  authentication mechanisms, not in our example\n      salt = @env['HTTP_AUTH_SALT']\n      # this is the protocol being proxied\n      proto = @env['HTTP_AUTH_PROTOCOL']\n      # the number of attempts needs to be an integer\n      attempt = @env['HTTP_AUTH_LOGIN_ATTEMPT'].to_i\n      # not used in our implementation, but these are here for reference\n      client = @env['HTTP_CLIENT_IP']\n      host = @env['HTTP_CLIENT_HOST']\n```", "```\n      # fail if more than the maximum login attempts are tried\n      if attempt > @max_attempts\n        @res[\"Auth-Status\"] = \"Maximum login attempts exceeded\"\n        return\n      end\n```", "```\n        @res[\"Auth-Status\"] = \"OK\"\n        @res[\"Auth-Server\"] = @mailhost\n        # return the correct port for this protocol\n        @res[\"Auth-Port\"] = MailAuth::Port[proto]\n        # if we're using APOP, we need to return the password in cleartext\n        if meth == 'apop' && proto == 'pop3'\n          @res[\"Auth-User\"] = user\n          @res[\"Auth-Pass\"] = pass\n        end\n```", "```\n        # if authentication was unsuccessful, we return an appropriate response\n        @res[\"Auth-Status\"] = \"Invalid login or password\"\n        # and set the wait time in seconds before the client may make\n        # another authentication attempt\n        @res[\"Auth-Wait\"] = \"3\"\n        # we can also set the error code to be returned to the SMTP client\n        @res[\"Auth-Error-Code\"] = \"535 5.7.8\"\n```", "```\n      @auths = { \"test:1234\" => '127.0.1.1' }\n```", "```\n      # this simply returns the value looked-up by the 'user:pass' key\n      if @auths.key?(\"#{user}:#{pass}\")\n        @mailhost = @auths[\"#{user}:#{pass}\"]\n        return true\n      #  if there is no such key, the method returns false\n      else\n        return false\n      end\n```", "```\n#!/usr/bin/env rackup\n\n# This is a basic HTTP server, conforming to the authentication protocol\n#  required by NGINX's mail module.\n#\nrequire 'logger'\nrequire 'rack'\n\nmodule MailAuth\n\n  # setup a protocol-to-port mapping\n  Port = {\n    'smtp' => '25',\n    'pop3' => '110',\n    'imap' => '143'\n  }\n\n  class Handler\n\n    def initialize\n      # setup logging, as a mail service\n      @log = Logger.new(\"| logger -p mail.info\")\n      # replacing the normal timestamp by the service name and pid\n      @log.datetime_format = \"nginx_mail_proxy_auth pid: \"\n      # the \"Auth-Server\" header must be an IP address\n      @mailhost = '127.0.0.1'\n      # set a maximum number of login attempts\n      @max_attempts = 3\n      # our authentication 'database' will just be a fixed hash for# this example\n      # it should be replaced by a method to connect to LDAP or a # database\n      @auths = { \"test:1234\" => '127.0.1.1' }\n    end\n```", "```\n    def call(env)\n      # our headers are contained in the environment\n      @env = env\n      # set up the request and response objects\n      @req = Rack::Request.new(env)\n      @res = Rack::Response.new\n      # pass control to the method named after the HTTP verb\n      #  with which we're called\n      self.send(@req.request_method.downcase)\n      # come back here to finish the response when done\n      @res.finish\n    end\n\n    def get\n      # the authentication mechanism\n      meth = @env['HTTP_AUTH_METHOD']\n      # the username (login)\n      user = @env['HTTP_AUTH_USER']\n      # the password, either in the clear or encrypted, depending on\n      # the authentication mechanism used\n      pass = @env['HTTP_AUTH_PASS']\n      # need the salt to encrypt the cleartext password, used for some\n      #  authentication mechanisms, not in our example\n      salt = @env['HTTP_AUTH_SALT']\n      # this is the protocol being proxied\n      proto = @env['HTTP_AUTH_PROTOCOL']\n      # the number of attempts needs to be an integer\n      attempt = @env['HTTP_AUTH_LOGIN_ATTEMPT'].to_i\n      # not used in our implementation, but these are here forreference\n      client = @env['HTTP_CLIENT_IP']\n      host = @env['HTTP_CLIENT_HOST']\n\n      # fail if more than the maximum login attempts are tried\n      if attempt > @max_attempts\n        @res[\"Auth-Status\"] = \"Maximum login attempts exceeded\"\n        return\n      end\n\n      # for the special case where no authentication is done\n      #  on smtp transactions, the following is in nginx.conf:\n      #     smtp_auth   none;\n      # may want to setup a lookup table to steer certain senders\n      #  to particular SMTP servers\n      if meth == 'none' && proto == 'smtp'\n        helo = @env['HTTP_AUTH_SMTP_HELO']\n        # want to get just the address from these two here\n        from = @env['HTTP_AUTH_SMTP_FROM'].split(/: /)[1]\n        to = @env['HTTP_AUTH_SMTP_TO'].split(/: /)[1]\n        @res[\"Auth-Status\"] = \"OK\"\n        @res[\"Auth-Server\"] = @mailhost\n        # return the correct port for this protocol\n        @res[\"Auth-Port\"] = MailAuth::Port[proto]\n        @log.info(\"a mail from #{from} on #{helo} for #{to}\")\n      # try to authenticate using the headers provided\n      elsif auth(user, pass)\n        @res[\"Auth-Status\"] = \"OK\"\n        @res[\"Auth-Server\"] = @mailhost\n        # return the correct port for this protocol\n        @res[\"Auth-Port\"] = MailAuth::Port[proto]\n        # if we're using APOP, we need to return the password in cleartext\n        if meth == 'apop' && proto == 'pop3'\n          @res[\"Auth-User\"] = user\n          @res[\"Auth-Pass\"] = pass\n        end\n        @log.info(\"+ #{user} from #{client}\")\n      # the authentication attempt has failed\n      else\n        # if authentication was unsuccessful, we return an appropriate response\n        @res[\"Auth-Status\"] = \"Invalid login or password\"\n        # and set the wait time in seconds before the client may make\n        # another authentication attempt\n        @res[\"Auth-Wait\"] = \"3\"\n        # we can also set the error code to be returned to the SMTPclient\n        @res[\"Auth-Error-Code\"] = \"535 5.7.8\"\n        @log.info(\"! #{user} from #{client}\")\n      end\n\n    end\n```", "```\n    private\n\n    # our authentication method, adapt to fit your environment\n    def auth(user, pass)\n      # this simply returns the value looked-up by the 'user:pass' key\n      if @auths.key?(\"#{user}:#{pass}\")\n        @mailhost = @auths[\"#{user}:#{pass}\"]\n        return @mailhost\n      #  if there is no such key, the method returns false\n      else\n        return false\n      end\n    end\n\n    # just in case some other process tries to access the service\n    #  and sends something other than a GET\n    def method_missing(env)\n      @res.status = 404\n    end\n\n  end # class MailAuthHandler\nend # module MailAuth\n```", "```\n# setup Rack middleware\nuse Rack::ShowStatus\n# map the /auth URI to our authentication handler\nmap \"/auth\" do\n  run MailAuth::Handler.new\nend\n```", "```\n# gem install memcached (depends on libsasl2 and gettext libraries)\nrequire 'memcached'\n\n# set this to the IP address/port where you have memcached running\n@cache = Memcached.new(\"localhost:11211\")\n\ndef get_cache_value(user, pass)\n  resp = ''\n  begin\n    # first, let's see if our key is already in the cache\n    resp = @cache.get(\"#{user}:#{pass}\")\n  rescue Memcached::NotFound\n    # it's not in the cache, so let's call the auth method\n    resp = auth(user, pass)\n    # and now store the response in the cache, keyed on 'user:pass'\n    @cache.set(\"#{user}:#{pass}\",resp)\n  end\n  # explicitly returning the response to the caller\n  return resp\nend\n```", "```\n    sudo apt-get install memcached\n\n    ```", "```\n    sudo yum install memcached\n\n    ```", "```\n    sudo pkg_add -r memcached\n\n    ```", "```\n<timestamp> [info] <worker pid>#0: *<connection id> client <ip address> connected to 0.0.0.0:110 \n```", "```\n<timestamp> [info] <worker pid>#0: *<connection id> client logged in, client: <ip address>, server: 0.0.0.0:110, login: \"<username>\", upstream: <upstream ip>:<upstream port>, [<client ip>:<client port>-<local ip>:110] <=> [<local ip:<high port>-<upstream ip>:<upstream port>] \n```", "```\n<timestamp> [info] <worker pid>#0: *<connection id> proxied session done, client: <ip address>, server: 0.0.0.0:110, login: \"<username>\", upstream: <upstream ip>:<upstream port>, [<client ip>:<client port>-<local ip>:110] <=> [<local ip:<high port>-<upstream ip>:<upstream port>] \n```", "```\n<timestamp> [warn] <worker pid>#0: *<connection id> \"starttls\" directive conflicts with \"ssl on\"\n```", "```\n<timestamp> [error] <worker pid>#0: *<connection id> auth http server 127.0.0.1:9000 timed out while in http auth state, client: <client ip>, server: 0.0.0.0:25\n<timestamp> [error] <worker pid>#0: *<connection id> auth http server 127.0.0.1:9000 sent invalid response while in http auth state, client: <client ip>, server: 0.0.0.0:25\n```", "```\n<timestamp> [error] <worker pid>#0: *<connection id> auth http server 127.0.0.1:9000 did not send server or port while in http auth state, client: <client ip>, server: 0.0.0.0:25, login: \"<login>\"\n```", "```\n<timestamp> [error] <worker pid>#0: *<connection id> no \"http_auth\" is defined for server in /opt/nginx/conf/nginx.conf:32\n```", "```\nulimit -n\n\n```"]