- en: Docker Containers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 容器
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: NGINX web server via Docker
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 Docker 使用 NGINX Web 服务器
- en: NGINX reverse proxy via Docker
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NGINX 反向代理通过 Docker
- en: Docker Compose with NGINX
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 NGINX 的 Docker Compose
- en: NGINX load balancing with Docker
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NGINX 负载均衡与 Docker
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: While the concept of container technology isn't new, the rise of Docker's popularity
    is simply because it was the first to bring simplicity and scalability to the
    market. For those who don't quite understand what Docker is, on a simplistic level,
    it's just an application container.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然容器技术的概念并不新鲜，但 Docker 流行的崛起只是因为它是第一个将简便性和可扩展性带入市场的工具。对于那些不太理解 Docker 的人，从简单的角度来看，它仅仅是一个应用容器。
- en: 'Containers themselves are simply another way of virtualizing your environment.
    Rather than having to emulate components such as a **Virtual Machine** (**VM**),
    containers run on a single kernel and rely on software-level abstraction and isolation
    to provide lightweight and faster virtual environments. Docker takes this a step
    further and isolates it right down to a single application, as shown in the following
    diagram:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 容器本身只是虚拟化环境的另一种方式。与其模拟虚拟机（**Virtual Machine**，**VM**）等组件，容器在单一内核上运行，并依赖软件层面的抽象和隔离来提供轻量级且更快速的虚拟环境。Docker
    进一步简化了这一过程，将其隔离到单个应用程序，如下图所示：
- en: '![](img/7192fc7f-7ec5-4a92-9e65-8625425e0f5e.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7192fc7f-7ec5-4a92-9e65-8625425e0f5e.png)'
- en: The advantage is that this high level of abstraction means that you can provide
    a highly consistent and rapidly deployable service architecture that is simple
    to run. Not only that, Docker has a number of tools to orchestrate and help manage
    the deployment of the containers as well.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 其优点在于，这种高度的抽象意味着你可以提供一个高度一致且可以快速部署的服务架构，并且易于运行。不仅如此，Docker 还有许多工具可以协作并帮助管理容器的部署。
- en: Installing Docker
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Docker
- en: If you haven't installed Docker yet, the easiest way to try it is on your local
    development machine. Rather than running it natively, these environments set up
    a small Linux VM and provide wrappers to directly use it from your existing operating
    system.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有安装 Docker，最简单的尝试方法是在本地开发机器上进行。与本地运行不同，这些环境设置了一个小型的 Linux 虚拟机，并提供了封装器，让你可以直接从现有的操作系统中使用它。
- en: 'To install it, download and run it through the installers from here:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装它，请从此处下载并通过安装程序运行：
- en: '**Windows**: [https://www.docker.com/docker-windows](https://www.docker.com/docker-windows)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Windows**: [https://www.docker.com/docker-windows](https://www.docker.com/docker-windows)'
- en: '**macOS**: [https://www.docker.com/docker-mac](https://www.docker.com/docker-mac)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**macOS**: [https://www.docker.com/docker-mac](https://www.docker.com/docker-mac)'
- en: As Docker is a rapidly evolving platform, always consult the official documentation
    in case there have been any changes since the time of writing.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Docker 是一个快速发展的平台，安装时请始终参考官方文档，以防自写作时以来发生了任何变化。
- en: 'If you''re installing Docker on a dedicated server or VPS, this can be done
    using the standard tools. For a CentOS 7 system, this is as simple as the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在专用服务器或 VPS 上安装 Docker，可以使用标准工具来完成。对于 CentOS 7 系统，操作非常简单，如下所示：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Those who are running Ubuntu, the commands are just as simple:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于运行 Ubuntu 的用户，命令同样简单：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This gives us a fully working Docker environment, even better if you have a
    local development installation and a staging/production system to test these recipes
    on.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了一个完全工作的 Docker 环境，如果你有本地开发安装和测试这些配置的预发布/生产系统，那就更好了。
- en: To familiarize yourself with Docker, we'll go through a few basic commands.
    The first is to simply run the `docker` command. This runs the Docker client and
    will spit out a list of commands that are available. If you see an error at this
    point, double-check the output from your installation or system logs.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了熟悉 Docker，我们将介绍一些基本命令。第一个命令是简单地运行 `docker` 命令。这将启动 Docker 客户端，并列出可用的命令。如果此时出现错误，请重新检查安装或系统日志中的输出。
- en: 'Next, let''s run `docker ps`, which will list all the containers:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们运行 `docker ps`，它将列出所有容器：
- en: '![](img/0d57b9d5-ed96-4207-aa74-a3133357da49.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0d57b9d5-ed96-4207-aa74-a3133357da49.png)'
- en: 'As this is a brand-new installation, you won''t see any listed here. Lastly,
    we can run `docker version` to list both the server and client versions:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个全新的安装，你此时不会看到任何列出的内容。最后，我们可以运行 `docker version` 来列出服务器和客户端的版本：
- en: '![](img/080f8fc9-7e42-4b6f-9261-4794ed0c7a38.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/080f8fc9-7e42-4b6f-9261-4794ed0c7a38.png)'
- en: While the Docker client can run on a different system to the Docker server (or
    Docker Engine as it can also be referred to as), you'll need to ensure that the
    versions are compatible.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Docker 客户端可以在与 Docker 服务器不同的系统上运行（也可以称为 Docker 引擎），但你需要确保它们的版本兼容。
- en: NGINX web server via Docker
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 Docker 部署 NGINX Web 服务器
- en: This recipe will step you through the basics of setting up a simple NGINX container
    via Docker. When you see the simplicity of the installation, don't be fooled by
    how easy it is, as that's the point of Docker.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 本指南将一步步引导你通过 Docker 设置一个简单的 NGINX 容器。当你看到安装的简便性时，不要被它的简单所迷惑，因为这正是 Docker 的优势所在。
- en: Getting ready
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: If you're already running existing Docker containers, make sure they're either
    stopped or are not running on port 80\. Otherwise, they will conflict with this
    recipe.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经在运行现有的 Docker 容器，请确保它们已经停止，或者不在端口 80 上运行。否则，它们将与这个配置冲突。
- en: How to do it...
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We''ll start by pulling down the latest image of Docker. While this is an optional
    step, it will allow you to see how Docker works in stages for the first time.
    To download the NGINX image (which for the officially packaged version is simply
    called `nginx`), run the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先拉取最新的 Docker 镜像。虽然这不是必须的步骤，但它将让你第一次看到 Docker 如何分步骤工作。要下载 NGINX 镜像（官方打包的版本叫做
    `nginx`），请运行以下命令：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will then pull down a number of images, each of which will display a series
    of unique image IDs, like the ones displayed in this example:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这将拉取多个镜像，每个镜像都会显示一系列独特的镜像 ID，就像这个示例中显示的那样：
- en: '![](img/2c89f2cc-f5e0-48a2-9c00-ab121372b76e.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2c89f2cc-f5e0-48a2-9c00-ab121372b76e.png)'
- en: 'Once our image has finished downloading, we can start creating our first container:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的镜像下载完成，我们就可以开始创建第一个容器：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If this works, you should get a single-line output, which will be the ID of
    the container:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成功，你应该会看到一行输出，那将是容器的 ID：
- en: '![](img/fd4b9592-b6ff-48f9-99d7-3abecaf09a67.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fd4b9592-b6ff-48f9-99d7-3abecaf09a67.png)'
- en: 'This indicates that the container has been created and started. If this is
    the first time you''re seeing a containerized system, less than a second setup
    may seem like a fault at first. However, that''s how quickly a container can be
    created and be up and running. To test the site, we can now browse the IP/hostname
    of where your Docker instance is running and connect to port `81` to confirm:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示容器已经创建并启动。如果这是你第一次看到容器化系统，那么不到一秒钟的设置可能一开始看起来像是故障。然而，这就是容器创建并启动的速度。为了测试站点，我们现在可以浏览
    Docker 实例所在的 IP 地址或主机名，并连接到端口 `81` 进行确认：
- en: '![](img/229b4fc3-c1a6-4be8-aa9f-ba7631ea556f.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/229b4fc3-c1a6-4be8-aa9f-ba7631ea556f.png)'
- en: How it works...
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Docker images are a layered format, which allows each layer to be reused between
    other images. This is to save on space, rather than having 20 instances of NGINX
    running on Ubuntu with all the system libraries duplicated. Docker will split
    these instances into layers so that you can have a singular base image, and each
    change to this is stored as a layer. Our NGINX image looks like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 镜像采用分层格式，这允许每一层在不同的镜像之间共享。这是为了节省空间，而不是让 20 个 NGINX 实例在 Ubuntu 上运行并重复所有系统库。Docker
    会将这些实例分解成多个层，这样你就可以有一个单一的基础镜像，任何对该镜像的修改都会作为一个新层进行存储。我们的 NGINX 镜像长这样：
- en: '![](img/730c825b-24fe-4fed-844a-18e61293db93.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/730c825b-24fe-4fed-844a-18e61293db93.png)'
- en: Each layer represents a change, and even the base image itself can be made up
    of multiple layers. Once you have a running container, any changes are then performed
    as **Copy-on-Write** (**COW**); this means the original images are preserved,
    while also allowing the ability to modify instances based on them.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 每一层代表一次更改，即使是基础镜像本身也可能由多个层组成。一旦你有了一个正在运行的容器，任何更改都会以 **写时复制** (**COW**) 的方式进行；这意味着原始镜像将被保留，同时也允许基于它们对实例进行修改。
- en: 'Our one-line deploy command can be broken down into a number of different parts:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的一行部署命令可以分解成多个不同的部分：
- en: '`run`: This tells Docker to create an instance and run the default command.
    As shown in the preceding figure, this is the `nginx` command to start NGINX.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`run`：这个命令告诉 Docker 创建一个实例并运行默认命令。正如前面的图示所示，这就是启动 NGINX 的 `nginx` 命令。'
- en: '`--name nginx-basic`: This gives our container a name, which allows you to
    easily identify and link to it from other containers.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--name nginx-basic`：这个选项给我们的容器指定一个名称，方便你从其他容器中轻松识别并链接它。'
- en: '`-d`: This option detaches the container from the command line and runs it
    in the background.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-d`：这个选项将容器从命令行中分离，并在后台运行。'
- en: '`-p 81:80`: Using `-p` specifies port mapping for the container. It''s always
    in this format: `<host>:<container>`. For our instance, we''ve opened port `81`
    on our server (or the development machine) and mapped it to port `80` in the container
    (where NGINX listens by default).'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-p 81:80`：使用 `-p` 指定容器的端口映射。格式始终是：`<host>:<container>`。对于我们的实例，我们在服务器（或开发机）上打开了端口
    `81`，并将其映射到容器中的端口 `80`（NGINX 默认监听的端口）。'
- en: '`nginx`: Finally, we specify the image name. This can also include a version
    tag, or it will select the latest release if no tag is specified. If we wanted
    to run an older version of NGINX, we could specify `nginx:1.9.14` to use the latest
    1.9 release.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nginx`：最后，我们指定镜像名称。这也可以包含一个版本标签，如果没有指定标签，它将选择最新版本。如果我们想运行 NGINX 的旧版本，我们可以指定
    `nginx:1.9.14` 来使用最新的 1.9 版本。'
- en: There's more...
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'Our initial example is fairly basic, but can be easily extended to serve static
    files. Rather than building an image with the files deployed, we can map a volume
    to the host in which Docker is on. This way, we can edit the files locally but
    still have them served from within the Docker container. Here''s our updated `run`
    command:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的初始示例相当基础，但可以很容易地扩展以提供静态文件。我们可以将一个卷映射到 Docker 所在主机上，而不是构建一个包含已部署文件的镜像。这样，我们可以在本地编辑文件，但仍然从
    Docker 容器内提供这些文件。下面是我们更新后的 `run` 命令：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Docker's filesystems use a union filesystem (for example, OverlayFS); this allows
    you to join two systems at a specified mount point. In our preceding example,
    we mounted `/var/static` on our local server and specified the mount point as
    `/usr/share/nginx/html`. We've also specified that the mount is read-only to prevent
    anything within the container from modifying the files.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 的文件系统使用联合文件系统（例如，OverlayFS）；这允许你在指定的挂载点连接两个系统。在我们之前的示例中，我们将 `/var/static`
    挂载在本地服务器上，并指定挂载点为 `/usr/share/nginx/html`。我们还指定该挂载是只读的，以防止容器内的任何内容修改文件。
- en: Changes to the files done within your local server (or the development machine)
    and in the `/var/static` directory will be served by our Docker instance.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地服务器（或开发机）和 `/var/static` 目录中对文件所做的更改将通过我们的 Docker 实例提供服务。
- en: This also means that you can keep your Docker configurations common between
    varying configurations and simply update the content separately. If you're especially
    using a **Revision Control System** (**RCS**) such as Git, it means you have a
    system that can be quickly updated via a **Continuous Integration** (**CI**) system.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着你可以在不同配置之间保持 Docker 配置的一致性，并且只需单独更新内容。如果你特别使用 **版本控制系统**（**RCS**），如 Git，这意味着你有一个可以通过
    **持续集成**（**CI**）系统快速更新的系统。
- en: See also
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参见
- en: 'Docker documentation: [https://docs.docker.com/](https://docs.docker.com/)'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 文档：[https://docs.docker.com/](https://docs.docker.com/)
- en: 'Official NGINX Docker hub entry: [https://hub.docker.com/_/nginx/](https://hub.docker.com/_/nginx/)'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方 NGINX Docker Hub 条目：[https://hub.docker.com/_/nginx/](https://hub.docker.com/_/nginx/)
- en: 'Official image build code: [https://github.com/nginxinc/docker-nginx](https://github.com/nginxinc/docker-nginx)'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方镜像构建代码：[https://github.com/nginxinc/docker-nginx](https://github.com/nginxinc/docker-nginx)
- en: NGINX reverse proxy via Docker
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NGINX 通过 Docker 进行反向代理
- en: In most scenarios, Docker will be deployed alongside an application container,
    such as Ruby on Rails, WordPress, or similar. In traditional deployment scenarios,
    these would all be configured on one server. However, in a Docker-based environment,
    you may want to reduce each container to a single task or process where possible,
    like a microservice-based architecture. This is so that you can independently
    upgrade or replace each part without affecting the other. An example of this is
    updating system libraries or deploying different PHP versions. As each task is
    a separate container, it remains isolated and, therefore, unaffected by other
    containers.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数场景中，Docker 会与应用容器一起部署，例如 Ruby on Rails、WordPress 或类似的应用。在传统的部署场景中，这些应用会配置在同一台服务器上。然而，在基于
    Docker 的环境中，你可能希望将每个容器简化为单一任务或进程，例如基于微服务的架构。这样你就可以独立升级或替换每个部分，而不会影响到其他部分。一个例子是更新系统库或部署不同版本的
    PHP。由于每个任务都是单独的容器，它们是隔离的，因此不会受到其他容器的影响。
- en: Using a reverse proxy on your local development server can also be a great way
    to test your application before deploying. Generally, if you have a basic WAMP
    (that is, Windows, Apache, MySQL, PHP) style development environment, then you
    may not discover unique issues, which only show when you have a proxy server that
    mimics your production environment.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地开发服务器上使用反向代理也是测试应用程序的一个好方法，尤其是在部署之前。通常，如果你有一个基础的 WAMP（即 Windows、Apache、MySQL、PHP）风格的开发环境，那么你可能不会发现一些只会在有反向代理服务器模拟生产环境时才会暴露的问题。
- en: Getting ready
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe assumes you have some form of web or application server running
    on your local server. Ideally, this could be *Dockerized* as well, but we'll cover
    both scenarios.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 该食谱假设你在本地服务器上运行了某种形式的 web 或应用服务器。理想情况下，这也可以是 *Docker 化* 的，但我们将同时涵盖这两种情况。
- en: 'Here''s how it''s going to look:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是大致的效果：
- en: '![](img/86bfb0f9-8748-456c-9031-c8ee32ed7554.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/86bfb0f9-8748-456c-9031-c8ee32ed7554.png)'
- en: As most real-world deployments are via HTTPS, we're also going to incorporate
    SSL certificate deployments.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 因为大多数实际部署都是通过 HTTPS 完成的，我们还将集成 SSL 证书的部署。
- en: How to do it...
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Because the standard NGINX image is perfect for more complex deployments, we're
    going to modify it to suit our needs. The great thing about Docker is that this
    process is very simple to do.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于标准的 NGINX 镜像非常适合更复杂的部署，我们将对其进行修改，以便满足我们的需求。Docker 的一个优点是，这个过程非常简单。
- en: 'Firstly, we''re going to create a Docker image definition file, which is called
    `Dockerfile`. This is what Docker uses to build an image, and it can reference
    an existing image as the base so that you don''t have to reinvent the wheel. Here''s
    our `Dockerfile`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个 Docker 镜像定义文件，称为 `Dockerfile`。Docker 使用此文件来构建镜像，并且它可以引用现有的镜像作为基础，以便不需要重新发明轮子。以下是我们的
    `Dockerfile`：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the same directory, we will also need our NGINX configuration file. As we
    want to override the default settings, we have called this `default.conf` so that
    it copies over the exiting file. Based on the *Configuring NGINX as a simple reverse
    proxy* recipe back in [Chapter 7](bc04362e-995f-4550-92b7-183754306d34.xhtml),
    *Reverse Proxy*, our configuration will look like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一目录下，我们还需要我们的 NGINX 配置文件。因为我们想要覆盖默认设置，所以我们将其命名为 `default.conf`，以便它可以覆盖现有文件。根据
    [第 7 章](bc04362e-995f-4550-92b7-183754306d34.xhtml)中 *配置 NGINX 作为简单的反向代理* 这一食谱，我们的配置将如下所示：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Lastly, we also need our SSL certificates and keys copied over as well. If you're
    intending to distribute this image or update the SSL certificates separately to
    the image, you can remove this from the image and use a volume mount to store
    the certificates on the local server.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还需要将 SSL 证书和密钥复制过来。如果你打算分发此镜像或单独更新 SSL 证书，你可以从镜像中移除这些内容，并使用卷挂载将证书存储在本地服务器上。
- en: If you need to generate a test SSL certificate, there's a quick guide available
    in [Chapter 4](ec61d6cb-64ef-4260-bb9d-d606dd47ebef.xhtml), *All About SSLs*.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要生成一个测试 SSL 证书，可以参考 [第 4 章](ec61d6cb-64ef-4260-bb9d-d606dd47ebef.xhtml)中的快速指南，*关于
    SSL 的一切*。
- en: 'Once you have all the configuration files ready, you can now tell Docker to
    build an image. It will store this image locally, based on the tags you provide.
    To create the image, run the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你准备好了所有配置文件，你就可以告诉 Docker 构建镜像。它会根据你提供的标签将此镜像存储在本地。创建镜像的命令如下：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Docker will then go through each of the steps in `Dockerfile` to produce a
    new image. Your output should look similar to this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 将按照 `Dockerfile` 中的每一个步骤来生成新的镜像。你的输出应该类似于以下内容：
- en: '![](img/6934f931-bd7d-48e1-aa04-81f4d84ebb2c.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6934f931-bd7d-48e1-aa04-81f4d84ebb2c.png)'
- en: 'We can see that, in the final output, our Docker image has been given the `b4007604b77e`
    ID. We can confirm this by viewing which Docker images we have installed:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，在最终输出中，我们的 Docker 镜像已经被赋予了 `b4007604b77e` ID。我们可以通过查看已安装的 Docker 镜像来确认这一点：
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following is the output listing our Docker image:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是列出我们 Docker 镜像的输出：
- en: '![](img/755d1e59-c389-4772-accb-e76611281518.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/755d1e59-c389-4772-accb-e76611281518.png)'
- en: Although there are a number of intermediate images, by default, Docker doesn't
    display them.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有许多中间镜像，但默认情况下，Docker 不会显示它们。
- en: 'After building and confirming that we have our Docker image, you can now deploy
    it:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建并确认我们已经有了 Docker 镜像之后，你可以开始部署它：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will create a container based on our new image, exposing port `443` via
    the server. Rather than being a bridged network (therefore using docker0), we
    tell NGINX to use the host's network.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这将基于我们的新镜像创建一个容器，通过服务器暴露`443`端口。与桥接网络（因此使用docker0）不同，我们告诉NGINX使用主机的网络。
- en: Currently, there's a longstanding issue with Docker for Mac accessing the host,
    based on the underlying OS limitation. For now, the easiest workaround is to only
    use container to container networking.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，Docker for Mac在访问主机时存在一个长期问题，这是由底层操作系统的限制引起的。现在，最简单的解决方法是只使用容器间的网络连接。
- en: This is best used for development only, as you're limited to only running one
    instance of each image due to the lack of port mapping.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这主要适用于开发阶段，因为由于缺乏端口映射，你只能运行每个镜像的一个实例。
- en: How it works...
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Within our `Dockerfile`, we define a number of steps to build the image:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`Dockerfile`中，我们定义了多个步骤来构建镜像：
- en: '`FROM`: This defines our starter image; for this recipe, we used `nginx:latest`.
    Rather than build the image from scratch, we simply start with the official NGINX
    image. If you want to manually install your own build, you could start with a
    base Linux, such as Debian or Alpine.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FROM`：这定义了我们的基础镜像；在这个例子中，我们使用的是`nginx:latest`。我们不是从头开始构建镜像，而是直接使用官方的NGINX镜像。如果你想手动安装自己的构建版本，可以从基础的Linux镜像开始，例如Debian或Alpine。'
- en: '`COPY`: In order to make the files part of the image, we can copy them as part
    of the build process. For this image, we''ve copied over our NGINX configuration
    file as well as the SSL certificates. If the files exist in the base image, they
    will simply be overwritten.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COPY`：为了将文件作为镜像的一部分，我们可以在构建过程中复制它们。对于这个镜像，我们已经复制了NGINX配置文件以及SSL证书。如果文件已经存在于基础镜像中，它们将被覆盖。'
- en: '`RUN`: We can issue commands within the build. In this instance, we symlink
    the default log files through to `/dev/stdout` and `/dev/stderr` so that we can
    view the logs from the standard Docker log tools.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUN`：我们可以在构建过程中发出命令。在这个例子中，我们将默认的日志文件通过符号链接方式连接到`/dev/stdout`和`/dev/stderr`，这样我们就可以通过标准的Docker日志工具查看日志。'
- en: '`EXPOSE`: In order to access network ports outside of the container, they must
    be exposed to the Docker networking subsystem. From here, they can be explicitly
    mapped using `-p` in the `docker run` command or implicitly mapped simply with
    `-P`.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EXPOSE`：为了访问容器外部的网络端口，必须将它们暴露给Docker网络子系统。之后，可以通过`docker run`命令中的`-p`明确映射，或者通过`-P`隐式映射。'
- en: '`CMD`: This defines the default command executed when the container starts.
    It''s set up in the format of `[''executable'', ''param1'', ''param2'']`, so for
    our NGINX command, it translates to `nginx -g daemon off;`. Because Docker requires
    the application to stay in the foreground, the `-g` option allows us to set an
    additional directive of daemon off to enforce this.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMD`：这定义了容器启动时执行的默认命令。它以`[''executable'', ''param1'', ''param2'']`的格式设置，对于我们的NGINX命令，它对应的是`nginx
    -g daemon off;`。因为Docker要求应用程序保持在前台运行，`-g`选项允许我们设置额外的指令“daemon off”来强制实现这一点。'
- en: There's more...
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The recipe wasn't about how production systems are deployed, as we were mixing
    host-deployed services with container-based ones. Most production deployments
    of Docker have 100 percent of services deployed within Docker containers, which
    simplifies networking.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例并不是讲解如何部署生产系统，因为我们混合使用了主机部署的服务和基于容器的服务。大多数生产环境中的Docker部署将100%的服务部署在Docker容器中，这简化了网络配置。
- en: 'In a typical production deployment, here''s what we might see:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的生产部署中，我们可能会看到这样的配置：
- en: '![](img/d301b5a2-2af4-4430-b6e6-9348c1cbcf30.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d301b5a2-2af4-4430-b6e6-9348c1cbcf30.png)'
- en: With everything containerized and isolated, we can still connect these without
    having to expose the ports to the world. Previously, this was called **linking**
    containers, and while the linking commands worked, they also had significant limitations.
    Instead, we now create distinct networks within the host.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将所有内容容器化和隔离，我们仍然可以在不将端口暴露给外界的情况下连接这些容器。之前，这种方式被称为**链接**容器，尽管链接命令有效，但也存在显著的限制。现在，我们通过在主机内创建独立的网络来代替。
- en: These networks allow containers to talk to each other in distinctly named networks
    and you can have multiple networks within one system without any issues. If you've
    previously used Docker and haven't moved to a version higher than 1.9, it's worth
    it for the improvements in this part alone.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这些网络允许容器在具有独特名称的网络中互相通信，并且在一个系统中可以有多个网络而不会出现问题。如果你之前使用过Docker，并且还没有升级到高于1.9的版本，那么仅仅为了这个部分的改进，升级是值得的。
- en: 'To allow two containers to talk to each other, we will first create a network:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让两个容器互相通信，我们首先需要创建一个网络：
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: I've named this network `webnet`, which will be between NGINX and the application
    only. In the preceding example, we can also create separate networks between the
    Rails application and PostgreSQL, then again for Rails and Redis. This level of
    isolation helps ensure there's no accidental data leakage if there is a security
    fault.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经将这个网络命名为 `webnet`，它将仅用于 NGINX 和应用程序之间。在之前的示例中，我们还可以为 Rails 应用程序与 PostgreSQL
    之间创建单独的网络，再为 Rails 和 Redis 创建单独的网络。这种级别的隔离有助于确保在出现安全故障时不会发生意外的数据泄漏。
- en: 'I have installed a Redmine container (which is a project management application
    based on Ruby on Rails), which will benefit from a reverse proxy in front to provide
    SSL termination. Because of the power of Docker, we can quickly deploy a Redmine
    server and automatically connect it to our `webnet` network:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经安装了一个 Redmine 容器（这是一个基于 Ruby on Rails 的项目管理应用程序），它将从前端的反向代理中受益，提供 SSL 终止。得益于
    Docker 的强大功能，我们可以快速部署一个 Redmine 服务器，并自动将其连接到我们的 `webnet` 网络：
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In order for NGINX to proxy the `redmine` container, first we''ll need to update
    the proxy configuration. When added to a network, Docker''s internal DNS server
    will automatically add the entry so that we can simply refer to the container
    by name. In the `default.conf`, update, the `proxy_pass` line will look like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 NGINX 代理 `redmine` 容器，首先我们需要更新代理配置。当容器加入到网络时，Docker 的内部 DNS 服务器会自动添加条目，这样我们就可以通过容器名称直接引用它。在
    `default.conf` 文件中更新，`proxy_pass` 行将变成如下：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As previously, we''ll need to rebuild our image and then run a container, this
    time linked to `webnet` instead of the host:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，我们需要重新构建镜像，然后运行一个容器，这次容器将与 `webnet` 网络连接，而不是与主机连接：
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When deploying the `nginx-proxy` image this time, we will also join it to the
    `webnet` network and then bind port `443` to the main host. Because the NGINX
    container is on the same network as the Redmine demo, it can explicitly access
    it via port `3000`, whereas the host server can''t. If you have everything configured
    correctly, you should see the proxied connection to Redmine:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这次部署 `nginx-proxy` 镜像时，我们还将其加入到 `webnet` 网络，并将端口 `443` 绑定到主机上。由于 NGINX 容器与 Redmine
    演示在同一网络上，它可以通过端口 `3000` 显式地访问 Redmine，而主机服务器则无法访问。如果你一切配置正确，你应该能看到代理连接到 Redmine：
- en: '![](img/26517725-3105-460f-9b6d-fe00b53fb4c9.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/26517725-3105-460f-9b6d-fe00b53fb4c9.png)'
- en: See also
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'macOS network limitation: [https://docs.docker.com/docker-for-mac/networking/#there-is-no-docker0-bridge-on-macos](https://docs.docker.com/docker-for-mac/networking/#there-is-no-docker0-bridge-on-macos)'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: macOS 网络限制：[https://docs.docker.com/docker-for-mac/networking/#there-is-no-docker0-bridge-on-macos](https://docs.docker.com/docker-for-mac/networking/#there-is-no-docker0-bridge-on-macos)
- en: '`Dockerfile` best practices: [https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/](https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/)'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dockerfile` 最佳实践：[https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/](https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/)'
- en: '`Dockerfile` reference: [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dockerfile` 参考：[https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)'
- en: 'Docker networking: [https://docs.docker.com/engine/userguide/networking/](https://docs.docker.com/engine/userguide/networking/)'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 网络：[https://docs.docker.com/engine/userguide/networking/](https://docs.docker.com/engine/userguide/networking/)
- en: Docker Compose with NGINX
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 NGINX 的 Docker Compose
- en: In our previous recipes, we deployed Docker containers in a singular fashion.
    While this is okay for smaller projects and testing, for production environments,
    ideally, we want this to be as repeatable as possible. This is where Docker Compose
    comes into the picture. Docker Compose is a tool that allows you to define multicontainer
    Docker applications for ease of management and ease of deployment. It does this
    via a single configuration file, which defines both the containers to deploy as
    well as the networking.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的教程中，我们以单一方式部署了 Docker 容器。虽然这种方式适用于小型项目和测试，但在生产环境中，理想情况下我们希望这能尽可能地可重复。这就是
    Docker Compose 出现的地方。Docker Compose 是一个工具，允许你定义多容器 Docker 应用程序，便于管理和部署。它通过一个单一的配置文件来实现，定义了要部署的容器以及网络设置。
- en: Getting ready
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Docker Compose is installed by default for all modern Docker installations.
    We'll take our Redmine deployment and convert it back into a one-command deployment
    process again.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose 默认会在所有现代的 Docker 安装中安装。我们将把 Redmine 部署转换回一个单命令的部署过程。
- en: How to do it...
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To get started, we need to create a `docker-compose.yml` file. This is in YAML
    format, which is a simple text-based language with a strong focus on readability.
    Here''s what our `docker-compose.yml` file looks like:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们需要创建一个`docker-compose.yml`文件。这是 YAML 格式的，它是一种简洁的文本语言，强调可读性。以下是我们的`docker-compose.yml`文件内容：
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is located in the same directory as `Dockerfile` and the previous NGINX
    configuration files we used. The directory naming is also important, as Docker
    Compose will use it to prepend the names of the containers it creates. For this
    recipe, I have the files located in the `composedemo` directory.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件位于与`Dockerfile`和我们之前使用的 NGINX 配置文件相同的目录中。目录命名也很重要，因为 Docker Compose 会使用它来在创建的容器名前加上目录名。对于这个配方，我将文件放在`composedemo`目录中。
- en: 'With our Docker Compose configuration file, we can now build and create the
    containers:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的 Docker Compose 配置文件，现在可以构建并创建容器了：
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This will firstly build our `nginx-proxy` image and then proceed to create
    all the containers. You should see an output like this as the containers start:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这将首先构建我们的`nginx-proxy`镜像，然后继续创建所有容器。当容器启动时，你应该会看到类似这样的输出：
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The naming is reflective of the configuration we used, where it prepends the
    directory name, adds the container name, and then appends a sequence number.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 命名方式反映了我们所使用的配置，它会在容器名前加上目录名，添加容器名，然后附加一个序列号。
- en: 'After the containers have been started, all the logs will output to the screen,
    and the containers will be running in the foreground. If you want to start it
    in the background, you can do this with the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 容器启动后，所有日志将输出到屏幕，容器将在前台运行。如果你想在后台启动容器，可以使用以下命令：
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This starts the containers in the background, much like our previous recipe.
    They can also be stopped with one command:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在后台启动容器，就像我们之前的配方一样。容器也可以通过一个命令停止：
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: With the ability to cleanly define the multicontainer deployments and then deploy
    with a single command, Docker Compose is an important part of the Docker ecosystem.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 通过能够干净利落地定义多容器部署，并通过一个命令进行部署，Docker Compose 是 Docker 生态系统中的重要组成部分。
- en: How it works...
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The YAML configuration file for Docker Compose has a number of elements in
    this recipe. Firstly, we define the version number (`version: ''3''`). This isn''t
    a revision number for the individual file, but tells Docker Compose what format
    to expect the configuration file in.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 'Docker Compose 的 YAML 配置文件包含了这个配方中的多个元素。首先，我们定义了版本号（`version: ''3''`）。这不是单个文件的修订号，而是告诉
    Docker Compose 配置文件的格式是什么。'
- en: Next, we define the network (`webnet`). By default, Docker Compose will create
    a separate network for all the containers, but we have explicitly named it in
    this recipe. The reason we do this is to retain compatibility with our previous
    recipe.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义网络（`webnet`）。默认情况下，Docker Compose 会为所有容器创建一个独立的网络，但我们在这个配方中显式地命名了它。我们这么做的原因是为了保持与之前配方的兼容性。
- en: Lastly, we define our services. The first is the `redmine` service, which we
    create from the `redmine` image. This is then added to the webnet network, and
    we also alias the name of the container. Again, this is to help maintain compatibility
    and reduce changes. While this isn't necessary to do, the reduction in changes—if
    you've come from a previous configuration—can help with diagnosing any issues.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义我们的服务。第一个是`redmine`服务，我们从`redmine`镜像创建该服务。然后，将其添加到`webnet`网络，并且我们还为容器设置别名。同样，这是为了帮助保持兼容性并减少变动。虽然这不是必须的，但如果你是从之前的配置过来，减少变动有助于诊断任何问题。
- en: The second service defined is our NGINX container, named `nginx-proxy`. Instead
    of using an image, we tell Docker Compose to build the container first from the
    current directory (`./`). Where we previously had to manually build and tag the
    image, Docker Compose does this automatically for us. We then map the host port
    `443` to the container port `443` and, like the Redmine service, we add it to
    the `webnet` network.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个定义的服务是我们的 NGINX 容器，命名为`nginx-proxy`。我们不使用镜像，而是告诉 Docker Compose 从当前目录（`./`）构建容器。之前我们需要手动构建并标记镜像，而
    Docker Compose 会自动为我们完成这一步。然后，我们将主机端口`443`映射到容器端口`443`，像 Redmine 服务一样，我们将其加入到`webnet`网络中。
- en: See also
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另见
- en: 'Docker Compose documentation: [https://docs.docker.com/compose/overview/](https://docs.docker.com/compose/overview/)'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Compose 文档：[https://docs.docker.com/compose/overview/](https://docs.docker.com/compose/overview/)
- en: 'Docker Compose file format: [https://docs.docker.com/compose/compose-file/](https://docs.docker.com/compose/compose-file/)'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Compose文件格式：[https://docs.docker.com/compose/compose-file/](https://docs.docker.com/compose/compose-file/)
- en: NGINX load balancing with Docker
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker进行NGINX负载均衡
- en: Once you've tackled the conversion from complex deploy scripts into neat `Dockerfile`,
    the next step is to deal with scale. As for most other problems, Docker has a
    solution for this too; scaling is one of those.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你解决了从复杂的部署脚本转换为简洁的`Dockerfile`的问题，下一步就是处理扩展问题。对于大多数其他问题，Docker也有解决方案；扩展正是其中之一。
- en: While newer versions of Docker have added native load balancing, it's still
    quite simplistic. This makes NGINX a better choice for many uses. Since you're
    already familiar with the workings of NGINX, it's easily adapted to provide load
    balancing within a Docker environment.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然较新的Docker版本增加了本地负载均衡，但它仍然相当简单。这使得NGINX成为许多应用场景下更好的选择。由于你已经熟悉NGINX的工作原理，它很容易被调整以在Docker环境中提供负载均衡。
- en: In a larger deployment, we'd use a more formal service discovery tool, such
    as `consul` or `etcd`, in order to provide more granular control. This recipe
    will simply use the built-in DNS capability of Docker in order to round-robin
    the requests.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在更大的部署中，我们会使用更正式的服务发现工具，例如`consul`或`etcd`，以提供更细粒度的控制。这个示例将仅使用Docker内置的DNS功能，以便进行轮询请求。
- en: Getting ready
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'This recipe has been simplified to run on a single VM. In most real-world scenarios,
    this would be spread across multiple VMs. Here''s what our test scenario looks
    like:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例已简化为只在单个虚拟机上运行。在大多数真实场景中，这将分布在多个虚拟机上。我们的测试场景如下：
- en: '![](img/65f03933-29ba-4248-b6cc-5a49d93f55b3.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/65f03933-29ba-4248-b6cc-5a49d93f55b3.png)'
- en: We're using the HTest tool, as covered back in [Chapter 8](4709da7c-9dbd-49d8-8fa7-c3fb6a9cdd6a.xhtml),
    *Load Balancing*, as the container we want to scale and load balance.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用HTest工具，正如在[第8章](4709da7c-9dbd-49d8-8fa7-c3fb6a9cdd6a.xhtml)《负载均衡》中介绍的那样，作为我们要扩展和负载均衡的容器。
- en: How to do it...
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'To deploy our load-balanced platform, first we''re going to create an NGINX
    container. Here''s our `default.conf`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了部署我们的负载均衡平台，首先我们要创建一个NGINX容器。以下是我们的`default.conf`：
- en: '[PRE19]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Additional files, such as the associated SSL certificates and `Dockerfile`,
    are also required.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要附加文件，如相关的SSL证书和`Dockerfile`。
- en: These are also available directly from GitHub at [https://github.com/timbutler/nginxcookbook](https://github.com/timbutler/nginxcookbook).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件也可以直接从GitHub获取：[https://github.com/timbutler/nginxcookbook](https://github.com/timbutler/nginxcookbook)。
- en: 'As we''re still using Docker Compose for the deployment, we''ll also need our
    updated `docker-compose.yml` configuration:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们仍然使用Docker Compose进行部署，因此我们还需要更新的`docker-compose.yml`配置：
- en: '[PRE20]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Again, this is quite similar to our previous recipe, as the structure of what
    we''re trying to achieve is quite similar. Once we have the configuration, we
    can now build and start our containers:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这与我们之前的示例非常相似，因为我们要实现的目标结构相当相似。一旦我们有了配置，接下来我们可以构建并启动容器：
- en: '[PRE21]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This will start both the `nginx` container as well as `htest`; it will also
    start the associated network. If successful, you should see an output like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动`nginx`容器和`htest`容器；它还会启动相关的网络。如果成功，你应该看到如下输出：
- en: '![](img/508b2b3e-efe5-4497-b22f-4e384fdf05f2.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/508b2b3e-efe5-4497-b22f-4e384fdf05f2.png)'
- en: 'By default, however, there''s only one instance of `htest` running. In order
    to scale this, we can simply tell Docker Compose how many instances we want to
    run. Here''s an example of this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，只有一个`htest`实例在运行。为了扩展规模，我们只需要告诉Docker Compose我们希望运行多少个实例。下面是一个示例：
- en: '[PRE22]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This will start an additional three `htest` containers:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动额外的三个`htest`容器：
- en: '![](img/ee88587e-08f0-487b-9cbb-9f571e722db8.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ee88587e-08f0-487b-9cbb-9f571e722db8.png)'
- en: Because we have NGINX set to call the proxy backend by its hostname, these are
    now called in a basic round-robin to each of the containers. If you browse to
    the site, you should see the counter for `htest` jumping around as each instance
    serves a request.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们设置了NGINX通过主机名调用代理后端，所以这些请求现在会以基本的轮询方式调用每个容器。如果你访问该网站，你应该会看到`htest`的计数器在跳动，因为每个实例都在处理请求。
- en: How it works...
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In our NGINX configuration (`default.conf`), we add the resolver directive (`resolver
    127.0.0.11 valid=1`) that directs NGINX to use the built-in Docker DNS resolver.
    In order to distribute the load, setting the validity to 1 means any TTL is ignored
    and the result only stays valid for 1 second.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的NGINX配置文件（`default.conf`）中，我们添加了`resolver 127.0.0.11 valid=1`指令，指示NGINX使用内置的Docker
    DNS解析器。为了分配负载，将有效期设置为1表示任何TTL都会被忽略，结果仅保持1秒钟有效。
- en: Then, we set the variable `$backend` to `http://htestbackend:8000`. The use
    of a variable ensures that it's evaluated each time in order to have the IP address
    updated.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将变量`$backend`设置为`http://htestbackend:8000`。使用变量可以确保每次都进行评估，从而更新IP地址。
- en: Within `Dockerfile`, we have set the alias for the `htest` container to `htestbackend`.
    Once we call the `scale` command, this starts three additional containers. Although
    a unique name is allocated to each container (for example, `loadbalancer_htest_1`),
    the alias ensures that there's a common name. This avoids having to rewrite the
    configuration of NGINX each time a new system is added, giving us the ability
    to add additional backends without reconfiguring them.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Dockerfile`中，我们为`htest`容器设置了别名为`htestbackend`。当我们调用`scale`命令时，它会启动三个额外的容器。尽管每个容器都会分配一个独特的名称（例如，`loadbalancer_htest_1`），但别名确保了它们有一个共同的名称。这避免了每次添加新系统时都需要重新编写NGINX配置文件，使我们能够在不重新配置的情况下添加额外的后端。
- en: See also
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另见
- en: 'NGINX `resolver` directive: [http://nginx.org/en/docs/http/ngx_http_core_module.html#resolver](http://nginx.org/en/docs/http/ngx_http_core_module.html#resolver)'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NGINX `resolver`指令：[http://nginx.org/en/docs/http/ngx_http_core_module.html#resolver](http://nginx.org/en/docs/http/ngx_http_core_module.html#resolver)
- en: 'To know more about the `docker compose scale` command: [https://docs.docker.com/compose/reference/scale/](https://docs.docker.com/compose/reference/scale/)'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 若要了解更多关于`docker compose scale`命令的信息：[https://docs.docker.com/compose/reference/scale/](https://docs.docker.com/compose/reference/scale/)
