<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Rewrites</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Redirecting non-www to www-based sites</li>
<li>Redirecting to a new domain</li>
<li>Blocking malicious user agents</li>
<li>Redirecting all calls to HTTPS to secure your site</li>
<li>Redirecting pages and directories</li>
<li>Redirecting <kbd>404</kbd> errors through a search page</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>The ability to rewrite URLs gives us a number of different abilities within NGINX. First and foremost, we can display neat URLs to the end user when we have a dynamically driven system such as WordPress. For example, instead of trying to remember <kbd>index.php?page_id=124</kbd>, we can simply use <kbd>/about/</kbd>.</p>
<p>Secondly, when we move content, change platforms, or update a system, we want to make sure all the old URLs still work. This is especially important for <strong>Search Engine Optimization</strong> (<strong>SEO</strong>), as well as for anyone who has your old page bookmarked.</p>
<p>In this chapter, we'll run through a number of recipes describing how to activate all of the common rewrites and also describing a few of these rewrites to provide great flexibility.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Redirecting non-www to www-based sites</h1>
                </header>
            
            <article>
                
<p>The debate about using a non-www prefixed URL versus including the www still rages on in the SEO world, but the key thing is to ensure there is consistency.</p>
<p>This means that if you choose to have the <kbd>www</kbd> prefix, then you'll want to ensure all URL calls are to this pattern. Especially since there are SEO implications involved with any URL change, attention to detail is critical here. For this recipe, we'll redirect all non-www to www-based calls, but the reverse is simply a matter of slightly modifying the rewrite rule.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>If you're used to the Apache way of doing things, this may look a little different. In the NGINX world, <em>if is evil</em> and needs to be avoided at all costs. Instead, we set one <kbd>server</kbd> block up for the non-www site and set it to redirect and a separate <kbd>server</kbd> block for the www-based site. Here's an example code:</p>
<pre>server { 
    listen       80; 
    server_name  redirect.nginxcookbook.com; 
    return       301  <br/>    http://www.redirect.nginxcookbook.com$request_uri; 
} 
 
server { 
    listen       80; 
    server_name  www.redirect.nginxcookbook.com; 
    location / { 
        root   /usr/share/nginx/html; 
        index  index.html index.htm; 
    } 
} </pre>
<p>Using the Chrome DevTools (or the equivalent), we can see the following sequence:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/d31e6386-07f0-4893-9ff5-de05026894ac.png"/></div>
<p>The original request to <kbd>redirect.nginxcookbook.com</kbd> sends a <kbd>301</kbd> to immediately load <kbd>www.redirect.nginxcookbook.com</kbd>. The browser then makes a request for this new URL, which, in the preceding example, responded with a HTTP 200.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this rewrite, we use a <kbd>301</kbd> HTTP call, which means that the URL has moved permanently. This indicates to any upstream system (be it a web crawler or proxy) that the change is final and not to look for the old URL. From an SEO perspective, this is critical, as any links or rankings applied to the old link should then be transferred to the new link.</p>
<p>The <kbd>$request_uri</kbd> variable passes the full URI, including arguments. This means that scenarios such as subdirectories (for example, <kbd>/about/</kbd>) as well as any arguments (for example, <kbd>id=123</kbd>) are redirected. This ensures that all bookmarks and direct links will remain working seamlessly after the change.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>Moz redirection: <a href="https://moz.com/learn/seo/redirection" target="_blank"><span class="URLPACKT">https://moz.com/learn/seo/redirection</span></a></li>
<li>NGINX redirect blog: <a href="https://www.nginx.com/blog/creating-nginx-rewrite-rules/" target="_blank"><span class="URLPACKT">https://www.nginx.com/blog/creating-nginx-rewrite-rules/</span></a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Redirecting to a new domain</h1>
                </header>
            
            <article>
                
<p>If a product or company decides to rebrand and rename, then one key part of this is to redirect the old domain to the new one. Even the top names such as Google (who started as BackRub) and eBay (who started as AuctionWeb) have had to go through this process, so it's more common than people realize.</p>
<p>In order to maintain all previous links and functionalities, ensuring all URLs are redirected to the new domain is critical. Thankfully, all that's required is a simple redirect with a rewrite to ensure that the full URL and all arguments are correctly sent to the new domain.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>As in the previous recipe, we need to have two distinct <kbd>server</kbd> blocks. Here's how to redirect the old site:</p>
<pre>server { 
    listen       80; 
    server_name  oldsite.nginxcookbook.com; 
    return       301 http://newsite.nginxcookbook.com$request_uri; 
} 
 
server { 
    listen       80; 
    server_name  newsite.nginxcookbook.com; 
    location / { 
        root   /usr/share/nginx/html; 
        index  index.html index.htm; 
    } 
} </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Like our non-www redirect, this recipe works in the same fashion. In fact, a redirect for a subdomain isn't functionally any different from a completely different domain altogether.</p>
<p>The return rule works just the same, where calls to subdirectories and all arguments are passed to the new domain without breaking their functionality. For example, using our preceding code, if we made a call to <kbd>http://oldsite.nginxcookbook.com/pages/?item=1951</kbd>, it would send a <kbd>301</kbd> redirect to <kbd>http://newsite.nginxcookbook.com/pages/?item=1951</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>While redirecting the domain fixes one part of the problem, you may need to make code changes as well. CMSes such as WordPress also need to have both the site URL and internal links updated as well. Make sure you consult the documentation for your respective application to ensure you take the necessary steps to migrate internal calls.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Blocking malicious user agents</h1>
                </header>
            
            <article>
                
<p>As the saying goes:</p>
<div class="packt_quote CDPAlignCenter CDPAlign"><em>"Just because you're not paranoid doesn't mean they aren't after you</em>."<br/>
                                                                                                   –Joseph Heller.</div>
<p>In the web world, hackers are continually scanning your servers and sites regardless of who you are and what sort of site you have. In 99 percent of all instances, they don't care who you are or what your site is, but only see how easily they can manipulate it to do what they want.</p>
<p>Even if you're 100 percent sure that your website is secure, you can save a lot of CPU cycles and potential <strong>Denial of Service</strong> (<strong>DOS</strong>) attacks by blocking these agents.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>The <kbd>server</kbd> block contains an <kbd>if</kbd> statement, which generally should be avoided, but it's necessary here. Performance wise, evaluating it for each call is necessary for interrogating the user agent anyway, so there's no degradation. In the following configuration, we'll drop out the bots we don't want to be able to access our site:</p>
<pre>server {
    listen       80;
    server_name  badbots.nginxcookbook.com;
    
    if ($http_user_agent ~ <br/>     (Baiduspider|Yandex|DirBuster|libwww|"")) {
        return 403;
     }
    
     location / {
         root   /usr/share/nginx/html;
         index  index.html index.htm;
     }
} </pre>
<p>This is of course, just a very small amount of user agents to block, but some of the more common. Ideally, you should keep the list small; the larger the list the larger the chance of blocking the wrong thing.</p>
<p>If we view the logs, we can see that the access has been blocked:</p>
<pre>106.74.67.24 - - [04/Sep/2016:22:24:03 +1000] "GET / HTTP/1.1" 403 571 "-" "libwww" "-"
106.74.67.24 - - [04/Sep/2016:22:24:03 +1000] "GET / HTTP/1.1" 403 571 "-" "libwww" "-"
106.74.67.24 - - [04/Sep/2016:22:24:03 +1000] "GET / HTTP/1.1" 403 571 "-" "libwww" "-"
106.74.67.24 - - [04/Sep/2016:22:24:04 +1000] "GET / HTTP/1.1" 403 571 "-" "libwww" "-"
106.74.67.24 - - [04/Sep/2016:22:24:04 +1000] "GET / HTTP/1.1" 403 571 "-" "libwww" "-"  </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Before our <kbd>location</kbd> block, we add an <kbd>if</kbd> statement to compare against the user agent. This ensures it's evaluated for every call. If your intent is to drop the CPU load by blocking malicious requests, it can be a good compromise.</p>
<pre>if ($http_user_agent ~ (Baiduspider|Yandex|DirBuster|libwww|"")) {
    return 403;
}  </pre>
<p>The tilde (<kbd>~</kbd>) performs a case-sensitive match against the user agent (<kbd>$http_user_agent</kbd>), and allows for a partial match. This means that if the user agent string contains <kbd>Yandex1.0</kbd> or <kbd>Yandex2.0</kbd>, both will still match the rule.</p>
<p>The list of blocked agents (<kbd>Baiduspider|Yandex|DirBuster|libwww|""</kbd>), uses the pipe (<kbd>|</kbd>) as an OR so that any of the strings can be matched. The double quotes at the end are there to block any system which doesn't report any user agent.</p>
<p>If you need complexity and more dynamic protection, then a proper <strong>Web Application Firewall</strong> (<strong>WAF</strong>) may be a better fit. A WAF has the ability to block other threats, such as SQL injection and <strong>Cross-site Scripting</strong> (<strong>XSS</strong>) as well.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>During the writing of this chapter, a site I manage was hit with over 200,000 malicious connections a minute and I needed these rules in place to ensure it remained operational. The attack was a WordPress pingback DOS attack, which exploits the fact that the WordPress pingback doesn't have a way of validating the return address. Since the site itself wasn't WordPress-based, we could simply block WordPress as the user agent:</p>
<pre>if ($http_user_agent ~ "WordPress") { 
    return 403; 
} </pre>
<p>With this rule in place, the site remained operational and the only negative issue was slightly increased traffic. The server was easily able to cope with the normal traffic and the rise in CPU usage was only minimal. Being able to turn a site which was completely offline back into an operational site within five minutes was a great outcome.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Redirecting all calls to HTTPS to secure your site</h1>
                </header>
            
            <article>
                
<p>Back in <a href="ec61d6cb-64ef-4260-bb9d-d606dd47ebef.xhtml" target="_blank"><span class="ChapterrefPACKT">Chapter 4</span></a>, <em>All About SSLs</em>, we covered installing and configuring an SSL certificate with NGINX. However, one thing we didn't cover was, ensuring that all calls to your site or application are always encrypted. This is especially critical if you're handling private data or payment information, which could be mandated by law to ensure the transmissions of the data is encrypted. Thankfully, enforcing HTTPS is simple to do.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Like our previous redirects, using two <kbd>server</kbd> blocks is the most efficient method:</p>
<pre>server { 
    listen 80; 
    server_name ssl.nginxcookbook.com; 
    return 301 https://ssl.nginxcookbook.com$request_uri; 
} 
 
server { 
    listen              443 ssl; 
    server_name         ssl.nginxcookbook.com; 
    ssl_certificate     /etc/ssl/public.pem; 
    ssl_certificate_key /etc/ssl/private.key; 
    ssl_protocols       TLSv1 TLSv1.1 TLSv1.2; 
    ssl_ciphers         HIGH:!aNULL:!MD5; 
 
    access_log  /var/log/nginx/ssl-access.log  combined; 
 
    location / { 
        root   /var/www; 
        index  index.html index.htm; 
    } 
} </pre>
<p>Here, we have our standard <kbd>server</kbd> block listening on port <kbd>80</kbd> and then redirecting all calls back to our calls to the HTTPS version. With the whole site redirected, even if there's a mistaken link to the HTTP version of the site, it will be automatically redirected.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>While a <kbd>server</kbd> block for each named site to redirect works perfectly, we can easily convert this back into a generic <kbd>server</kbd> block. This way, it's a simple configuration file between different sites and ensures that all other virtual servers on the same system also redirect.</p>
<pre>server { 
    listen 80 default_server; 
    server_name  _; 
    return 301 https://$server_name$request_uri; 
} </pre>
<p>Set <kbd>default_server</kbd> to the <kbd>server</kbd> block of any undefined server. The underscore (<kbd>_</kbd>) is simply a placeholder in NGINX; because we've set this <kbd>server</kbd> block to be the default, it will process all non-matching requests anyway. The underscore simply makes it easy to view.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p>The NGINX <kbd>server_name</kbd> documentation: <a href="http://nginx.org/en/docs/http/server_names.html" target="_blank"><span class="URLPACKT">http://nginx.org/en/docs/http/server_names.html</span></a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Redirecting pages and directories</h1>
                </header>
            
            <article>
                
<p>One of the most common uses of rewrites is to automatically redirect a URL from an old platform to your new site. If you've ever changed your platform (for example, moved from a proprietary system to WordPress or similar), then you'll have a large amount of existing links which will already be bookmarked and ranked within Google.</p>
<p>Like our <kbd>404</kbd> recipe, many modern CMSes can do this, but most can't do it with the efficiency that NGINX can. Anything which can reduce the server load on a production system is always a good thing, especially if you have a very busy site.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>The following are a number of quick references to redirect your page or directory.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Single page redirect</h1>
                </header>
            
            <article>
                
<p>If you've moved a page or have a new CMS, you can redirect each page using the following:</p>
<pre>rewrite ^/originalpage/$ /newpage/ redirect; </pre>
<p>This simply has to be within your <kbd>server</kbd> block directive. It's important to note that the syntax needs to be an exact match. In the preceding example, if you called the URL without the trailing slash, it would fail to redirect. We can account for both these scenarios by modifying the <kbd>rewrite</kbd> directive quickly:</p>
<pre>rewrite ^/originalpage/?$ /newpage/ redirect; </pre>
<p>As explained in detail later, this means that the trailing slash is now optional, so that both call to <kbd>/originalpage</kbd> and <kbd>/originalpage/</kbd> will now both redirect.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Full directory redirect</h1>
                </header>
            
            <article>
                
<p>If you want everything within a whole directory to redirect, this can also be easily covered with one line:</p>
<pre>rewrite ^/oldproduct/?(.*)$ /newproduct/$1 redirect; </pre>
<p>Again, this needs to go within your existing <kbd>server</kbd> block directive. While similar to the single page, there are a few key differences. First, we add a subexpression (<kbd>.*</kbd>), which we then pass to the new URL as a variable (<kbd>$1</kbd>).</p>
<p>For example, if we call the <kbd>/oldproduct/information</kbd> URL, it will redirect to <kbd>/newproduct/information</kbd>. This will match anything in the URL, so if you have parameters in the call (for example, <kbd>id=1</kbd>), these will also be passed to the new URL.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The rewrite rules use <strong>Perl Compatible Regular Expressions</strong> (<strong>PCRE</strong>), which is a pattern matching system for textual content. While the more complex scenarios can be quite complex to read, you can quickly grasp the basics by understanding the basics of the syntax. Here's a reference table:</p>
<table class="table" style="width: 845px;height: 825px">
<tbody>
<tr>
<td>
<p><strong>Syntax</strong></p>
</td>
<td>
<p><strong>Meaning</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>^</kbd></p>
</td>
<td>
<p>The start of the string to match</p>
</td>
</tr>
<tr>
<td>
<p><kbd>$</kbd></p>
</td>
<td>
<p>The end of the string to match</p>
</td>
</tr>
<tr>
<td>
<p><kbd>.</kbd></p>
</td>
<td>
<p>Any character (except newline)</p>
</td>
</tr>
<tr>
<td>
<p><kbd>\d</kbd></p>
</td>
<td>
<p>Any digit</p>
</td>
</tr>
<tr>
<td>
<p><kbd>\D</kbd></p>
</td>
<td>
<p>Any non-digit</p>
</td>
</tr>
<tr>
<td>
<p><kbd>\w</kbd></p>
</td>
<td>
<p>Word, meaning letters, digits, and underscore (<kbd>_</kbd>)</p>
</td>
</tr>
<tr>
<td>
<p><kbd>*</kbd></p>
</td>
<td>
<p>Zero or more of the previous expression</p>
</td>
</tr>
<tr>
<td>
<p><kbd>+</kbd></p>
</td>
<td>
<p>One or more of the previous expression</p>
</td>
</tr>
<tr>
<td>
<p><kbd>?</kbd></p>
</td>
<td>
<p>Zero or one of the previous expression</p>
</td>
</tr>
<tr>
<td>
<p><kbd>()</kbd></p>
</td>
<td>
<p>Group the expression to allow the subexpression to be used separately</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>These are just the basics, but it does allow a very rapid understanding of the more simplistic rules. The following table has a number of quick examples of a match against the <kbd>/oldproduct/show.php?id=1</kbd> string:</p>
<table class="table">
<tbody>
<tr>
<td>
<p><strong>Rule</strong></p>
</td>
<td>
<p><strong>Meaning</strong></p>
</td>
<td>
<p><strong>Match</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>^.*$</kbd></p>
</td>
<td>
<p>This matches everything on a line</p>
</td>
<td>
<p><kbd>/oldproduct/show.php?id=1</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>^/oldproduct/$</kbd></p>
</td>
<td>
<p>This looks for a string which must be exactly <kbd>/oldproduct/</kbd></p>
</td>
<td>
<p>No match</p>
</td>
</tr>
<tr>
<td>
<p><kbd>^/oldproduct/</kbd></p>
</td>
<td>
<p>This looks for a string which must start with <kbd>/oldproduct/</kbd> but only matches that phrase</p>
</td>
<td>
<p><kbd>/oldproduct/</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>^/oldproduct.*</kbd></p>
</td>
<td>
<p>This looks for a string which must start with <kbd>/oldproduct/</kbd> and also matches everything after that</p>
</td>
<td>
<p><kbd>/oldproduct/show.php?id=1</kbd></p>
</td>
</tr>
<tr>
<td>
<p><kbd>\w+\.php</kbd></p>
</td>
<td>
<p>This looks for any letters, numbers, or underscores and match at least 1 ending in <kbd>.php</kbd></p>
</td>
<td>
<p><kbd>show.php</kbd></p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Unless you do it day in and day out, don't expect to have your regular expression work perfectly the first time. There are a number of handy tools online (such as <a href="http://regex101.com" target="_blank"><span class="URLPACKT">regex101.com</span></a>), which allows you to test your expressions and give a detailed feedback. For complex scenarios, these tools are critical and allow detailed testing before adding the rules to a live server.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p>The regular expression test tool: <a href="https://regex101.com/" target="_blank"><span class="URLPACKT">https://regex101.com/</span></a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Redirecting 404 errors through a search page</h1>
                </header>
            
            <article>
                
<p>If you have moved URLs or have an incorrect link to your site, it will generally generate a <kbd>404 Not Found</kbd> error to the browser. While you can also style this page to make it match the site, the end result is generally the same. If a user hits this link, either way, they won't find the content they were originally searching for.</p>
<p>With a small amount of trickery, we can instead turn the <kbd>404</kbd> into search parameters to push through to your site. This way, you can either match the page or item the user was looking for or at least display the best guesses for them.</p>
<p>While most modern CMSes either have this functionality built in or have a plugin to handle it for you, if you're stuck with an older system or custom coded site, then you can quickly add this functionality.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>In order to convert the <kbd>404</kbd> requests into arguments, here's our <kbd>server</kbd> directive:</p>
<pre>server { 
    listen       80; 
    server_name  demosite.nginxcookbook.com; 
 
    access_log  /var/log/nginx/demosite.access.log  combined; 
    index index.php; 
 
    root   /var/www/vhosts/demosite; 
 
    error_page 404 @404page; 
 
    location @404page { 
        try_files $uri $uri/ /search.php?uri=$uri&amp;$args; 
    } 
 
    location ~ \.php$ { 
        fastcgi_pass unix:/var/run/php7.0-fpm.sock; 
        fastcgi_index index.php; 
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; 
        include fastcgi_params; 
 
        try_files $uri $uri/ /search.php?uri=$uri&amp;$args; 
    } 
} </pre>
<p>In this <kbd>server</kbd> block, we've assumed that the site uses PHP, but static files with a search file just for the <kbd>404</kbd> errors will also work.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>For our <kbd>404</kbd> errors, we override the default NGINX 404 page to a custom location (<kbd>error_page 404 @404page;</kbd>). The reason we need to use a custom location is so that we can rewrite the URI and arguments.</p>
<p>Within our <kbd>@404page</kbd> location, we rewrite the URI and arguments to the search page (<kbd>/search.php?uri=$uri&amp;$args</kbd>), so that they can be used as variables. For example, if we make a call to <kbd>/oldpage/index.asp?id=44</kbd>, it will send this to <kbd>/search.php</kbd> as the following variables:</p>
<ul>
<li><kbd>[uri] =&gt; /oldpage/index.asp</kbd></li>
<li><kbd>[id] =&gt; 44</kbd></li>
</ul>
<p>Lastly, we also include a <kbd>try_files</kbd> call to ensure that any missing PHP files are also rewritten to the <kbd>search.php</kbd> file.</p>
<p>The <kbd>search.php</kbd> file could include the ability to have a lookup table or it could incorporate a database search to do a fuzzy search and either automatically redirect or simply present options to the user.</p>


            </article>

            
        </section>
    </body></html>