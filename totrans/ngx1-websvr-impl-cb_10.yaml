- en: Chapter 10. Some More Third-party Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a fair load balancing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up health checks for backend servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tracking and reporting file upload progress
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating circles for round edges using Nginx
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running Python using Phusion Passenger
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating graphs directly from RRDtool in Nginx
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Google performance tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serving content directly from GridFS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Basic HTTP auth using PAM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Basic HTTP auth using Kerberos
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter looks at various web situations such as load balancing, server
    health checks, and more which will be very useful in a production environment.
    These simple recipes will be highly applicable in enterprise scenarios where you
    may need to have analytics, external authentication schemes, and many other situations.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a fair load balancing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nginx by default uses a round robin mechanism to proxy requests to its backend
    servers. Most of the time this is sufficient, as the machines on the backend are
    usually of the same build and configuration, but in many cases it necessary to
    implement a fair load. This balance takes into account the existing load on a
    machine before its proxies the requests. This is where the Nginx fair scheduler
    plugin comes in. It enables the system administrator to configure fair scheduling
    and allows the backend machines to be of dissimilar performance, and yet the whole
    system will perform optimally.
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring a fair load balancing](img/4965OS_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will first download the plugin, install it, and then configure it in the
    steps described ahead.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will first install the fair scheduling module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will then put the following in our Nginx configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need to restart Nginx to see the changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This module lets you configure a weighted least connection round robin mechanism,
    which keeps track of the real-time load on each individual backend server to make
    a decision on whom to proxy it to.
  prefs: []
  type: TYPE_NORMAL
- en: The module also allows you to track the load on each server by visiting a web
    page; this can be easily integrated into your web infrastructure monitoring systems.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can also configure the module to handle the following scheduling cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Modes | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Default | This lets us configure the simple weighted least-connection round
    robin, which basically means you give the request to the server with the least
    active connections in a round-robin fashion. This is the default mode explained
    in the preceding example. |'
  prefs: []
  type: TYPE_TB
- en: '| no_rr | This disables round robin, which would be applicable in cases where
    we may be spawning multiple backends depending on your load. It will ensure that
    Nginx uses as many backends as it needs. |'
  prefs: []
  type: TYPE_TB
- en: '| weight_mode=idle no_rr | This mode attempts to balance the load between the
    minimum pool of backend servers. It can help us identify the actual number of
    backend servers. |'
  prefs: []
  type: TYPE_TB
- en: '| weight_mode=peak | In this mode, Nginx will not send requests to the backend
    beyond a certain limit. If all the backends are full the client will receive a
    502 error. |'
  prefs: []
  type: TYPE_TB
- en: 'The following diagram shows a scenario how servers respond when they are busy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more…](img/4965OS_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Chapter 7](ch07.html "Chapter 7. Nginx as a Reverse Proxy"), *Setup load balancing
    with reverse proxy*'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up health checks for backend servers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most important aspects of running a fairly large Internet site is
    the ability to understand the health of your machines. In huge server farms, it
    is not physically possible to inspect the health of the machines one by one, or
    for that matter to detect which backend server is down.
  prefs: []
  type: TYPE_NORMAL
- en: To solve this problem, Nginx has a neat module which will let you run a regular
    check on all the backend servers and mark them as bad when they do not behave
    accordingly. Marking them as bad ensures that the end client's request never gets
    sent to the backend server with issues by Nginx. There are very little performance
    overheads as Nginx maintains all the health check numbers in memory.
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up health checks for backend servers](img/4965OS_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will first install the Nginx backend health module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will then put the following in the configuration files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, restart Nginx to see the changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This module makes a query to the backend servers every minute and then updates
    the status of every backend server. This was achieved with the `healthcheck_enabled`
    and `healthcheck_delay` directives.
  prefs: []
  type: TYPE_NORMAL
- en: We have enabled the health check status page as well, so we can check out the
    status of the backend server by visiting [http://www.example1.com/backend_status](http://www.example1.com/backend_status).
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/4965_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tracking and reporting file upload progress
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: File uploading is one of the most common activities on a website. It is achieved
    by making a multi-part POST submission, which does not allow you to track the
    progress of the file upload. So if your user is uploading a fairly large file,
    he expects to be notified about the speed of upload and the time it will take.
    To ensure that the user is aware, there is a module that helps us track how far
    the file has been uploaded to the server.
  prefs: []
  type: TYPE_NORMAL
- en: '![Tracking and reporting file upload progress](img/4965_10_05b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will first install the plugin, and then see how to configure it in the following
    steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will first install the Nginx file upload progress module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will use the following in our Nginx configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A restart of Nginx will apply those changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This configuration basically sets up a 1MB cache to keep track of the uploaded
    file status. Every file uploaded should be assigned a tracking ID, using which
    one can query `http://www.example1.com/progress` to find out how much of the file
    has uploaded till now. It can return a lot of formats based on how we have configured
    the module output; in this example it will output JSON by default.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that to track the file progress we will need to append
    an X-Progress-ID, which will uniquely identify the file being uploaded.
  prefs: []
  type: TYPE_NORMAL
- en: Generating circles for round edges using Nginx
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The latest in Internet aesthetics are rounded edges, and clearly Nginx is not
    going to be left behind. This recipe has a look at an interesting module that
    allows you to generate dynamic circles, which we can easily utilize for creating
    round edge styles. This is most applicable when you need to support rounded edges
    on older browsers that are not compatible with CSS3.
  prefs: []
  type: TYPE_NORMAL
- en: '![Generating circles for round edges using Nginx](img/4965_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will first install the plugin and then configure it in the following steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will first need to install the Nginx Circle GIF module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will then use the following in our Nginx configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, restart Nginx to see the changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Configuring this module is simply adding a new URL endpoint, which will act
    as a web API to generate the gif. The format of the URL is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<background color>/<foreground color>/<radius>.gif`'
  prefs: []
  type: TYPE_NORMAL
- en: 'So the following URL will generate a black on white circle of radius 10 pixels.
    We can use this to generate the rounded corner styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://www.example1.com/circles/ffffff/000000/10.gif`'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/4965_10_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Running Python using Phusion Passenger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nginx's primary purpose, to act as a state-of-art web and mail proxy server,
    has curtailed its image as that of an all-purpose server, of which it is fully
    capable. We will have a look at how can we run Python applications with Phusion
    Passenger as the backend.
  prefs: []
  type: TYPE_NORMAL
- en: '![Running Python using Phusion Passenger](img/4965_10_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will first install all the dependencies required to install Phusion Passenger
    and then configure Nginx with it in the following steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will first install Ruby:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to install `rubygems`, which is the package management tool for Ruby:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will install rails and Passenger Phusion:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will install the Passenger Phusion Nginx module, as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it…](img/4965_10_09.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The following configuration is used in nginx.conf and it assumes that the application
    is placed at `/var/www/www.example1.com/`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, a Nginx restart should let you see all the changes at work.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Phusion Passenger is a very easy way to deploy production application in Rails,
    which is a web framework in Ruby. It is also very efficient at deploying Python
    (WSGI) applications. In this recipe, we have gone ahead and set up a small Python
    web script to demonstrate this capability.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Chapter 6](ch06.html "Chapter 6. Setting Up Applications: FCGI and WSGI Modules"),
    *Setting up a Python site using uWSGI*'
  prefs: []
  type: TYPE_NORMAL
- en: Generating graphs directly from RRDtool in Nginx
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A lot of sites today show analytics as a part of their offering. The most common
    form of analytics representation is the time-based graphs, which are very efficiently
    generated by RRDtool, which is a really good open source graph generation tool.
    In this recipe, we will explore a module that will create a web API that you can
    dynamically call to get your graphs.
  prefs: []
  type: TYPE_NORMAL
- en: '![Generating graphs directly from RRDtool in Nginx](img/4965_10_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will first install the plugin and then configure it in the following steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will install the Nginx RRDtool module; it assumes that you have already
    installed RRDtools:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will then use the following in our configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, restart Nginx to see the changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This set up is easy to demonstrate. Let''s say that we want to generate a graph
    using the following set of commands in the RRDtool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You can generate the following URL, which will return the preceding graph, but
    it will appear as a web URL which will simplify your life drastically. This URL
    contains the preceding code in an URL encoded format appended to the `http://www.example1.com/rrd_gen`
    URL.
  prefs: []
  type: TYPE_NORMAL
- en: '`http://www.example1.com/rrd_gen--start%20now-300s%20--end%20now%20DEF%3Ads0%3Dtest.rrd%3Areading%3AAVERAGE%20LINE1%3Ads0%2300FF00`'
  prefs: []
  type: TYPE_NORMAL
- en: Using Google performance tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The more experienced Nginx user may actually need to look into limitations of
    the Nginx platform, in those cases libraries such as Google performance tools
    make life very easy for the developers. We will look at setting up the Google
    performance tools module in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Google performance tools](img/4965OS_10_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will first install the plugin and then configure it in the following steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will first install the Google performance Nginx module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the following in your configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will need to restart Nginx to see the changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This simple directive will let us profile our worker threads. The generated
    profile files are defined by the `google_perftools_profiles` directive, and this
    configuration will generate files such as `log/profile.<pid>` where `pid` is the
    process ID of the worker thread whose profiling information it is.
  prefs: []
  type: TYPE_NORMAL
- en: Serving content directly from GridFS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GridFS is a specification for storing large files in MongoDB. It basically aims
    to split down files into smaller chunks which are easily manageable, and allows
    efficient range operations. We will have a look at how we can configure Nginx
    to serve content directly from GridFS, thereby creating a situation where you
    can manage all your large files through GridFS and serve them using Nginx.
  prefs: []
  type: TYPE_NORMAL
- en: '![Serving content directly from GridFS](img/4965OS_10_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will first install the plugin and then configure Nginx in the following steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'This recipe assumes that you have installed GridFS. We will install the Nginx
    gridFS module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will put the following in our Nginx configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, restart Nginx to check out the changes. Do make sure that GridFS is running
    before you test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The configuration above enables the GridFS on a MongoDB database called `my_app`,
    with the username password as foo and bar respectively. Any call made like `http://www.example1.com/gridfs/123/`
    will return the corresponding file from the *pic* collection with the ID 123.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/4965OS_10_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Configuring Basic HTTP auth using PAM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nginx supports HTTP authentication, and as we have seen in earlier recipes,
    we can generate `htpasswd` files which contain the valid username and passwords.
    However, most systems have an existing authentication system that already integrates
    with PAM, and Nginx has a plugin that already lets you authenticate with PAM.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PAM is a mechanism that integrates low-level authentication schemes into high
    level programming API, thus all your programs can operate independently to how
    your login system operates.
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring Basic HTTP auth using PAM](img/4965OS_10_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The recipe describes a situation where you want to protect `http://www.example1.com/downloads`
    and ensure that only LDAP authenticated users can access that part of the site.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will first install the PAM authentication model and then configure Nginx
    in the following steps.
  prefs: []
  type: TYPE_NORMAL
- en: We will first install the Nginx PAM auth module. This recipe assumes that you
    have an already configured and working LDAP setup.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will then put the following in our Nginx configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will need to put the following in `/etc/pam.d/nginx:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, you will need to restart your Nginx server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This module basically utilizes PAM as the top level API to access the LDAP authentication
    structures. It first enables the authentication in the necessary location, which
    is `/downloads` in this case. Then we set up a PAM service called Nginx, that
    basically utilizes the PAM LDAP libraries to complete the authentication.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/4965_10_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Configuring Basic HTTP auth using Kerberos
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are using Windows based systems in a heterogeneous environment, in all
    probability you must use Kerberos as your authentication protocol. In situations
    where we are deploying a site internally it may be useful to handle web authentication
    with Kerberos. Nginx has the solution for this, as it has a module that lets you
    authenticate the user using Kerberos.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will take a look at how you can protect a particular web location
    using HTTP authentication using Kerberos as the backend. This is a highly experimental
    plugin, and only useful when you do not have an alternative to this form of authentication
    in your network.
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring Basic HTTP auth using Kerberos](img/4965OS_10_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we first install the plugin and then configure Nginx to use
    it in the following steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will first install the Nginx Kerberos module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we will configure the module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Restart Nginx for the changes to take effect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This module defines the realm name, and then we will need to define the location
    of the service credentials. Finally, we set up the service that you use to acquire
    the credentials.
  prefs: []
  type: TYPE_NORMAL
- en: There are some assumptions that the preceding configuration makes. Your Nginx
    web server should be in the same broadcast scope of the Kerberos server and so
    should the client, who will be authenticated to that server.
  prefs: []
  type: TYPE_NORMAL
- en: In another scenario, it is possible that you already have PAM with Kerberos
    support set up on your server. In this case you can use the preceding recipe to
    set up PAM with Kerberos.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Configuring basic HTTP auth using PAM* recipe, in this chapter
  prefs: []
  type: TYPE_NORMAL
