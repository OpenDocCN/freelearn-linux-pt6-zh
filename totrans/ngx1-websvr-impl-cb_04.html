<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Slow Them Down: Access and Rate Limiting Module"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Slow Them Down: Access and Rate Limiting Module</h1></div></div></div><p>In this chapter, we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Limiting requests for any given session</li><li class="listitem" style="list-style-type: disc">Blocking and allowing access using IP</li><li class="listitem" style="list-style-type: disc">Setting up simple rate limiting for a download directory</li><li class="listitem" style="list-style-type: disc">Rate limiting search engine bots</li><li class="listitem" style="list-style-type: disc">Setting up GeoIP using the MaxMind country database</li><li class="listitem" style="list-style-type: disc">Using the GeoIP module to set up access and rate control</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec01"/>Introduction</h1></div></div></div><p>In this day and age of the Internet, the user is extremely sensitive about the quality of service they get from their online services. There are a lot of small companies with few resources that are able to capture a part of the market by innovating rapidly. Such companies eventually have to rate limit, as inevitably they have more traffic than their servers can handle.</p><p>Something as simple as getting "digged" (<a class="ulink" href="http://www.digg.com">http://www.digg.com</a>) or "slashdotted" (<a class="ulink" href="http://www.slashdot.org">http://www.slashdot.org</a>) used to bring down sites, but Nginx provides good protection against situations like this by providing rate limiting and server access based on IP.</p></div></div>
<div class="section" title="Limiting requests for any given session"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec02"/>Limiting requests for any given session</h1></div></div></div><p>Due to its event driven nature, Nginx is being adopted all over the world whenever one needs performance with resource constraints. However, in a lot of situations, that is not enough and the only way is to limit request to ensure that your site is up and your server does not suffer any downtime.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec01"/>How to do it...</h2></div></div></div><p>The following configuration, when applied within a server directive, allows you to limit requests for a given session:<a class="indexterm" id="id107"/>
</p><div class="informalexample"><pre class="programlisting">http {
limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s;
...
Server {
limit_req zone=one burst=5;
...
}
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec02"/>How it works...</h2></div></div></div><p>The<code class="literal"> limit_req_zone</code> directive basically allows you to define what variable (in this case<code class="literal"> $binary_remote_addr)</code> to act as the key of the sessions, in addition to allocating 10MB for this "zone" and limiting the rate to one request per second. There are no limits to the number of zones one can set up, as long as you have the memory to handle the zone allocations. A given zone which uses, say, the remote address as the key for the session, will be able to handle about 32,000 sessions in 1M of session memory allocated to it.</p><p>In the<code class="literal"> server</code> directive, we actually do the request rate limiting by using the<code class="literal"> limit_req directive</code>, which basically uses zone one, which allows no more than an average of one request per second with a maximum burst rate of five requests.</p><p>Any request that is beyond the rate capacity will receive a "Service unavailable" 503 error page.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec03"/>There's more...</h2></div></div></div><p>You can use other variables to act as the session key, but it is important to note that the session key variable size must be small to accommodate all the incoming connections (that is total connections x session value size &lt; size of session cache).</p></div></div>
<div class="section" title="Blocking and allowing access using IP"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec03"/>Blocking and allowing access using IP</h1></div></div></div><p>One of the most important things that a site needs to do is to blacklist some malicious IPs that over time try to probe and cause harm to your site. This can be done at multiple levels like the router, and even at the software firewall level which will also drive away this unnecessary load from Nginx. If you do not have enough control on your stack, then Nginx is the best place to start blocking those bots and hackers.<a class="indexterm" id="id108"/>
</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec04"/>How to do it...</h2></div></div></div><p>This lets you block some IPs from accessing your site:</p><div class="informalexample"><pre class="programlisting">server {
listen 80;
server_name www.example1.com;
location / {
deny 192.168.1.1;
allow 192.168.1.0/24;
deny all;
}
...
}
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec05"/>How it works...</h2></div></div></div><p>It is clear that the<code class="literal"> deny</code> and<code class="literal"> allow</code> directives are in sequence, so it will deny the IP 192.168.1.1 while it allows the network 192.168.1.0/24 to access. A final<code class="literal"> deny all</code>; directive makes sure that no other IP can access this location (<code class="literal">http://www.example1.com</code>).<a class="indexterm" id="id109"/>
</p><p>So all other IPs, when they try to access this HTTP location, will get a 403 forbidden page. You can use the<code class="literal"> error_page</code> directive to rewrite this to a 404 page.</p></div><div class="section" title="There's more...."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec06"/>There's more....</h2></div></div></div><p>It is important to realize that the sequence of the directives is critical. Something like:</p><div class="informalexample"><pre class="programlisting">server {
listen 80;
server_name www.example1.com;
location / {
deny all; # this is not a good idea
deny 192.168.1.1;
allow 192.168.1.0/24;
}
...
}
</pre></div><p>Will give a 403 forbidden to all the clients that open the location (<code class="literal">http://www.example1.com</code>).</p></div></div>
<div class="section" title="Setting up simple rate limiting for a download directory"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec05"/>Setting up simple rate limiting for a download directory</h1></div></div></div><p>We have looked at ways to rate limit requests, but sometimes the issue is that some clients start to hog the bandwidth and pull down the quality of service for the other users. In such scenarios, it is best to use bandwidth based rate limiting.<a class="indexterm" id="id110"/>
</p><p>The best application of something like this is with the static files on your site. It ensures that no one leeches your bandwidth for the wrong reasons.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec07"/>How to do it...</h2></div></div></div><p>The following simple configuration in the server directive will allow you to rate limit the whole site:</p><div class="informalexample"><pre class="programlisting">server {
server_name www.example1.com;
location /downloads/ {
limit_rate 10k;
root /var/www/www.example1.com/downloads/;
}
..
}
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec08"/>How it works...</h2></div></div></div><p>This simple configuration will limit the<code class="literal"> /downloads</code> file downloading speed to 10k for all users.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec09"/>There's more...</h2></div></div></div><p>There are a lot more things that can be done with this rate limiting; the following configuration will let you limit the rate to 100k after the 1 megabyte of the file has been sent in full throttle to the client:</p><div class="informalexample"><pre class="programlisting">server {
server_name www.example1.com;
location /downloads/ {
limit_rate_after 1m;
limit_rate 100k;
root /var/www/www.example1.com/downloads/;
}
…
}
</pre></div></div></div>
<div class="section" title="Rate limiting search engine bots"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec06"/>Rate limiting search engine bots</h1></div></div></div><p>Till now we have learned about easy ways of blocking, request-limiting, and bandwidth-limiting all clients. We can start applying most of this knowledge to some problems that do come up in the production environment.<a class="indexterm" id="id111"/>
</p><p>Most of the time, it so happens that with content heavy sites, bots and search engines start using up more bandwidth than actual users. In such a scenario, where you want to make sure the actual users are not hindered, yet you have the SEO intact, you will want to rate limit search engine bots.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec10"/>How to do it...</h2></div></div></div><p>This following configuration, when placed within the location directive, will help you block and rate limit some bots:</p><div class="informalexample"><pre class="programlisting">if($http_user_agent ~ "Alexibot|Art-Online|asterias|BackDoorbot|Black.Hole|\
BlackWidow|BlowFish|botALot|BuiltbotTough|Bullseye|BunnySlippers|Cegbfeieh|Cheesebot") {
deny all;
}
if ($http_user_agent ~ Google|Yahoo|MSN|baidu) {
limit_rate 20k;
}
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec11"/>How it works...</h2></div></div></div><p>The idea is fairly simple, in cases where it is clear that the bot is not getting you traffic but only leeching your bandwidth, it is best to block them. But not all bots are bad. Googlebot, yahoobot and msnbot are all crucial for your search engine traffic to come through. It is a fine balance that has to be undertaken in situations where you have a high traffic site.<a class="indexterm" id="id112"/>
</p></div><div class="section" title="There's more...."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec12"/>There's more....</h2></div></div></div><p>You can use this situation to also ensure that your site gets very little spam traffic. It is clear that most commenting bots can be stopped with simple blacklisting of the<code class="literal"> HTTP_REFERER</code>, as shown in the following snippet:</p><div class="informalexample"><pre class="programlisting">if ($http_referer ~* (\.us$|dating|diamond|forsale|girl|jewelry|organic|poker|poweroversoftware|teen|webcam|zippo) ) {
deny all;
}
</pre></div></div></div>
<div class="section" title="Setting up GeoIP using the MaxMind country database"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec08"/>Setting up GeoIP using the MaxMind country database</h1></div></div></div><p>MaxMind is a company that specializes in generating databases which map countries and cities to IP ranges. It allows you to easily locate the geographic location of the end client. This information can be used to show the user geo-dependent data, or maybe redirect to server locations that can serve the end-client faster.<a class="indexterm" id="id113"/>
</p><p>In this recipe, we will install the MaxMind database in Nginx and show the usage of the GeoIP variables inside the Nginx configuration. Check out their demo at:<a class="ulink" href="http://www.maxmind.com/app/locate_my_ip"> http://www.maxmind.com/app/locate_my_ip</a>.</p><div class="mediaobject"><img alt="Setting up GeoIP using the MaxMind country database" height="236" src="graphics/4965_04_01.jpg"/></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec13"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"> Download the Geo-IP database or install the package:<a class="indexterm" id="id114"/><div class="informalexample"><pre class="programlisting">wget http://geolite.maxmind.com/download/geoip/database/GeoLiteCity.dat.gz
</pre></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: none">or</li></ul></div><div class="informalexample"><pre class="programlisting">aptitude install geoip-database
</pre></div></li><li class="listitem"> You will need to install some GeoIP libraries:<div class="informalexample"><pre class="programlisting">aptitude install libgeoip-dev
</pre></div></li><li class="listitem"> Then you configure Nginx for installing the GeoIP module as well. This assumes that you have already downloaded the Nginx codebase and have the compilation dependencies already installed. This has been covered in one of the earlier recipes as well.<div class="informalexample"><pre class="programlisting">./configure --with-http_geoip_module
</pre></div></li><li class="listitem"> We will then add the following configuration user the<code class="literal"> http</code> directive:<div class="informalexample"><pre class="programlisting">http {
geoip_country GeoIP.dat; # the country IP database
geoip_city GeoLiteCity.dat; # the city IP database
. . .
</pre></div></li></ol></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl2sec14"/>How it works...</h3></div></div></div><p>The preceding steps installs the databases and configures the GeoIP module in Nginx. This allows the configuration to access the following new variables. These variables can let you write geography specific rules!<a class="indexterm" id="id115"/>
</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left" width="2.10833337571886"/><col style="text-align: left" width="2.97361108991835"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Variable</p>
</th><th style="text-align: left" valign="bottom">
<p>Purpose</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">$geoip_city_country_code</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Two-letter country code, for example, "RU", "US".</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">$geoip_city_country_code3</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Three-letter country code, for example, "RUS", "USA".</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">$geoip_city_country_name</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The name of the country, for example, "Russian Federation", "United States" — if available.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">$geoip_region</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The name of the region (province, region, state, province, federal land, and the like), for example, "Moscow City", "DC" — if available.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">$geoip_city</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The name of the city, for example, "Moscow", "Washington", "Lisbon", &amp;c — if available.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">$geoip_postal_code</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Zip code or postal code — if available.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">$geoip_city_continent_code</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Continent if available</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">$geoip_latitude</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Latitude — if available.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">$geoip_longitude</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Longitude — if available.</p>
</td></tr></tbody></table></div></div></div></div>
<div class="section" title="Using the GeoIP module to set up access and rate control"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec10"/>Using the GeoIP module to set up access and rate control</h1></div></div></div><p>Now we come to an interesting part of Nginx, where we can use the GeoIP module to set up access and rate control.</p><p>For example, you can make your site inaccessible to a whole country depending on your needs. Hulu videos (<a class="ulink" href="http://www.hulu.com">http://www.hulu.com</a>) are not available to IPs outside of the United States. This is, of course, not completely fool-proof as there are anonymity networks that allow you to mask your actual IP or appear as if you are a client from the US.<a class="indexterm" id="id116"/>
</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec15"/>How to do it...</h2></div></div></div><p>This simple configuration, which assumes that you have already installed GeoIP as per the preceding recipe, will allow Bermuda users to access certain content while blocking Bhutan and Bolivia users from accessing the site:</p><div class="informalexample"><pre class="programlisting">http {
geoip_country GeoIP.dat; # the country IP database
geoip_city GeoLiteCity.dat; # the city IP database
...
server {
server_name www.example1.com;
...
location / {
If($geoip_city_country_code ~ BM) {
rate_limit 20k;
}
If($geoip_city_country_code ~ BT|BO) {
deny all;
}
...
}
...
}
</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec16"/>How it works...</h2></div></div></div><p>The idea behind the GeoIP module is simple. It basically looks at the remote client IP and fills up some variables which let you easily identify the various geographic attributes of the client. In this example, we are filtering requests that are from the Bermudas and rate limiting their bandwidth to 20k, while we are taking requests that are identified as coming from Bhutan and sending a 403 forbidden response to them.<a class="indexterm" id="id117"/>
</p><p>You can extend this to create alternate sites for different countries on the same URL. This is useful for language localization as well. Nginx is clearly state-of-the-art when it comes to GeoIP mapping.</p></div></div></body></html>